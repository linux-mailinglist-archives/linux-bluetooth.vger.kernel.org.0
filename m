Return-Path: <linux-bluetooth-owner@vger.kernel.org>
X-Original-To: lists+linux-bluetooth@lfdr.de
Delivered-To: lists+linux-bluetooth@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 578152793EF
	for <lists+linux-bluetooth@lfdr.de>; Sat, 26 Sep 2020 00:08:09 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726849AbgIYWII (ORCPT <rfc822;lists+linux-bluetooth@lfdr.de>);
        Fri, 25 Sep 2020 18:08:08 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40638 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726731AbgIYWII (ORCPT
        <rfc822;linux-bluetooth@vger.kernel.org>);
        Fri, 25 Sep 2020 18:08:08 -0400
Received: from mail-pg1-x534.google.com (mail-pg1-x534.google.com [IPv6:2607:f8b0:4864:20::534])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 603CAC0613CE
        for <linux-bluetooth@vger.kernel.org>; Fri, 25 Sep 2020 15:08:07 -0700 (PDT)
Received: by mail-pg1-x534.google.com with SMTP id e18so96855pgd.4
        for <linux-bluetooth@vger.kernel.org>; Fri, 25 Sep 2020 15:08:07 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:subject:date:message-id:mime-version
         :content-transfer-encoding;
        bh=vCijk7pQ9jnIswqIXhIq7tcI+pJ4eS2HVP3lBjK4vSo=;
        b=a2dMTuv1LJoH25LLYYBR14cFTuRnzxPDAFy7a9QslDgJkor4CR+nO2RbOAqOYyw9Vg
         YBnCUThQR+CfxDDK7Z5EKIpRlzsyRCB/Dh1f/49aOx+sCCWHQ1WP4vwb9TKg90axz/3I
         RLWPtOV2tOmxWmWy6vn4Ck9Yc08ancCr77FLEnEPT6gzL6WQx2YQsiH6x4X5EzPADLou
         e929ggAdLRtLD0AK2qcPtjmHigsMVCvfmtk0xak/PLTcEm0aFPLNdkNCGxhSOr+RdMT3
         00frU7W1ObSCEAYtluK2tME1lB+xrUrDi0cJG2ZubEbuOeXsGV+CT/vbFvSpnoIj8tZR
         ZJjg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:subject:date:message-id:mime-version
         :content-transfer-encoding;
        bh=vCijk7pQ9jnIswqIXhIq7tcI+pJ4eS2HVP3lBjK4vSo=;
        b=cFBwx5IDKUgtuheSz08M1iklpeIEmo3rsSp+2Y1LG4cqofN0WcuwUCmckSQOAE+NF2
         4iZzziZ+F/izxUnhoRYXLg0yhVviicBNgfXGEJLNxmYJq0URPgHpbfcFwsR9hH36DoCI
         svQS8Ww3uI8WEUL8wJM0kNki14IdC551USH7NGJSEL+3LwHHuD1VztFckIb6ntUi8uxd
         pOl88hhohOp2SscTu7NIinDZX6wV6x2+S75s1FyC1Cjd7T5ncnorgUDLTH9qbTK/NJxz
         hGsBbjy27g4IeoQOGdcS4ZgOanSuQbI5giTffMn0rWaSxzwKe/9sED1IWRemhWeFvFue
         DHxg==
X-Gm-Message-State: AOAM5338x3kDRgBqUzrqxFzhajgCABIdlfICRYbcHCOxIYJL4vZp9Ual
        0RYIXnR4GnCKoBl2kHjhH+YBPfd+vC0=
X-Google-Smtp-Source: ABdhPJzDK9o00gJNdM4V6VFgf4idB8QqSzOKI1ki6Q/z0UnoQKBTGDIRLfg1eW2yZJaT1wowYHzUNg==
X-Received: by 2002:a65:5249:: with SMTP id q9mr787527pgp.79.1601071683243;
        Fri, 25 Sep 2020 15:08:03 -0700 (PDT)
Received: from localhost.localdomain (c-71-56-157-77.hsd1.or.comcast.net. [71.56.157.77])
        by smtp.gmail.com with ESMTPSA id gx5sm148076pjb.57.2020.09.25.15.08.01
        for <linux-bluetooth@vger.kernel.org>
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Fri, 25 Sep 2020 15:08:01 -0700 (PDT)
From:   Luiz Augusto von Dentz <luiz.dentz@gmail.com>
To:     linux-bluetooth@vger.kernel.org
Subject: [RFC BlueZ] tools: Remove legacy code for CSR controllers
Date:   Fri, 25 Sep 2020 15:07:59 -0700
Message-Id: <20200925220759.3799735-1-luiz.dentz@gmail.com>
X-Mailer: git-send-email 2.26.2
MIME-Version: 1.0
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-bluetooth.vger.kernel.org>
X-Mailing-List: linux-bluetooth@vger.kernel.org

From: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>

This code has not been touched for ages and very unlikely that someone
will be using this nowadays as most of these controller specific
transports are handled by the kernel nowadays.
---
 Makefile.tools    |   17 +-
 tools/bccmd.1     |  130 ---
 tools/bccmd.c     | 1248 --------------------
 tools/csr.c       | 2856 ---------------------------------------------
 tools/csr.h       |  555 ---------
 tools/csr_3wire.c |   62 -
 tools/csr_bcsp.c  |  257 ----
 tools/csr_h4.c    |  166 ---
 tools/csr_hci.c   |  160 ---
 tools/csr_usb.c   |  308 -----
 tools/hciconfig.c |   28 -
 tools/ubcsp.c     | 1180 -------------------
 tools/ubcsp.h     |  208 ----
 13 files changed, 5 insertions(+), 7170 deletions(-)
 delete mode 100644 tools/bccmd.1
 delete mode 100644 tools/bccmd.c
 delete mode 100644 tools/csr.c
 delete mode 100644 tools/csr.h
 delete mode 100644 tools/csr_3wire.c
 delete mode 100644 tools/csr_bcsp.c
 delete mode 100644 tools/csr_h4.c
 delete mode 100644 tools/csr_hci.c
 delete mode 100644 tools/csr_usb.c
 delete mode 100644 tools/ubcsp.c
 delete mode 100644 tools/ubcsp.h

diff --git a/Makefile.tools b/Makefile.tools
index 0423293d6..d5fdf2d89 100644
--- a/Makefile.tools
+++ b/Makefile.tools
@@ -176,9 +176,8 @@ tools_userchan_tester_LDADD =3D lib/libbluetooth-intern=
al.la \
 endif
=20
 if TOOLS
-bin_PROGRAMS +=3D tools/rctest tools/l2test tools/l2ping tools/bccmd \
-			tools/bluemoon tools/hex2hcd tools/mpris-proxy \
-			tools/btattach
+bin_PROGRAMS +=3D tools/rctest tools/l2test tools/l2ping tools/bluemoon \
+		tools/hex2hcd tools/mpris-proxy tools/btattach
=20
 noinst_PROGRAMS +=3D tools/bdaddr tools/avinfo tools/avtest \
 			tools/scotest tools/amptest tools/hwdb \
@@ -278,12 +277,6 @@ tools_l2test_LDADD =3D lib/libbluetooth-internal.la
=20
 tools_l2ping_LDADD =3D lib/libbluetooth-internal.la
=20
-tools_bccmd_SOURCES =3D tools/bccmd.c tools/csr.h tools/csr.c \
-			tools/csr_hci.c tools/csr_usb.c \
-			tools/csr_h4.c tools/csr_3wire.c \
-			tools/csr_bcsp.c tools/ubcsp.h tools/ubcsp.c
-tools_bccmd_LDADD =3D lib/libbluetooth-internal.la
-
 tools_bluemoon_SOURCES =3D tools/bluemoon.c monitor/bt.h
 tools_bluemoon_LDADD =3D src/libshared-mainloop.la
=20
@@ -298,7 +291,7 @@ tools_gatt_service_LDADD =3D $(GLIB_LIBS) $(DBUS_LIBS) =
gdbus/libgdbus-internal.la
 profiles_iap_iapd_SOURCES =3D profiles/iap/main.c
 profiles_iap_iapd_LDADD =3D gdbus/libgdbus-internal.la $(GLIB_LIBS) $(DBUS=
_LIBS)
=20
-dist_man_MANS +=3D tools/rctest.1 tools/l2ping.1 tools/bccmd.1 tools/btatt=
ach.1
+dist_man_MANS +=3D tools/rctest.1 tools/l2ping.1 tools/btattach.1
=20
 EXTRA_DIST +=3D tools/bdaddr.1
=20
@@ -360,7 +353,7 @@ tools_hciattach_SOURCES =3D tools/hciattach.c tools/hci=
attach.h \
 						tools/hciattach_bcm43xx.c
 tools_hciattach_LDADD =3D lib/libbluetooth-internal.la
=20
-tools_hciconfig_SOURCES =3D tools/hciconfig.c tools/csr.h tools/csr.c
+tools_hciconfig_SOURCES =3D tools/hciconfig.c
 tools_hciconfig_LDADD =3D lib/libbluetooth-internal.la
=20
 tools_hcitool_SOURCES =3D tools/hcitool.c src/oui.h src/oui.c
@@ -409,7 +402,7 @@ EXTRA_DIST +=3D tools/hciattach.1 tools/hciconfig.1 \
 			tools/rfcomm.1 tools/sdptool.1 tools/ciptool.1
 endif
 else
-EXTRA_DIST +=3D tools/rctest.1 tools/l2ping.1 tools/bccmd.1 tools/btattach=
.1
+EXTRA_DIST +=3D tools/rctest.1 tools/l2ping.1 tools/btattach.1
 endif
=20
 if HID2HCI
diff --git a/tools/bccmd.1 b/tools/bccmd.1
deleted file mode 100644
index 26c83a6a2..000000000
--- a/tools/bccmd.1
+++ /dev/null
@@ -1,130 +0,0 @@
-.TH BCCMD 1 "Jun 20 2006" BlueZ "Linux System Administration"
-.SH NAME
-bccmd \- Utility for the CSR BCCMD interface
-.SH SYNOPSIS
-.B bccmd
-.br
-.B bccmd [-t <transport>] [-d <device>] <command> [<args>]
-.br
-.B bccmd [-h --help]
-.br
-.SH DESCRIPTION
-.B
-bccmd
-issues BlueCore commands to
-.B
-Cambridge Silicon Radio
-devices. If run without the <command> argument, a short help page will be =
displayed.
-.SH OPTIONS
-.TP
-.BI -t\ <transport>
-Specify the communication transport. Valid options are:
-.RS
-.TP
-.BI HCI
-Local device with Host Controller Interface (default).
-.TP
-.BI USB
-Direct USB connection.
-.TP
-.BI BCSP
-Blue Core Serial Protocol.
-.TP
-.BI H4
-H4 serial protocol.
-.TP
-.BI 3WIRE
-3WIRE protocol (not implemented).
-.SH
-.TP
-.BI -d\ <dev>
-Specify a particular device to operate on. If not specified, default is th=
e first available HCI device
-or /dev/ttyS0 for serial transports.
-.SH COMMANDS
-.TP
-.BI builddef
-Get build definitions
-.TP
-.BI keylen\ <handle>
-Get current crypt key length
-.TP
-.BI clock
-Get local Bluetooth clock
-.TP
-.BI rand
-Get random number
-.TP
-.BI chiprev
-Get chip revision
-.TP
-.BI buildname
-Get the full build name
-.TP
-.BI panicarg
-Get panic code argument
-.TP
-.BI faultarg
-Get fault code argument
-.TP
-.BI coldreset
-Perform cold reset
-.TP
-.BI warmreset
-Perform warm reset
-.TP
-.BI disabletx
-Disable TX on the device
-.TP
-.BI enabletx
-Enable TX on the device
-.TP
-.BI singlechan\ <channel>
-Lock radio on specific channel
-.TP
-.BI hoppingon
-Revert to channel hopping
-.TP
-.BI rttxdata1\ <decimal\ freq\ MHz>\ <level>
-TXData1 radio test
-.TP
-.BI radiotest\ <decimal\ freq\ MHz>\ <level>\ <id>
-Run radio tests, tests 4, 6 and 7 are transmit tests
-.TP
-.BI memtypes
-Get memory types
-.TP
-.BI psget\ [-r]\ [-s\ <stores>]\ <key>
-Get value for PS key.
--r sends a warm reset afterwards
-.TP
-.BI psset\ [-r]\ [-s\ <stores>]\ <key>\ <value>
-Set value for PS key.
--r sends a warm reset afterwards
-.TP
-.BI psclr\ [-r]\ [-s\ <stores>]\ <key>
-Clear value for PS key.
--r sends a warm reset afterwards
-.TP
-.BI pslist\ [-r]\ [-s\ <stores>]
-List all PS keys.
--r sends a warm reset afterwards
-.TP
-.BI psread\ [-r]\ [-s\ <stores>]
-Read all PS keys.
--r sends a warm reset afterwards
-.TP
-.BI psload\ [-r]\ [-s\ <stores>]\ <file>
-Load all PS keys from PSR file.
--r sends a warm reset afterwards
-.TP
-.BI pscheck\ [-r]\ [-s\ <stores>]\ <file>
-Check syntax of PSR file.
--r sends a warm reset afterwards
-.SH KEYS
-bdaddr country devclass keymin keymax features commands version
-remver hciextn mapsco baudrate hostintf anafreq anaftrim usbvid
-usbpid dfupid bootmode
-.SH AUTHORS
-Written by Marcel Holtmann <marcel@holtmann.org>,
-man page by Adam Laurie <adam@algroup.co.uk>
-.PP
diff --git a/tools/bccmd.c b/tools/bccmd.c
deleted file mode 100644
index 2c215ace7..000000000
--- a/tools/bccmd.c
+++ /dev/null
@@ -1,1248 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 =
 USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <sys/socket.h>
-#include <unistd.h>
-
-#include "lib/bluetooth.h"
-#include "lib/hci.h"
-#include "lib/hci_lib.h"
-
-#include "src/shared/tty.h"
-
-#include "csr.h"
-
-#define CSR_TRANSPORT_UNKNOWN	0
-#define CSR_TRANSPORT_HCI	1
-#define CSR_TRANSPORT_USB	2
-#define CSR_TRANSPORT_BCSP	3
-#define CSR_TRANSPORT_H4	4
-#define CSR_TRANSPORT_3WIRE	5
-
-#define CSR_STORES_PSI		(0x0001)
-#define CSR_STORES_PSF		(0x0002)
-#define CSR_STORES_PSROM	(0x0004)
-#define CSR_STORES_PSRAM	(0x0008)
-#define CSR_STORES_DEFAULT	(CSR_STORES_PSI | CSR_STORES_PSF)
-
-#define CSR_TYPE_NULL		0
-#define CSR_TYPE_COMPLEX	1
-#define CSR_TYPE_UINT8		2
-#define CSR_TYPE_UINT16		3
-#define CSR_TYPE_UINT32		4
-
-#define CSR_TYPE_ARRAY		CSR_TYPE_COMPLEX
-#define CSR_TYPE_BDADDR		CSR_TYPE_COMPLEX
-
-static inline int transport_open(int transport, char *device, speed_t bcsp=
_rate)
-{
-	switch (transport) {
-	case CSR_TRANSPORT_HCI:
-		return csr_open_hci(device);
-	case CSR_TRANSPORT_USB:
-		return csr_open_usb(device);
-	case CSR_TRANSPORT_BCSP:
-		return csr_open_bcsp(device, bcsp_rate);
-	case CSR_TRANSPORT_H4:
-		return csr_open_h4(device);
-	case CSR_TRANSPORT_3WIRE:
-		return csr_open_3wire(device);
-	default:
-		fprintf(stderr, "Unsupported transport\n");
-		return -1;
-	}
-}
-
-static inline int transport_read(int transport, uint16_t varid, uint8_t *v=
alue, uint16_t length)
-{
-	switch (transport) {
-	case CSR_TRANSPORT_HCI:
-		return csr_read_hci(varid, value, length);
-	case CSR_TRANSPORT_USB:
-		return csr_read_usb(varid, value, length);
-	case CSR_TRANSPORT_BCSP:
-		return csr_read_bcsp(varid, value, length);
-	case CSR_TRANSPORT_H4:
-		return csr_read_h4(varid, value, length);
-	case CSR_TRANSPORT_3WIRE:
-		return csr_read_3wire(varid, value, length);
-	default:
-		errno =3D EOPNOTSUPP;
-		return -1;
-	}
-}
-
-static inline int transport_write(int transport, uint16_t varid, uint8_t *=
value, uint16_t length)
-{
-	switch (transport) {
-	case CSR_TRANSPORT_HCI:
-		return csr_write_hci(varid, value, length);
-	case CSR_TRANSPORT_USB:
-		return csr_write_usb(varid, value, length);
-	case CSR_TRANSPORT_BCSP:
-		return csr_write_bcsp(varid, value, length);
-	case CSR_TRANSPORT_H4:
-		return csr_write_h4(varid, value, length);
-	case CSR_TRANSPORT_3WIRE:
-		return csr_write_3wire(varid, value, length);
-	default:
-		errno =3D EOPNOTSUPP;
-		return -1;
-	}
-}
-
-static inline void transport_close(int transport)
-{
-	switch (transport) {
-	case CSR_TRANSPORT_HCI:
-		csr_close_hci();
-		break;
-	case CSR_TRANSPORT_USB:
-		csr_close_usb();
-		break;
-	case CSR_TRANSPORT_BCSP:
-		csr_close_bcsp();
-		break;
-	case CSR_TRANSPORT_H4:
-		csr_close_h4();
-		break;
-	case CSR_TRANSPORT_3WIRE:
-		csr_close_3wire();
-		break;
-	}
-}
-
-static struct {
-	uint16_t pskey;
-	int type;
-	int size;
-	char *str;
-} storage[] =3D {
-	{ CSR_PSKEY_BDADDR,                   CSR_TYPE_BDADDR,  8,  "bdaddr"   },
-	{ CSR_PSKEY_COUNTRYCODE,              CSR_TYPE_UINT16,  0,  "country"  },
-	{ CSR_PSKEY_CLASSOFDEVICE,            CSR_TYPE_UINT32,  0,  "devclass" },
-	{ CSR_PSKEY_ENC_KEY_LMIN,             CSR_TYPE_UINT16,  0,  "keymin"   },
-	{ CSR_PSKEY_ENC_KEY_LMAX,             CSR_TYPE_UINT16,  0,  "keymax"   },
-	{ CSR_PSKEY_LOCAL_SUPPORTED_FEATURES, CSR_TYPE_ARRAY,   8,  "features" },
-	{ CSR_PSKEY_LOCAL_SUPPORTED_COMMANDS, CSR_TYPE_ARRAY,   18, "commands" },
-	{ CSR_PSKEY_HCI_LMP_LOCAL_VERSION,    CSR_TYPE_UINT16,  0,  "version"  },
-	{ CSR_PSKEY_LMP_REMOTE_VERSION,       CSR_TYPE_UINT8,   0,  "remver"   },
-	{ CSR_PSKEY_HOSTIO_USE_HCI_EXTN,      CSR_TYPE_UINT16,  0,  "hciextn"  },
-	{ CSR_PSKEY_HOSTIO_MAP_SCO_PCM,       CSR_TYPE_UINT16,  0,  "mapsco"   },
-	{ CSR_PSKEY_UART_BAUDRATE,            CSR_TYPE_UINT16,  0,  "baudrate" },
-	{ CSR_PSKEY_HOST_INTERFACE,           CSR_TYPE_UINT16,  0,  "hostintf" },
-	{ CSR_PSKEY_ANA_FREQ,                 CSR_TYPE_UINT16,  0,  "anafreq"  },
-	{ CSR_PSKEY_ANA_FTRIM,                CSR_TYPE_UINT16,  0,  "anaftrim" },
-	{ CSR_PSKEY_USB_VENDOR_ID,            CSR_TYPE_UINT16,  0,  "usbvid"   },
-	{ CSR_PSKEY_USB_PRODUCT_ID,           CSR_TYPE_UINT16,  0,  "usbpid"   },
-	{ CSR_PSKEY_USB_DFU_PRODUCT_ID,       CSR_TYPE_UINT16,  0,  "dfupid"   },
-	{ CSR_PSKEY_INITIAL_BOOTMODE,         CSR_TYPE_UINT16,  0,  "bootmode" },
-	{ 0x0000 },
-};
-
-static char *storestostr(uint16_t stores)
-{
-	switch (stores) {
-	case 0x0000:
-		return "Default";
-	case 0x0001:
-		return "psi";
-	case 0x0002:
-		return "psf";
-	case 0x0004:
-		return "psrom";
-	case 0x0008:
-		return "psram";
-	default:
-		return "Unknown";
-	}
-}
-
-static char *memorytostr(uint16_t type)
-{
-	switch (type) {
-	case 0x0000:
-		return "Flash memory";
-	case 0x0001:
-		return "EEPROM";
-	case 0x0002:
-		return "RAM (transient)";
-	case 0x0003:
-		return "ROM (or \"read-only\" flash memory)";
-	default:
-		return "Unknown";
-	}
-}
-
-#define OPT_RANGE(min, max) \
-		if (argc < (min)) { errno =3D EINVAL; return -1; } \
-		if (argc > (max)) { errno =3D E2BIG; return -1; }
-
-static struct option help_options[] =3D {
-	{ "help",	0, 0, 'h' },
-	{ 0, 0, 0, 0 }
-};
-
-static int opt_help(int argc, char *argv[], int *help)
-{
-	int opt;
-
-	while ((opt=3Dgetopt_long(argc, argv, "+h", help_options, NULL)) !=3D EOF=
) {
-		switch (opt) {
-		case 'h':
-			if (help)
-				*help =3D 1;
-			break;
-		}
-	}
-
-	return optind;
-}
-
-#define OPT_HELP(range, help) \
-		opt_help(argc, argv, (help)); \
-		argc -=3D optind; argv +=3D optind; optind =3D 0; \
-		OPT_RANGE((range), (range))
-
-static int cmd_builddef(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t def =3D 0x0000, nextdef =3D 0x0000;
-	int err =3D 0;
-
-	OPT_HELP(0, NULL);
-
-	printf("Build definitions:\n");
-
-	while (1) {
-		memset(array, 0, sizeof(array));
-		array[0] =3D def & 0xff;
-		array[1] =3D def >> 8;
-
-		err =3D transport_read(transport, CSR_VARID_GET_NEXT_BUILDDEF, array, 8);
-		if (err < 0)
-			break;
-
-		nextdef =3D array[2] | (array[3] << 8);
-
-		if (nextdef =3D=3D 0x0000)
-			break;
-
-		def =3D nextdef;
-
-		printf("0x%04x - %s\n", def, csr_builddeftostr(def));
-	}
-
-	return err;
-}
-
-static int cmd_keylen(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t handle, keylen;
-	int err;
-
-	OPT_HELP(1, NULL);
-
-	handle =3D atoi(argv[0]);
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D handle & 0xff;
-	array[1] =3D handle >> 8;
-
-	err =3D transport_read(transport, CSR_VARID_CRYPT_KEY_LENGTH, array, 8);
-	if (err < 0)
-		return -1;
-
-	keylen =3D array[2] | (array[3] << 8);
-
-	printf("Crypt key length: %d bit\n", keylen * 8);
-
-	return 0;
-}
-
-static int cmd_clock(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint32_t clock;
-	int err;
-
-	OPT_HELP(0, NULL);
-
-	memset(array, 0, sizeof(array));
-
-	err =3D transport_read(transport, CSR_VARID_BT_CLOCK, array, 8);
-	if (err < 0)
-		return -1;
-
-	clock =3D array[2] | (array[3] << 8) | (array[0] << 16) | (array[1] << 24=
);
-
-	printf("Bluetooth clock: 0x%04x (%d)\n", clock, clock);
-
-	return 0;
-}
-
-static int cmd_rand(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t rand;
-	int err;
-
-	OPT_HELP(0, NULL);
-
-	memset(array, 0, sizeof(array));
-
-	err =3D transport_read(transport, CSR_VARID_RAND, array, 8);
-	if (err < 0)
-		return -1;
-
-	rand =3D array[0] | (array[1] << 8);
-
-	printf("Random number: 0x%02x (%d)\n", rand, rand);
-
-	return 0;
-}
-
-static int cmd_chiprev(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t rev;
-	char *str;
-	int err;
-
-	OPT_HELP(0, NULL);
-
-	memset(array, 0, sizeof(array));
-
-	err =3D transport_read(transport, CSR_VARID_CHIPREV, array, 8);
-	if (err < 0)
-		return -1;
-
-	rev =3D array[0] | (array[1] << 8);
-
-	switch (rev) {
-	case 0x64:
-		str =3D "BC1 ES";
-		break;
-	case 0x65:
-		str =3D "BC1";
-		break;
-	case 0x89:
-		str =3D "BC2-External A";
-		break;
-	case 0x8a:
-		str =3D "BC2-External B";
-		break;
-	case 0x28:
-		str =3D "BC2-ROM";
-		break;
-	case 0x43:
-		str =3D "BC3-Multimedia";
-		break;
-	case 0x15:
-		str =3D "BC3-ROM";
-		break;
-	case 0xe2:
-		str =3D "BC3-Flash";
-		break;
-	case 0x26:
-		str =3D "BC4-External";
-		break;
-	case 0x30:
-		str =3D "BC4-ROM";
-		break;
-	default:
-		str =3D "NA";
-		break;
-	}
-
-	printf("Chip revision: 0x%04x (%s)\n", rev, str);
-
-	return 0;
-}
-
-static int cmd_buildname(int transport, int argc, char *argv[])
-{
-	uint8_t array[131];
-	char name[64];
-	unsigned int i;
-	int err;
-
-	OPT_HELP(0, NULL);
-
-	memset(array, 0, sizeof(array));
-
-	err =3D transport_read(transport, CSR_VARID_READ_BUILD_NAME, array, 128);
-	if (err < 0)
-		return -1;
-
-	for (i =3D 0; i < sizeof(name); i++)
-		name[i] =3D array[(i * 2) + 4];
-
-	printf("Build name: %s\n", name);
-
-	return 0;
-}
-
-static int cmd_panicarg(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t error;
-	int err;
-
-	OPT_HELP(0, NULL);
-
-	memset(array, 0, sizeof(array));
-
-	err =3D transport_read(transport, CSR_VARID_PANIC_ARG, array, 8);
-	if (err < 0)
-		return -1;
-
-	error =3D array[0] | (array[1] << 8);
-
-	printf("Panic code: 0x%02x (%s)\n", error,
-					error < 0x100 ? "valid" : "invalid");
-
-	return 0;
-}
-
-static int cmd_faultarg(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t error;
-	int err;
-
-	OPT_HELP(0, NULL);
-
-	memset(array, 0, sizeof(array));
-
-	err =3D transport_read(transport, CSR_VARID_FAULT_ARG, array, 8);
-	if (err < 0)
-		return -1;
-
-	error =3D array[0] | (array[1] << 8);
-
-	printf("Fault code: 0x%02x (%s)\n", error,
-					error < 0x100 ? "valid" : "invalid");
-
-	return 0;
-}
-
-static int cmd_coldreset(int transport, int argc, char *argv[])
-{
-	return transport_write(transport, CSR_VARID_COLD_RESET, NULL, 0);
-}
-
-static int cmd_warmreset(int transport, int argc, char *argv[])
-{
-	return transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
-}
-
-static int cmd_disabletx(int transport, int argc, char *argv[])
-{
-	return transport_write(transport, CSR_VARID_DISABLE_TX, NULL, 0);
-}
-
-static int cmd_enabletx(int transport, int argc, char *argv[])
-{
-	return transport_write(transport, CSR_VARID_ENABLE_TX, NULL, 0);
-}
-
-static int cmd_singlechan(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t channel;
-
-	OPT_HELP(1, NULL);
-
-	channel =3D atoi(argv[0]);
-
-	if (channel > 2401 && channel < 2481)
-		channel -=3D 2402;
-
-	if (channel > 78) {
-		errno =3D EINVAL;
-		return -1;
-	}
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D channel & 0xff;
-	array[1] =3D channel >> 8;
-
-	return transport_write(transport, CSR_VARID_SINGLE_CHAN, array, 8);
-}
-
-static int cmd_hoppingon(int transport, int argc, char *argv[])
-{
-	return transport_write(transport, CSR_VARID_HOPPING_ON, NULL, 0);
-}
-
-static int cmd_rttxdata1(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t freq, level;
-
-	OPT_HELP(2, NULL);
-
-	freq =3D atoi(argv[0]);
-
-	if (!strncasecmp(argv[1], "0x", 2))
-		level =3D strtol(argv[1], NULL, 16);
-	else
-		level =3D atoi(argv[1]);
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D 0x04;
-	array[1] =3D 0x00;
-	array[2] =3D freq & 0xff;
-	array[3] =3D freq >> 8;
-	array[4] =3D level & 0xff;
-	array[5] =3D level >> 8;
-
-	return transport_write(transport, CSR_VARID_RADIOTEST, array, 8);
-}
-
-static int cmd_radiotest(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t freq, level, test;
-
-	OPT_HELP(3, NULL);
-
-	freq =3D atoi(argv[0]);
-
-	if (!strncasecmp(argv[1], "0x", 2))
-		level =3D strtol(argv[1], NULL, 16);
-	else
-		level =3D atoi(argv[1]);
-
-	test =3D atoi(argv[2]);
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D test & 0xff;
-	array[1] =3D test >> 8;
-	array[2] =3D freq & 0xff;
-	array[3] =3D freq >> 8;
-	array[4] =3D level & 0xff;
-	array[5] =3D level >> 8;
-
-	return transport_write(transport, CSR_VARID_RADIOTEST, array, 8);
-}
-
-static int cmd_memtypes(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t type, stores[4] =3D { 0x0001, 0x0002, 0x0004, 0x0008 };
-	int i, err;
-
-	OPT_HELP(0, NULL);
-
-	for (i =3D 0; i < 4; i++) {
-		memset(array, 0, sizeof(array));
-		array[0] =3D stores[i] & 0xff;
-		array[1] =3D stores[i] >> 8;
-
-		err =3D transport_read(transport, CSR_VARID_PS_MEMORY_TYPE, array, 8);
-		if (err < 0)
-			continue;
-
-		type =3D array[2] + (array[3] << 8);
-
-		printf("%s (0x%04x) =3D %s (%d)\n", storestostr(stores[i]),
-					stores[i], memorytostr(type), type);
-	}
-
-	return 0;
-}
-
-static struct option pskey_options[] =3D {
-	{ "stores",	1, 0, 's' },
-	{ "reset",	0, 0, 'r' },
-	{ "help",	0, 0, 'h' },
-	{ 0, 0, 0, 0 }
-};
-
-static int opt_pskey(int argc, char *argv[], uint16_t *stores, int *reset,=
 int *help)
-{
-	int opt;
-
-	while ((opt=3Dgetopt_long(argc, argv, "+s:rh", pskey_options, NULL)) !=3D=
 EOF) {
-		switch (opt) {
-		case 's':
-			if (!stores)
-				break;
-			if (!strcasecmp(optarg, "default"))
-				*stores =3D 0x0000;
-			else if (!strcasecmp(optarg, "implementation"))
-				*stores =3D 0x0001;
-			else if (!strcasecmp(optarg, "factory"))
-				*stores =3D 0x0002;
-			else if (!strcasecmp(optarg, "rom"))
-				*stores =3D 0x0004;
-			else if (!strcasecmp(optarg, "ram"))
-				*stores =3D 0x0008;
-			else if (!strcasecmp(optarg, "psi"))
-				*stores =3D 0x0001;
-			else if (!strcasecmp(optarg, "psf"))
-				*stores =3D 0x0002;
-			else if (!strcasecmp(optarg, "psrom"))
-				*stores =3D 0x0004;
-			else if (!strcasecmp(optarg, "psram"))
-				*stores =3D 0x0008;
-			else if (!strncasecmp(optarg, "0x", 2))
-				*stores =3D strtol(optarg, NULL, 16);
-			else
-				*stores =3D atoi(optarg);
-			break;
-
-		case 'r':
-			if (reset)
-				*reset =3D 1;
-			break;
-
-		case 'h':
-			if (help)
-				*help =3D 1;
-			break;
-		}
-	}
-
-	return optind;
-}
-
-#define OPT_PSKEY(min, max, stores, reset, help) \
-		opt_pskey(argc, argv, (stores), (reset), (help)); \
-		argc -=3D optind; argv +=3D optind; optind =3D 0; \
-		OPT_RANGE((min), (max))
-
-static int cmd_psget(int transport, int argc, char *argv[])
-{
-	uint8_t array[128];
-	uint16_t pskey, length, value, stores =3D CSR_STORES_DEFAULT;
-	uint32_t val32;
-	int i, err, reset =3D 0;
-
-	memset(array, 0, sizeof(array));
-
-	OPT_PSKEY(1, 1, &stores, &reset, NULL);
-
-	if (strncasecmp(argv[0], "0x", 2)) {
-		pskey =3D atoi(argv[0]);
-
-		for (i =3D 0; storage[i].pskey; i++) {
-			if (strcasecmp(storage[i].str, argv[0]))
-				continue;
-
-			pskey =3D storage[i].pskey;
-			break;
-		}
-	} else
-		pskey =3D strtol(argv[0] + 2, NULL, 16);
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D pskey & 0xff;
-	array[1] =3D pskey >> 8;
-	array[2] =3D stores & 0xff;
-	array[3] =3D stores >> 8;
-
-	err =3D transport_read(transport, CSR_VARID_PS_SIZE, array, 8);
-	if (err < 0)
-		return err;
-
-	length =3D array[2] + (array[3] << 8);
-	if (length + 6 > (int) sizeof(array) / 2)
-		return -EIO;
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D pskey & 0xff;
-	array[1] =3D pskey >> 8;
-	array[2] =3D length & 0xff;
-	array[3] =3D length >> 8;
-	array[4] =3D stores & 0xff;
-	array[5] =3D stores >> 8;
-
-	err =3D transport_read(transport, CSR_VARID_PS, array, (length + 3) * 2);
-	if (err < 0)
-		return err;
-
-	switch (length) {
-	case 1:
-		value =3D array[6] | (array[7] << 8);
-		printf("%s: 0x%04x (%d)\n", csr_pskeytostr(pskey), value, value);
-		break;
-
-	case 2:
-		val32 =3D array[8] | (array[9] << 8) | (array[6] << 16) | (array[7] << 2=
4);
-		printf("%s: 0x%08x (%d)\n", csr_pskeytostr(pskey), val32, val32);
-		break;
-
-	default:
-		printf("%s:", csr_pskeytostr(pskey));
-		for (i =3D 0; i < length; i++)
-			printf(" 0x%02x%02x", array[(i * 2) + 6], array[(i * 2) + 7]);
-		printf("\n");
-		break;
-	}
-
-	if (reset)
-		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
-
-	return err;
-}
-
-static int cmd_psset(int transport, int argc, char *argv[])
-{
-	uint8_t array[128];
-	uint16_t pskey, length, value, stores =3D CSR_STORES_PSRAM;
-	uint32_t val32;
-	int i, err, reset =3D 0;
-
-	memset(array, 0, sizeof(array));
-
-	OPT_PSKEY(2, 81, &stores, &reset, NULL);
-
-	if (strncasecmp(argv[0], "0x", 2)) {
-		pskey =3D atoi(argv[0]);
-
-		for (i =3D 0; storage[i].pskey; i++) {
-			if (strcasecmp(storage[i].str, argv[0]))
-				continue;
-
-			pskey =3D storage[i].pskey;
-			break;
-		}
-	} else
-		pskey =3D strtol(argv[0] + 2, NULL, 16);
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D pskey & 0xff;
-	array[1] =3D pskey >> 8;
-	array[2] =3D stores & 0xff;
-	array[3] =3D stores >> 8;
-
-	err =3D transport_read(transport, CSR_VARID_PS_SIZE, array, 8);
-	if (err < 0)
-		return err;
-
-	length =3D array[2] + (array[3] << 8);
-	if (length + 6 > (int) sizeof(array) / 2)
-		return -EIO;
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D pskey & 0xff;
-	array[1] =3D pskey >> 8;
-	array[2] =3D length & 0xff;
-	array[3] =3D length >> 8;
-	array[4] =3D stores & 0xff;
-	array[5] =3D stores >> 8;
-
-	argc--;
-	argv++;
-
-	switch (length) {
-	case 1:
-		if (argc !=3D 1) {
-			errno =3D E2BIG;
-			return -1;
-		}
-
-		if (!strncasecmp(argv[0], "0x", 2))
-			value =3D strtol(argv[0] + 2, NULL, 16);
-		else
-			value =3D atoi(argv[0]);
-
-		array[6] =3D value & 0xff;
-		array[7] =3D value >> 8;
-		break;
-
-	case 2:
-		if (argc !=3D 1) {
-			errno =3D E2BIG;
-			return -1;
-		}
-
-		if (!strncasecmp(argv[0], "0x", 2))
-			val32 =3D strtol(argv[0] + 2, NULL, 16);
-		else
-			val32 =3D atoi(argv[0]);
-
-		array[6] =3D (val32 & 0xff0000) >> 16;
-		array[7] =3D val32 >> 24;
-		array[8] =3D val32 & 0xff;
-		array[9] =3D (val32 & 0xff00) >> 8;
-		break;
-
-	default:
-		if (argc !=3D length * 2) {
-			errno =3D EINVAL;
-			return -1;
-		}
-
-		for (i =3D 0; i < length * 2; i++)
-			if (!strncasecmp(argv[0], "0x", 2))
-				array[i + 6] =3D strtol(argv[i] + 2, NULL, 16);
-			else
-				array[i + 6] =3D atoi(argv[i]);
-		break;
-	}
-
-	err =3D transport_write(transport, CSR_VARID_PS, array, (length + 3) * 2);
-	if (err < 0)
-		return err;
-
-	if (reset)
-		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
-
-	return err;
-}
-
-static int cmd_psclr(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t pskey, stores =3D CSR_STORES_PSRAM;
-	int i, err, reset =3D 0;
-
-	OPT_PSKEY(1, 1, &stores, &reset, NULL);
-
-	if (strncasecmp(argv[0], "0x", 2)) {
-		pskey =3D atoi(argv[0]);
-
-		for (i =3D 0; storage[i].pskey; i++) {
-			if (strcasecmp(storage[i].str, argv[0]))
-				continue;
-
-			pskey =3D storage[i].pskey;
-			break;
-		}
-	} else
-		pskey =3D strtol(argv[0] + 2, NULL, 16);
-
-	memset(array, 0, sizeof(array));
-	array[0] =3D pskey & 0xff;
-	array[1] =3D pskey >> 8;
-	array[2] =3D stores & 0xff;
-	array[3] =3D stores >> 8;
-
-	err =3D transport_write(transport, CSR_VARID_PS_CLR_STORES, array, 8);
-	if (err < 0)
-		return err;
-
-	if (reset)
-		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
-
-	return err;
-}
-
-static int cmd_pslist(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t pskey =3D 0x0000, length, stores =3D CSR_STORES_DEFAULT;
-	int err, reset =3D 0;
-
-	OPT_PSKEY(0, 0, &stores, &reset, NULL);
-
-	while (1) {
-		memset(array, 0, sizeof(array));
-		array[0] =3D pskey & 0xff;
-		array[1] =3D pskey >> 8;
-		array[2] =3D stores & 0xff;
-		array[3] =3D stores >> 8;
-
-		err =3D transport_read(transport, CSR_VARID_PS_NEXT, array, 8);
-		if (err < 0)
-			break;
-
-		pskey =3D array[4] + (array[5] << 8);
-		if (pskey =3D=3D 0x0000)
-			break;
-
-		memset(array, 0, sizeof(array));
-		array[0] =3D pskey & 0xff;
-		array[1] =3D pskey >> 8;
-		array[2] =3D stores & 0xff;
-		array[3] =3D stores >> 8;
-
-		err =3D transport_read(transport, CSR_VARID_PS_SIZE, array, 8);
-		if (err < 0)
-			continue;
-
-		length =3D array[2] + (array[3] << 8);
-
-		printf("0x%04x - %s (%d bytes)\n", pskey,
-					csr_pskeytostr(pskey), length * 2);
-	}
-
-	if (reset)
-		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
-
-	return 0;
-}
-
-static int cmd_psread(int transport, int argc, char *argv[])
-{
-	uint8_t array[256];
-	uint16_t pskey =3D 0x0000, length, stores =3D CSR_STORES_DEFAULT;
-	char *str, val[7];
-	int i, err, reset =3D 0;
-
-	OPT_PSKEY(0, 0, &stores, &reset, NULL);
-
-	while (1) {
-		memset(array, 0, sizeof(array));
-		array[0] =3D pskey & 0xff;
-		array[1] =3D pskey >> 8;
-		array[2] =3D stores & 0xff;
-		array[3] =3D stores >> 8;
-
-		err =3D transport_read(transport, CSR_VARID_PS_NEXT, array, 8);
-		if (err < 0)
-			break;
-
-		pskey =3D array[4] + (array[5] << 8);
-		if (pskey =3D=3D 0x0000)
-			break;
-
-		memset(array, 0, sizeof(array));
-		array[0] =3D pskey & 0xff;
-		array[1] =3D pskey >> 8;
-		array[2] =3D stores & 0xff;
-		array[3] =3D stores >> 8;
-
-		err =3D transport_read(transport, CSR_VARID_PS_SIZE, array, 8);
-		if (err < 0)
-			continue;
-
-		length =3D array[2] + (array[3] << 8);
-		if (length + 6 > (int) sizeof(array) / 2)
-			continue;
-
-		memset(array, 0, sizeof(array));
-		array[0] =3D pskey & 0xff;
-		array[1] =3D pskey >> 8;
-		array[2] =3D length & 0xff;
-		array[3] =3D length >> 8;
-		array[4] =3D stores & 0xff;
-		array[5] =3D stores >> 8;
-
-		err =3D transport_read(transport, CSR_VARID_PS, array, (length + 3) * 2);
-		if (err < 0)
-			continue;
-
-		str =3D csr_pskeytoval(pskey);
-		if (!strcasecmp(str, "UNKNOWN")) {
-			sprintf(val, "0x%04x", pskey);
-			str =3D NULL;
-		}
-
-		printf("// %s%s\n&%04x =3D", str ? "PSKEY_" : "",
-						str ? str : val, pskey);
-		for (i =3D 0; i < length; i++)
-			printf(" %02x%02x", array[(i * 2) + 7], array[(i * 2) + 6]);
-		printf("\n");
-	}
-
-	if (reset)
-		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
-
-	return 0;
-}
-
-static int cmd_psload(int transport, int argc, char *argv[])
-{
-	uint8_t array[256];
-	uint16_t pskey, length, size, stores =3D CSR_STORES_PSRAM;
-	char *str, val[7];
-	int err, reset =3D 0;
-
-	OPT_PSKEY(1, 1, &stores, &reset, NULL);
-
-	psr_read(argv[0]);
-
-	memset(array, 0, sizeof(array));
-	size =3D sizeof(array) - 6;
-
-	while (psr_get(&pskey, array + 6, &size) =3D=3D 0) {
-		str =3D csr_pskeytoval(pskey);
-		if (!strcasecmp(str, "UNKNOWN")) {
-			sprintf(val, "0x%04x", pskey);
-			str =3D NULL;
-		}
-
-		printf("Loading %s%s ... ", str ? "PSKEY_" : "",
-							str ? str : val);
-		fflush(stdout);
-
-		length =3D size / 2;
-
-		array[0] =3D pskey & 0xff;
-		array[1] =3D pskey >> 8;
-		array[2] =3D length & 0xff;
-		array[3] =3D length >> 8;
-		array[4] =3D stores & 0xff;
-		array[5] =3D stores >> 8;
-
-		err =3D transport_write(transport, CSR_VARID_PS, array, size + 6);
-
-		printf("%s\n", err < 0 ? "failed" : "done");
-
-		memset(array, 0, sizeof(array));
-		size =3D sizeof(array) - 6;
-	}
-
-	if (reset)
-		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
-
-	return 0;
-}
-
-static int cmd_pscheck(int transport, int argc, char *argv[])
-{
-	uint8_t array[256];
-	uint16_t pskey, size;
-	int i;
-
-	OPT_HELP(1, NULL);
-
-	psr_read(argv[0]);
-
-	while (psr_get(&pskey, array, &size) =3D=3D 0) {
-		printf("0x%04x =3D", pskey);
-		for (i =3D 0; i < size; i++)
-			printf(" 0x%02x", array[i]);
-		printf("\n");
-	}
-
-	return 0;
-}
-
-static int cmd_adc(int transport, int argc, char *argv[])
-{
-	uint8_t array[8];
-	uint16_t mux, value;
-	int err;
-
-	OPT_HELP(1, NULL);
-
-	if (!strncasecmp(argv[0], "0x", 2))
-		mux =3D strtol(argv[0], NULL, 16);
-	else
-		mux =3D atoi(argv[0]);
-
-	/* Request an ADC read from a particular mux'ed input */
-	memset(array, 0, sizeof(array));
-	array[0] =3D mux & 0xff;
-	array[1] =3D mux >> 8;
-
-	err =3D transport_write(transport, CSR_VARID_ADC, array, 2);
-	if (err < 0) {
-		errno =3D -err;
-		return -1;
-	}
-
-	/* have to wait a short while, then read result */
-	usleep(50000);
-	err =3D transport_read(transport, CSR_VARID_ADC_RES, array, 8);
-	if (err < 0) {
-		errno =3D -err;
-		return -1;
-	}
-
-	mux =3D array[0] | (array[1] << 8);
-	value =3D array[4] | (array[5] << 8);
-
-	printf("ADC value from Mux 0x%02x : 0x%04x (%s)\n", mux, value,
-					array[2] =3D=3D 1 ? "valid" : "invalid");
-
-	return 0;
-}
-
-static struct {
-	char *str;
-	int (*func)(int transport, int argc, char *argv[]);
-	char *arg;
-	char *doc;
-} commands[] =3D {
-	{ "builddef",  cmd_builddef,  "",                    "Get build definitio=
ns"          },
-	{ "keylen",    cmd_keylen,    "<handle>",            "Get current crypt k=
ey length"   },
-	{ "clock",     cmd_clock,     "",                    "Get local Bluetooth=
 clock"      },
-	{ "rand",      cmd_rand,      "",                    "Get random number" =
             },
-	{ "chiprev",   cmd_chiprev,   "",                    "Get chip revision" =
             },
-	{ "buildname", cmd_buildname, "",                    "Get the full build =
name"        },
-	{ "panicarg",  cmd_panicarg,  "",                    "Get panic code argu=
ment"        },
-	{ "faultarg",  cmd_faultarg,  "",                    "Get fault code argu=
ment"        },
-	{ "coldreset", cmd_coldreset, "",                    "Perform cold reset"=
             },
-	{ "warmreset", cmd_warmreset, "",                    "Perform warm reset"=
             },
-	{ "disabletx", cmd_disabletx, "",                    "Disable TX on the d=
evice"       },
-	{ "enabletx",  cmd_enabletx,  "",                    "Enable TX on the de=
vice"        },
-	{ "singlechan",cmd_singlechan,"<channel>",           "Lock radio on speci=
fic channel" },
-	{ "hoppingon", cmd_hoppingon, "",                    "Revert to channel h=
opping"      },
-	{ "rttxdata1", cmd_rttxdata1, "<freq> <level>",      "TXData1 radio test"=
             },
-	{ "radiotest", cmd_radiotest, "<freq> <level> <id>", "Run radio tests"   =
             },
-	{ "memtypes",  cmd_memtypes,  NULL,                  "Get memory types"  =
             },
-	{ "psget",     cmd_psget,     "<key>",               "Get value for PS ke=
y"           },
-	{ "psset",     cmd_psset,     "<key> <value>",       "Set value for PS ke=
y"           },
-	{ "psclr",     cmd_psclr,     "<key>",               "Clear value for PS =
key"         },
-	{ "pslist",    cmd_pslist,    NULL,                  "List all PS keys"  =
             },
-	{ "psread",    cmd_psread,    NULL,                  "Read all PS keys"  =
             },
-	{ "psload",    cmd_psload,    "<file>",              "Load all PS keys fr=
om PSR file" },
-	{ "pscheck",   cmd_pscheck,   "<file>",              "Check PSR file"    =
             },
-	{ "adc",       cmd_adc,       "<mux>",               "Read ADC value of <=
mux> input"  },
-	{ NULL }
-};
-
-static void usage(void)
-{
-	int i, pos =3D 0;
-
-	printf("bccmd - Utility for the CSR BCCMD interface\n\n");
-	printf("Usage:\n"
-		"\tbccmd [options] <command>\n\n");
-
-	printf("Options:\n"
-		"\t-t <transport>     Select the transport\n"
-		"\t-d <device>        Select the device\n"
-		"\t-b <bcsp rate>     Select the bcsp transfer rate\n"
-		"\t-h, --help         Display help\n"
-		"\n");
-
-	printf("Transports:\n"
-		"\tHCI USB BCSP H4 3WIRE\n\n");
-
-	printf("Commands:\n");
-	for (i =3D 0; commands[i].str; i++)
-		printf("\t%-10s %-20s\t%s\n", commands[i].str,
-		commands[i].arg ? commands[i].arg : " ",
-		commands[i].doc);
-	printf("\n");
-
-	printf("Keys:\n\t");
-	for (i =3D 0; storage[i].pskey; i++) {
-		printf("%s ", storage[i].str);
-		pos +=3D strlen(storage[i].str) + 1;
-		if (pos > 60) {
-			printf("\n\t");
-			pos =3D 0;
-		}
-	}
-	printf("\n");
-}
-
-static struct option main_options[] =3D {
-	{ "transport",	1, 0, 't' },
-	{ "device",	1, 0, 'd' },
-	{ "bcsprate", 1, 0, 'b'},
-	{ "help",	0, 0, 'h' },
-	{ 0, 0, 0, 0 }
-};
-
-int main(int argc, char *argv[])
-{
-	char *device =3D NULL;
-	int i, err, opt, transport =3D CSR_TRANSPORT_HCI;
-	speed_t bcsp_rate =3D B38400;
-
-	while ((opt=3Dgetopt_long(argc, argv, "+t:d:i:b:h", main_options, NULL)) =
!=3D EOF) {
-		switch (opt) {
-		case 't':
-			if (!strcasecmp(optarg, "hci"))
-				transport =3D CSR_TRANSPORT_HCI;
-			else if (!strcasecmp(optarg, "usb"))
-				transport =3D CSR_TRANSPORT_USB;
-			else if (!strcasecmp(optarg, "bcsp"))
-				transport =3D CSR_TRANSPORT_BCSP;
-			else if (!strcasecmp(optarg, "h4"))
-				transport =3D CSR_TRANSPORT_H4;
-			else if (!strcasecmp(optarg, "h5"))
-				transport =3D CSR_TRANSPORT_3WIRE;
-			else if (!strcasecmp(optarg, "3wire"))
-				transport =3D CSR_TRANSPORT_3WIRE;
-			else if (!strcasecmp(optarg, "twutl"))
-				transport =3D CSR_TRANSPORT_3WIRE;
-			else
-				transport =3D CSR_TRANSPORT_UNKNOWN;
-			break;
-
-		case 'd':
-		case 'i':
-			device =3D strdup(optarg);
-			break;
-		case 'b':
-			bcsp_rate =3D tty_get_speed(atoi(optarg));
-			if (!bcsp_rate) {
-				printf("Unknown BCSP baud rate specified, defaulting to 38400bps\n");
-				bcsp_rate =3D B38400;
-			}
-			break;
-		case 'h':
-		default:
-			usage();
-			exit(0);
-		}
-	}
-
-	argc -=3D optind;
-	argv +=3D optind;
-	optind =3D 0;
-
-	if (argc < 1) {
-		usage();
-		exit(1);
-	}
-
-	if (transport_open(transport, device, bcsp_rate) < 0)
-		exit(1);
-
-	free(device);
-
-	for (i =3D 0; commands[i].str; i++) {
-		if (strcasecmp(commands[i].str, argv[0]))
-			continue;
-
-		err =3D commands[i].func(transport, argc, argv);
-
-		transport_close(transport);
-
-		if (err < 0) {
-			fprintf(stderr, "Can't execute command: %s (%d)\n",
-							strerror(errno), errno);
-			exit(1);
-		}
-
-		exit(0);
-	}
-
-	fprintf(stderr, "Unsupported command\n");
-
-	transport_close(transport);
-
-	exit(1);
-}
diff --git a/tools/csr.c b/tools/csr.c
deleted file mode 100644
index 61bdaa0cf..000000000
--- a/tools/csr.c
+++ /dev/null
@@ -1,2856 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2003-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 =
 USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/mman.h>
-#include <sys/socket.h>
-
-#include "lib/bluetooth.h"
-#include "lib/hci.h"
-#include "lib/hci_lib.h"
-
-#include "csr.h"
-
-struct psr_data {
-	uint16_t pskey;
-	uint8_t *value;
-	uint8_t size;
-	struct psr_data *next;
-};
-
-static struct psr_data *head =3D NULL, *tail =3D NULL;
-
-static struct {
-	uint16_t id;
-	char *str;
-} csr_map[] =3D {
-	{   66, "HCI 9.8"	},
-	{   97, "HCI 10.3"	},
-	{  101, "HCI 10.5"	},
-	{  111,	"HCI 11.0"	},
-	{  112,	"HCI 11.1"	},
-	{  114,	"HCI 11.2"	},
-	{  115,	"HCI 11.3"	},
-	{  117,	"HCI 12.0"	},
-	{  119,	"HCI 12.1"	},
-	{  133,	"HCI 12.2"	},
-	{  134,	"HCI 12.3"	},
-	{  162,	"HCI 12.4"	},
-	{  165,	"HCI 12.5"	},
-	{  169,	"HCI 12.6"	},
-	{  188,	"HCI 12.7"	},
-	{  218,	"HCI 12.8"	},
-	{  283,	"HCI 12.9"	},
-	{  203,	"HCI 13.2"	},
-	{  204,	"HCI 13.2"	},
-	{  210,	"HCI 13.3"	},
-	{  211,	"HCI 13.3"	},
-	{  213,	"HCI 13.4"	},
-	{  214,	"HCI 13.4"	},
-	{  225,	"HCI 13.5"	},
-	{  226,	"HCI 13.5"	},
-	{  237,	"HCI 13.6"	},
-	{  238,	"HCI 13.6"	},
-	{  242,	"HCI 14.0"	},
-	{  243,	"HCI 14.0"	},
-	{  244,	"HCI 14.0"	},
-	{  245,	"HCI 14.0"	},
-	{  254,	"HCI 13.7"	},
-	{  255,	"HCI 13.7"	},
-	{  264,	"HCI 14.1"	},
-	{  265,	"HCI 14.1"	},
-	{  267,	"HCI 14.2"	},
-	{  268,	"HCI 14.2"	},
-	{  272,	"HCI 14.3"	},
-	{  273,	"HCI 14.3"	},
-	{  274,	"HCI 13.8"	},
-	{  275,	"HCI 13.8"	},
-	{  286,	"HCI 13.9"	},
-	{  287,	"HCI 13.9"	},
-	{  309,	"HCI 13.10"	},
-	{  310,	"HCI 13.10"	},
-	{  313,	"HCI 14.4"	},
-	{  314,	"HCI 14.4"	},
-	{  323,	"HCI 14.5"	},
-	{  324,	"HCI 14.5"	},
-	{  336,	"HCI 14.6"	},
-	{  337,	"HCI 14.6"	},
-	{  351,	"HCI 13.11"	},
-	{  352,	"HCI 13.11"	},
-	{  362,	"HCI 15.0"	},
-	{  363,	"HCI 15.0"	},
-	{  364,	"HCI 15.0"	},
-	{  365,	"HCI 15.0"	},
-	{  373,	"HCI 14.7"	},
-	{  374,	"HCI 14.7"	},
-	{  379,	"HCI 15.1"	},
-	{  380,	"HCI 15.1"	},
-	{  381,	"HCI 15.1"	},
-	{  382,	"HCI 15.1"	},
-	{  392,	"HCI 15.2"	},
-	{  393,	"HCI 15.2"	},
-	{  394,	"HCI 15.2"	},
-	{  395,	"HCI 15.2"	},
-	{  436,	"HCI 16.0"	},
-	{  437,	"HCI 16.0"	},
-	{  438,	"HCI 16.0"	},
-	{  439,	"HCI 16.0"	},
-	{  443,	"HCI 15.3"	},
-	{  444,	"HCI 15.3"	},
-	{  465,	"HCI 16.1"	},
-	{  466,	"HCI 16.1"	},
-	{  467,	"HCI 16.1"	},
-	{  468,	"HCI 16.1"	},
-	{  487,	"HCI 14.8"	},
-	{  488,	"HCI 14.8"	},
-	{  492,	"HCI 16.2"	},
-	{  493,	"HCI 16.2"	},
-	{  495,	"HCI 16.2"	},
-	{  496,	"HCI 16.2"	},
-	{  502,	"HCI 16.1.1"	},
-	{  503,	"HCI 16.1.1"	},
-	{  504,	"HCI 16.1.1"	},
-	{  505,	"HCI 16.1.1"	},
-	{  506,	"HCI 16.1.2"	},
-	{  507,	"HCI 16.1.2"	},
-	{  508,	"HCI 16.1.2"	},
-	{  509,	"HCI 16.1.2"	},
-	{  516,	"HCI 16.3"	},
-	{  517,	"HCI 16.3"	},
-	{  518,	"HCI 16.3"	},
-	{  519,	"HCI 16.3"	},
-	{  523,	"HCI 16.4"	},
-	{  524,	"HCI 16.4"	},
-	{  525,	"HCI 16.4"	},
-	{  526,	"HCI 16.4"	},
-	{  553,	"HCI 15.3"	},
-	{  554,	"HCI 15.3"	},
-	{  562,	"HCI 16.5"	},
-	{  563,	"HCI 16.5"	},
-	{  564,	"HCI 16.5"	},
-	{  565,	"HCI 16.5"	},
-	{  593,	"HCI 17.0"	},
-	{  594,	"HCI 17.0"	},
-	{  595,	"HCI 17.0"	},
-	{  599,	"HCI 17.0"	},
-	{  600,	"HCI 17.0"	},
-	{  608,	"HCI 13.10.1"	},
-	{  609,	"HCI 13.10.1"	},
-	{  613,	"HCI 17.1"	},
-	{  614,	"HCI 17.1"	},
-	{  615,	"HCI 17.1"	},
-	{  616,	"HCI 17.1"	},
-	{  618,	"HCI 17.1"	},
-	{  624,	"HCI 17.2"	},
-	{  625,	"HCI 17.2"	},
-	{  626,	"HCI 17.2"	},
-	{  627,	"HCI 17.2"	},
-	{  637,	"HCI 16.6"	},
-	{  638,	"HCI 16.6"	},
-	{  639,	"HCI 16.6"	},
-	{  640,	"HCI 16.6"	},
-	{  642,	"HCI 13.10.2"	},
-	{  643,	"HCI 13.10.2"	},
-	{  644,	"HCI 13.10.3"	},
-	{  645,	"HCI 13.10.3"	},
-	{  668,	"HCI 13.10.4"	},
-	{  669,	"HCI 13.10.4"	},
-	{  681,	"HCI 16.7"	},
-	{  682,	"HCI 16.7"	},
-	{  683,	"HCI 16.7"	},
-	{  684,	"HCI 16.7"	},
-	{  704,	"HCI 16.8"	},
-	{  718,	"HCI 16.4.1"	},
-	{  719,	"HCI 16.4.1"	},
-	{  720,	"HCI 16.4.1"	},
-	{  721,	"HCI 16.4.1"	},
-	{  722,	"HCI 16.7.1"	},
-	{  723,	"HCI 16.7.1"	},
-	{  724,	"HCI 16.7.1"	},
-	{  725,	"HCI 16.7.1"	},
-	{  731,	"HCI 16.7.2"	},
-	{  732,	"HCI 16.7.2"	},
-	{  733,	"HCI 16.7.2"	},
-	{  734,	"HCI 16.7.2"	},
-	{  735,	"HCI 16.4.2"	},
-	{  736,	"HCI 16.4.2"	},
-	{  737,	"HCI 16.4.2"	},
-	{  738,	"HCI 16.4.2"	},
-	{  750,	"HCI 16.7.3"	},
-	{  751,	"HCI 16.7.3"	},
-	{  752,	"HCI 16.7.3"	},
-	{  753,	"HCI 16.7.3"	},
-	{  760,	"HCI 16.7.4"	},
-	{  761,	"HCI 16.7.4"	},
-	{  762,	"HCI 16.7.4"	},
-	{  763,	"HCI 16.7.4"	},
-	{  770,	"HCI 16.9"	},
-	{  771,	"HCI 16.9"	},
-	{  772,	"HCI 16.9"	},
-	{  773,	"HCI 16.9"	},
-	{  774,	"HCI 17.3"	},
-	{  775,	"HCI 17.3"	},
-	{  776,	"HCI 17.3"	},
-	{  777,	"HCI 17.3"	},
-	{  781,	"HCI 16.7.5"	},
-	{  786,	"HCI 16.10"	},
-	{  787,	"HCI 16.10"	},
-	{  788,	"HCI 16.10"	},
-	{  789,	"HCI 16.10"	},
-	{  791,	"HCI 16.4.3"	},
-	{  792,	"HCI 16.4.3"	},
-	{  793,	"HCI 16.4.3"	},
-	{  794,	"HCI 16.4.3"	},
-	{  798,	"HCI 16.11"	},
-	{  799,	"HCI 16.11"	},
-	{  800,	"HCI 16.11"	},
-	{  801,	"HCI 16.11"	},
-	{  806,	"HCI 16.7.5"	},
-	{  807,	"HCI 16.12"	},
-	{  808,	"HCI 16.12"	},
-	{  809,	"HCI 16.12"	},
-	{  810,	"HCI 16.12"	},
-	{  817,	"HCI 16.13"	},
-	{  818,	"HCI 16.13"	},
-	{  819,	"HCI 16.13"	},
-	{  820,	"HCI 16.13"	},
-	{  823,	"HCI 13.10.5"	},
-	{  824,	"HCI 13.10.5"	},
-	{  826,	"HCI 16.14"	},
-	{  827,	"HCI 16.14"	},
-	{  828,	"HCI 16.14"	},
-	{  829,	"HCI 16.14"	},
-	{  843,	"HCI 17.3.1"	},
-	{  856,	"HCI 17.3.2"	},
-	{  857,	"HCI 17.3.2"	},
-	{  858,	"HCI 17.3.2"	},
-	{ 1120, "HCI 17.11"	},
-	{ 1168, "HCI 18.1"	},
-	{ 1169, "HCI 18.1"	},
-	{ 1241, "HCI 18.x"	},
-	{ 1298, "HCI 18.2"	},
-	{ 1354, "HCI 18.2"	},
-	{ 1392, "HCI 18.2"	},
-	{ 1393, "HCI 18.2"	},
-	{ 1501, "HCI 18.2"	},
-	{ 1503, "HCI 18.2"	},
-	{ 1504, "HCI 18.2"	},
-	{ 1505, "HCI 18.2"	},
-	{ 1506, "HCI 18.2"	},
-	{ 1520, "HCI 18.2"	},
-	{ 1586, "HCI 18.2"	},
-	{ 1591, "HCI 18.2"	},
-	{ 1592, "HCI 18.2"	},
-	{ 1593, "HCI 18.2.1"	},
-	{ 1733, "HCI 18.3"	},
-	{ 1734, "HCI 18.3"	},
-	{ 1735, "HCI 18.3"	},
-	{ 1737, "HCI 18.3"	},
-	{ 1915, "HCI 19.2"	},
-	{ 1916, "HCI 19.2"	},
-	{ 1958, "HCI 19.2"	},
-	{ 1981, "Unified 20a"	},
-	{ 1982, "Unified 20a"	},
-	{ 1989, "HCI 18.4"	},
-	{ 2062, "Unified 20a1"	},
-	{ 2063, "Unified 20a1"	},
-	{ 2067, "Unified 18f"	},
-	{ 2068, "Unified 18f"	},
-	{ 2243, "Unified 18e"	},
-	{ 2244, "Unified 18e"	},
-	{ 2258, "Unified 20d"	},
-	{ 2259, "Unified 20d"	},
-	{ 2361, "Unified 20e"	},
-	{ 2362, "Unified 20e"	},
-	{ 2386, "Unified 21a"	},
-	{ 2387, "Unified 21a"	},
-	{ 2423, "Unified 21a"	},
-	{ 2424, "Unified 21a"	},
-	{ 2623, "Unified 21c"	},
-	{ 2624, "Unified 21c"	},
-	{ 2625, "Unified 21c"	},
-	{ 2626, "Unified 21c"	},
-	{ 2627, "Unified 21c"	},
-	{ 2628, "Unified 21c"	},
-	{ 2629, "Unified 21c"	},
-	{ 2630, "Unified 21c"	},
-	{ 2631, "Unified 21c"	},
-	{ 2632, "Unified 21c"	},
-	{ 2633, "Unified 21c"	},
-	{ 2634, "Unified 21c"	},
-	{ 2635, "Unified 21c"	},
-	{ 2636, "Unified 21c"	},
-	{ 2649, "Unified 21c"	},
-	{ 2650, "Unified 21c"	},
-	{ 2651, "Unified 21c"	},
-	{ 2652, "Unified 21c"	},
-	{ 2653, "Unified 21c"	},
-	{ 2654, "Unified 21c"	},
-	{ 2655, "Unified 21c"	},
-	{ 2656, "Unified 21c"	},
-	{ 2658, "Unified 21c"	},
-	{ 3057, "Unified 21d"	},
-	{ 3058, "Unified 21d"	},
-	{ 3059, "Unified 21d"	},
-	{ 3060, "Unified 21d"	},
-	{ 3062, "Unified 21d"	},
-	{ 3063, "Unified 21d"	},
-	{ 3064, "Unified 21d"	},
-	{ 3164, "Unified 21e"	},
-	{ 3413, "Unified 21f"	},
-	{ 3414, "Unified 21f"	},
-	{ 3415, "Unified 21f"	},
-	{ 3424, "Unified 21f"	},
-	{ 3454, "Unified 21f"	},
-	{ 3684, "Unified 21f"	},
-	{ 3764, "Unified 21f"	},
-	{ 4276, "Unified 22b"	},
-	{ 4277, "Unified 22b"	},
-	{ 4279, "Unified 22b"	},
-	{ 4281, "Unified 22b"	},
-	{ 4282, "Unified 22b"	},
-	{ 4283, "Unified 22b"	},
-	{ 4284, "Unified 22b"	},
-	{ 4285, "Unified 22b"	},
-	{ 4289, "Unified 22b"	},
-	{ 4290, "Unified 22b"	},
-	{ 4291, "Unified 22b"	},
-	{ 4292, "Unified 22b"	},
-	{ 4293, "Unified 22b"	},
-	{ 4294, "Unified 22b"	},
-	{ 4295, "Unified 22b"	},
-	{ 4363, "Unified 22c"	},
-	{ 4373, "Unified 22c"	},
-	{ 4374, "Unified 22c"	},
-	{ 4532, "Unified 22d"	},
-	{ 4533, "Unified 22d"	},
-	{ 4698, "Unified 23c"	},
-	{ 4839, "Unified 23c"	},
-	{ 4841, "Unified 23c"	},
-	{ 4866, "Unified 23c"	},
-	{ 4867, "Unified 23c"	},
-	{ 4868, "Unified 23c"	},
-	{ 4869, "Unified 23c"	},
-	{ 4870, "Unified 23c"	},
-	{ 4871, "Unified 23c"	},
-	{ 4872, "Unified 23c"	},
-	{ 4874, "Unified 23c"	},
-	{ 4875, "Unified 23c"	},
-	{ 4876, "Unified 23c"	},
-	{ 4877, "Unified 23c"	},
-	{ 2526, "Marcel 1 (2005-09-26)"	},
-	{ 2543, "Marcel 2 (2005-09-28)"	},
-	{ 2622, "Marcel 3 (2005-10-27)"	},
-	{ 3326, "Marcel 4 (2006-06-16)"	},
-	{ 3612, "Marcel 5 (2006-10-24)"	},
-	{ 4509, "Marcel 6 (2007-06-11)"	},
-	{ 5417, "Marcel 7 (2008-08-26)" },
-	{  195, "Sniff 1 (2001-11-27)"	},
-	{  220, "Sniff 2 (2002-01-03)"	},
-	{  269, "Sniff 3 (2002-02-22)"	},
-	{  270, "Sniff 4 (2002-02-26)"	},
-	{  284, "Sniff 5 (2002-03-12)"	},
-	{  292, "Sniff 6 (2002-03-20)"	},
-	{  305, "Sniff 7 (2002-04-12)"	},
-	{  306, "Sniff 8 (2002-04-12)"	},
-	{  343, "Sniff 9 (2002-05-02)"	},
-	{  346, "Sniff 10 (2002-05-03)"	},
-	{  355, "Sniff 11 (2002-05-16)"	},
-	{  256, "Sniff 11 (2002-05-16)"	},
-	{  390, "Sniff 12 (2002-06-26)"	},
-	{  450, "Sniff 13 (2002-08-16)"	},
-	{  451, "Sniff 13 (2002-08-16)"	},
-	{  533, "Sniff 14 (2002-10-11)"	},
-	{  580, "Sniff 15 (2002-11-14)"	},
-	{  623, "Sniff 16 (2002-12-12)"	},
-	{  678, "Sniff 17 (2003-01-29)"	},
-	{  847, "Sniff 18 (2003-04-17)"	},
-	{  876, "Sniff 19 (2003-06-10)"	},
-	{  997, "Sniff 22 (2003-09-05)"	},
-	{ 1027, "Sniff 23 (2003-10-03)"	},
-	{ 1029, "Sniff 24 (2003-10-03)"	},
-	{ 1112, "Sniff 25 (2003-12-03)"	},
-	{ 1113, "Sniff 25 (2003-12-03)"	},
-	{ 1133, "Sniff 26 (2003-12-18)"	},
-	{ 1134, "Sniff 26 (2003-12-18)"	},
-	{ 1223, "Sniff 27 (2004-03-08)"	},
-	{ 1224, "Sniff 27 (2004-03-08)"	},
-	{ 1319, "Sniff 31 (2004-04-22)"	},
-	{ 1320, "Sniff 31 (2004-04-22)"	},
-	{ 1427, "Sniff 34 (2004-06-16)"	},
-	{ 1508, "Sniff 35 (2004-07-19)"	},
-	{ 1509, "Sniff 35 (2004-07-19)"	},
-	{ 1587, "Sniff 36 (2004-08-18)"	},
-	{ 1588, "Sniff 36 (2004-08-18)"	},
-	{ 1641, "Sniff 37 (2004-09-16)"	},
-	{ 1642, "Sniff 37 (2004-09-16)"	},
-	{ 1699, "Sniff 38 (2004-10-07)"	},
-	{ 1700, "Sniff 38 (2004-10-07)"	},
-	{ 1752, "Sniff 39 (2004-11-02)"	},
-	{ 1753, "Sniff 39 (2004-11-02)"	},
-	{ 1759, "Sniff 40 (2004-11-03)"	},
-	{ 1760, "Sniff 40 (2004-11-03)"	},
-	{ 1761, "Sniff 40 (2004-11-03)"	},
-	{ 2009, "Sniff 41 (2005-04-06)"	},
-	{ 2010, "Sniff 41 (2005-04-06)"	},
-	{ 2011, "Sniff 41 (2005-04-06)"	},
-	{ 2016, "Sniff 42 (2005-04-11)"	},
-	{ 2017, "Sniff 42 (2005-04-11)"	},
-	{ 2018, "Sniff 42 (2005-04-11)"	},
-	{ 2023, "Sniff 43 (2005-04-14)"	},
-	{ 2024, "Sniff 43 (2005-04-14)"	},
-	{ 2025, "Sniff 43 (2005-04-14)"	},
-	{ 2032, "Sniff 44 (2005-04-18)"	},
-	{ 2033, "Sniff 44 (2005-04-18)"	},
-	{ 2034, "Sniff 44 (2005-04-18)"	},
-	{ 2288, "Sniff 45 (2005-07-08)"	},
-	{ 2289, "Sniff 45 (2005-07-08)"	},
-	{ 2290, "Sniff 45 (2005-07-08)"	},
-	{ 2388, "Sniff 46 (2005-08-17)"	},
-	{ 2389, "Sniff 46 (2005-08-17)"	},
-	{ 2390, "Sniff 46 (2005-08-17)"	},
-	{ 2869, "Sniff 47 (2006-02-15)"	},
-	{ 2870, "Sniff 47 (2006-02-15)"	},
-	{ 2871, "Sniff 47 (2006-02-15)"	},
-	{ 3214, "Sniff 48 (2006-05-16)"	},
-	{ 3215, "Sniff 48 (2006-05-16)"	},
-	{ 3216, "Sniff 48 (2006-05-16)"	},
-	{ 3356, "Sniff 49 (2006-07-17)"	},
-	{ 3529, "Sniff 50 (2006-09-21)"	},
-	{ 3546, "Sniff 51 (2006-09-29)"	},
-	{ 3683, "Sniff 52 (2006-11-03)"	},
-	{    0, }
-};
-
-char *csr_builddeftostr(uint16_t def)
-{
-	switch (def) {
-	case 0x0000:
-		return "NONE";
-	case 0x0001:
-		return "CHIP_BASE_BC01";
-	case 0x0002:
-		return "CHIP_BASE_BC02";
-	case 0x0003:
-		return "CHIP_BC01B";
-	case 0x0004:
-		return "CHIP_BC02_EXTERNAL";
-	case 0x0005:
-		return "BUILD_HCI";
-	case 0x0006:
-		return "BUILD_RFCOMM";
-	case 0x0007:
-		return "BT_VER_1_1";
-	case 0x0008:
-		return "TRANSPORT_ALL";
-	case 0x0009:
-		return "TRANSPORT_BCSP";
-	case 0x000a:
-		return "TRANSPORT_H4";
-	case 0x000b:
-		return "TRANSPORT_USB";
-	case 0x000c:
-		return "MAX_CRYPT_KEY_LEN_56";
-	case 0x000d:
-		return "MAX_CRYPT_KEY_LEN_128";
-	case 0x000e:
-		return "TRANSPORT_USER";
-	case 0x000f:
-		return "CHIP_BC02_KATO";
-	case 0x0010:
-		return "TRANSPORT_NONE";
-	case 0x0012:
-		return "REQUIRE_8MBIT";
-	case 0x0013:
-		return "RADIOTEST";
-	case 0x0014:
-		return "RADIOTEST_LITE";
-	case 0x0015:
-		return "INSTALL_FLASH";
-	case 0x0016:
-		return "INSTALL_EEPROM";
-	case 0x0017:
-		return "INSTALL_COMBO_DOT11";
-	case 0x0018:
-		return "LOWPOWER_TX";
-	case 0x0019:
-		return "TRANSPORT_TWUTL";
-	case 0x001a:
-		return "COMPILER_GCC";
-	case 0x001b:
-		return "CHIP_BC02_CLOUSEAU";
-	case 0x001c:
-		return "CHIP_BC02_TOULOUSE";
-	case 0x001d:
-		return "CHIP_BASE_BC3";
-	case 0x001e:
-		return "CHIP_BC3_NICKNACK";
-	case 0x001f:
-		return "CHIP_BC3_KALIMBA";
-	case 0x0020:
-		return "INSTALL_HCI_MODULE";
-	case 0x0021:
-		return "INSTALL_L2CAP_MODULE";
-	case 0x0022:
-		return "INSTALL_DM_MODULE";
-	case 0x0023:
-		return "INSTALL_SDP_MODULE";
-	case 0x0024:
-		return "INSTALL_RFCOMM_MODULE";
-	case 0x0025:
-		return "INSTALL_HIDIO_MODULE";
-	case 0x0026:
-		return "INSTALL_PAN_MODULE";
-	case 0x0027:
-		return "INSTALL_IPV4_MODULE";
-	case 0x0028:
-		return "INSTALL_IPV6_MODULE";
-	case 0x0029:
-		return "INSTALL_TCP_MODULE";
-	case 0x002a:
-		return "BT_VER_1_2";
-	case 0x002b:
-		return "INSTALL_UDP_MODULE";
-	case 0x002c:
-		return "REQUIRE_0_WAIT_STATES";
-	case 0x002d:
-		return "CHIP_BC3_PADDYWACK";
-	case 0x002e:
-		return "CHIP_BC4_COYOTE";
-	case 0x002f:
-		return "CHIP_BC4_ODDJOB";
-	case 0x0030:
-		return "TRANSPORT_H4DS";
-	case 0x0031:
-		return "CHIP_BASE_BC4";
-	default:
-		return "UNKNOWN";
-	}
-}
-
-char *csr_buildidtostr(uint16_t id)
-{
-	static char str[12];
-	int i;
-
-	for (i =3D 0; csr_map[i].id; i++)
-		if (csr_map[i].id =3D=3D id)
-			return csr_map[i].str;
-
-	snprintf(str, sizeof(str), "Build %d", id);
-	return str;
-}
-
-char *csr_chipvertostr(uint16_t ver, uint16_t rev)
-{
-	switch (ver) {
-	case 0x00:
-		return "BlueCore01a";
-	case 0x01:
-		switch (rev) {
-		case 0x64:
-			return "BlueCore01b (ES)";
-		case 0x65:
-		default:
-			return "BlueCore01b";
-		}
-	case 0x02:
-		switch (rev) {
-		case 0x89:
-			return "BlueCore02-External (ES2)";
-		case 0x8a:
-			return "BlueCore02-External";
-		case 0x28:
-			return "BlueCore02-ROM/Audio/Flash";
-		default:
-			return "BlueCore02";
-		}
-	case 0x03:
-		switch (rev) {
-		case 0x43:
-			return "BlueCore3-MM";
-		case 0x15:
-			return "BlueCore3-ROM";
-		case 0xe2:
-			return "BlueCore3-Flash";
-		case 0x26:
-			return "BlueCore4-External";
-		case 0x30:
-			return "BlueCore4-ROM";
-		default:
-			return "BlueCore3 or BlueCore4";
-		}
-	default:
-		return "Unknown";
-	}
-}
-
-char *csr_pskeytostr(uint16_t pskey)
-{
-	switch (pskey) {
-	case CSR_PSKEY_BDADDR:
-		return "Bluetooth address";
-	case CSR_PSKEY_COUNTRYCODE:
-		return "Country code";
-	case CSR_PSKEY_CLASSOFDEVICE:
-		return "Class of device";
-	case CSR_PSKEY_DEVICE_DRIFT:
-		return "Device drift";
-	case CSR_PSKEY_DEVICE_JITTER:
-		return "Device jitter";
-	case CSR_PSKEY_MAX_ACLS:
-		return "Maximum ACL links";
-	case CSR_PSKEY_MAX_SCOS:
-		return "Maximum SCO links";
-	case CSR_PSKEY_MAX_REMOTE_MASTERS:
-		return "Maximum remote masters";
-	case CSR_PSKEY_ENABLE_MASTERY_WITH_SLAVERY:
-		return "Support master and slave roles simultaneously";
-	case CSR_PSKEY_H_HC_FC_MAX_ACL_PKT_LEN:
-		return "Maximum HCI ACL packet length";
-	case CSR_PSKEY_H_HC_FC_MAX_SCO_PKT_LEN:
-		return "Maximum HCI SCO packet length";
-	case CSR_PSKEY_H_HC_FC_MAX_ACL_PKTS:
-		return "Maximum number of HCI ACL packets";
-	case CSR_PSKEY_H_HC_FC_MAX_SCO_PKTS:
-		return "Maximum number of HCI SCO packets";
-	case CSR_PSKEY_LC_FC_BUFFER_LOW_WATER_MARK:
-		return "Flow control low water mark";
-	case CSR_PSKEY_LC_MAX_TX_POWER:
-		return "Maximum transmit power";
-	case CSR_PSKEY_TX_GAIN_RAMP:
-		return "Transmit gain ramp rate";
-	case CSR_PSKEY_LC_POWER_TABLE:
-		return "Radio power table";
-	case CSR_PSKEY_LC_PEER_POWER_PERIOD:
-		return "Peer transmit power control interval";
-	case CSR_PSKEY_LC_FC_POOLS_LOW_WATER_MARK:
-		return "Flow control pool low water mark";
-	case CSR_PSKEY_LC_DEFAULT_TX_POWER:
-		return "Default transmit power";
-	case CSR_PSKEY_LC_RSSI_GOLDEN_RANGE:
-		return "RSSI at bottom of golden receive range";
-	case CSR_PSKEY_LC_COMBO_DISABLE_PIO_MASK:
-		return "Combo: PIO lines and logic to disable transmit";
-	case CSR_PSKEY_LC_COMBO_PRIORITY_PIO_MASK:
-		return "Combo: priority activity PIO lines and logic";
-	case CSR_PSKEY_LC_COMBO_DOT11_CHANNEL_PIO_BASE:
-		return "Combo: 802.11b channel number base PIO line";
-	case CSR_PSKEY_LC_COMBO_DOT11_BLOCK_CHANNELS:
-		return "Combo: channels to block either side of 802.11b";
-	case CSR_PSKEY_LC_MAX_TX_POWER_NO_RSSI:
-		return "Maximum transmit power when peer has no RSSI";
-	case CSR_PSKEY_LC_CONNECTION_RX_WINDOW:
-		return "Receive window size during connections";
-	case CSR_PSKEY_LC_COMBO_DOT11_TX_PROTECTION_MODE:
-		return "Combo: which TX packets shall we protect";
-	case CSR_PSKEY_LC_ENHANCED_POWER_TABLE:
-		return "Radio power table";
-	case CSR_PSKEY_LC_WIDEBAND_RSSI_CONFIG:
-		return "RSSI configuration for use with wideband RSSI";
-	case CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_LEAD:
-		return "Combo: How much notice will we give the Combo Card";
-	case CSR_PSKEY_BT_CLOCK_INIT:
-		return "Initial value of Bluetooth clock";
-	case CSR_PSKEY_TX_MR_MOD_DELAY:
-		return "TX Mod delay";
-	case CSR_PSKEY_RX_MR_SYNC_TIMING:
-		return "RX MR Sync Timing";
-	case CSR_PSKEY_RX_MR_SYNC_CONFIG:
-		return "RX MR Sync Configuration";
-	case CSR_PSKEY_LC_LOST_SYNC_SLOTS:
-		return "Time in ms for lost sync in low power modes";
-	case CSR_PSKEY_RX_MR_SAMP_CONFIG:
-		return "RX MR Sync Configuration";
-	case CSR_PSKEY_AGC_HYST_LEVELS:
-		return "AGC hysteresis levels";
-	case CSR_PSKEY_RX_LEVEL_LOW_SIGNAL:
-		return "ANA_RX_LVL at low signal strengths";
-	case CSR_PSKEY_AGC_IQ_LVL_VALUES:
-		return "ANA_IQ_LVL values for AGC algorithmn";
-	case CSR_PSKEY_MR_FTRIM_OFFSET_12DB:
-		return "ANA_RX_FTRIM offset when using 12 dB IF atten ";
-	case CSR_PSKEY_MR_FTRIM_OFFSET_6DB:
-		return "ANA_RX_FTRIM offset when using 6 dB IF atten ";
-	case CSR_PSKEY_NO_CAL_ON_BOOT:
-		return "Do not calibrate radio on boot";
-	case CSR_PSKEY_RSSI_HI_TARGET:
-		return "RSSI high target";
-	case CSR_PSKEY_PREFERRED_MIN_ATTENUATION:
-		return "Preferred minimum attenuator setting";
-	case CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_OVERRIDE:
-		return "Combo: Treat all packets as high priority";
-	case CSR_PSKEY_LC_MULTISLOT_HOLDOFF:
-		return "Time till single slot packets are used for resync";
-	case CSR_PSKEY_FREE_KEY_PIGEON_HOLE:
-		return "Link key store bitfield";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR0:
-		return "Bluetooth address + link key 0";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR1:
-		return "Bluetooth address + link key 1";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR2:
-		return "Bluetooth address + link key 2";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR3:
-		return "Bluetooth address + link key 3";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR4:
-		return "Bluetooth address + link key 4";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR5:
-		return "Bluetooth address + link key 5";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR6:
-		return "Bluetooth address + link key 6";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR7:
-		return "Bluetooth address + link key 7";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR8:
-		return "Bluetooth address + link key 8";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR9:
-		return "Bluetooth address + link key 9";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR10:
-		return "Bluetooth address + link key 10";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR11:
-		return "Bluetooth address + link key 11";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR12:
-		return "Bluetooth address + link key 12";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR13:
-		return "Bluetooth address + link key 13";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR14:
-		return "Bluetooth address + link key 14";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR15:
-		return "Bluetooth address + link key 15";
-	case CSR_PSKEY_ENC_KEY_LMIN:
-		return "Minimum encryption key length";
-	case CSR_PSKEY_ENC_KEY_LMAX:
-		return "Maximum encryption key length";
-	case CSR_PSKEY_LOCAL_SUPPORTED_FEATURES:
-		return "Local supported features block";
-	case CSR_PSKEY_LM_USE_UNIT_KEY:
-		return "Allow use of unit key for authentication?";
-	case CSR_PSKEY_HCI_NOP_DISABLE:
-		return "Disable the HCI Command_Status event on boot";
-	case CSR_PSKEY_LM_MAX_EVENT_FILTERS:
-		return "Maximum number of event filters";
-	case CSR_PSKEY_LM_USE_ENC_MODE_BROADCAST:
-		return "Allow LM to use enc_mode=3D2";
-	case CSR_PSKEY_LM_TEST_SEND_ACCEPTED_TWICE:
-		return "LM sends two LMP_accepted messages in test mode";
-	case CSR_PSKEY_LM_MAX_PAGE_HOLD_TIME:
-		return "Maximum time we hold a device around page";
-	case CSR_PSKEY_AFH_ADAPTATION_RESPONSE_TIME:
-		return "LM period for AFH adaption";
-	case CSR_PSKEY_AFH_OPTIONS:
-		return "Options to configure AFH";
-	case CSR_PSKEY_AFH_RSSI_RUN_PERIOD:
-		return "AFH RSSI reading period";
-	case CSR_PSKEY_AFH_REENABLE_CHANNEL_TIME:
-		return "AFH good channel adding time";
-	case CSR_PSKEY_NO_DROP_ON_ACR_MS_FAIL:
-		return "Complete link if acr barge-in role switch refused";
-	case CSR_PSKEY_MAX_PRIVATE_KEYS:
-		return "Max private link keys stored";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR0:
-		return "Bluetooth address + link key 0";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR1:
-		return "Bluetooth address + link key 1";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR2:
-		return "Bluetooth address + link key 2";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR3:
-		return "Bluetooth address + link key 3";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR4:
-		return "Bluetooth address + link key 4";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR5:
-		return "Bluetooth address + link key 5";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR6:
-		return "Bluetooth address + link key 6";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR7:
-		return "Bluetooth address + link key 7";
-	case CSR_PSKEY_LOCAL_SUPPORTED_COMMANDS:
-		return "Local supported commands";
-	case CSR_PSKEY_LM_MAX_ABSENCE_INDEX:
-		return "Maximum absence index allowed";
-	case CSR_PSKEY_DEVICE_NAME:
-		return "Local device's \"user friendly\" name";
-	case CSR_PSKEY_AFH_RSSI_THRESHOLD:
-		return "AFH RSSI threshold";
-	case CSR_PSKEY_LM_CASUAL_SCAN_INTERVAL:
-		return "Scan interval in slots for casual scanning";
-	case CSR_PSKEY_AFH_MIN_MAP_CHANGE:
-		return "The minimum amount to change an AFH map by";
-	case CSR_PSKEY_AFH_RSSI_LP_RUN_PERIOD:
-		return "AFH RSSI reading period when in low power mode";
-	case CSR_PSKEY_HCI_LMP_LOCAL_VERSION:
-		return "The HCI and LMP version reported locally";
-	case CSR_PSKEY_LMP_REMOTE_VERSION:
-		return "The LMP version reported remotely";
-	case CSR_PSKEY_HOLD_ERROR_MESSAGE_NUMBER:
-		return "Maximum number of queued HCI Hardware Error Events";
-	case CSR_PSKEY_DFU_ATTRIBUTES:
-		return "DFU attributes";
-	case CSR_PSKEY_DFU_DETACH_TO:
-		return "DFU detach timeout";
-	case CSR_PSKEY_DFU_TRANSFER_SIZE:
-		return "DFU transfer size";
-	case CSR_PSKEY_DFU_ENABLE:
-		return "DFU enable";
-	case CSR_PSKEY_DFU_LIN_REG_ENABLE:
-		return "Linear Regulator enabled at boot in DFU mode";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_MSB:
-		return "DFU encryption VM application public key MSB";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_LSB:
-		return "DFU encryption VM application public key LSB";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_M_DASH:
-		return "DFU encryption VM application M dash";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_R2N_MSB:
-		return "DFU encryption VM application public key R2N MSB";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_R2N_LSB:
-		return "DFU encryption VM application public key R2N LSB";
-	case CSR_PSKEY_BCSP_LM_PS_BLOCK:
-		return "BCSP link establishment block";
-	case CSR_PSKEY_HOSTIO_FC_PS_BLOCK:
-		return "HCI flow control block";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO0:
-		return "Host transport channel 0 settings (BCSP ACK)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO1:
-		return "Host transport channel 1 settings (BCSP-LE)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO2:
-		return "Host transport channel 2 settings (BCCMD)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO3:
-		return "Host transport channel 3 settings (HQ)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO4:
-		return "Host transport channel 4 settings (DM)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO5:
-		return "Host transport channel 5 settings (HCI CMD/EVT)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO6:
-		return "Host transport channel 6 settings (HCI ACL)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO7:
-		return "Host transport channel 7 settings (HCI SCO)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO8:
-		return "Host transport channel 8 settings (L2CAP)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO9:
-		return "Host transport channel 9 settings (RFCOMM)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO10:
-		return "Host transport channel 10 settings (SDP)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO11:
-		return "Host transport channel 11 settings (TEST)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO12:
-		return "Host transport channel 12 settings (DFU)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO13:
-		return "Host transport channel 13 settings (VM)";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO14:
-		return "Host transport channel 14 settings";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO15:
-		return "Host transport channel 15 settings";
-	case CSR_PSKEY_HOSTIO_UART_RESET_TIMEOUT:
-		return "UART reset counter timeout";
-	case CSR_PSKEY_HOSTIO_USE_HCI_EXTN:
-		return "Use hci_extn to route non-hci channels";
-	case CSR_PSKEY_HOSTIO_USE_HCI_EXTN_CCFC:
-		return "Use command-complete flow control for hci_extn";
-	case CSR_PSKEY_HOSTIO_HCI_EXTN_PAYLOAD_SIZE:
-		return "Maximum hci_extn payload size";
-	case CSR_PSKEY_BCSP_LM_CNF_CNT_LIMIT:
-		return "BCSP link establishment conf message count";
-	case CSR_PSKEY_HOSTIO_MAP_SCO_PCM:
-		return "Map SCO over PCM";
-	case CSR_PSKEY_HOSTIO_AWKWARD_PCM_SYNC:
-		return "PCM interface synchronisation is difficult";
-	case CSR_PSKEY_HOSTIO_BREAK_POLL_PERIOD:
-		return "Break poll period (microseconds)";
-	case CSR_PSKEY_HOSTIO_MIN_UART_HCI_SCO_SIZE:
-		return "Minimum SCO packet size sent to host over UART HCI";
-	case CSR_PSKEY_HOSTIO_MAP_SCO_CODEC:
-		return "Map SCO over the built-in codec";
-	case CSR_PSKEY_PCM_CVSD_TX_HI_FREQ_BOOST:
-		return "High frequency boost for PCM when transmitting CVSD";
-	case CSR_PSKEY_PCM_CVSD_RX_HI_FREQ_BOOST:
-		return "High frequency boost for PCM when receiving CVSD";
-	case CSR_PSKEY_PCM_CONFIG32:
-		return "PCM interface settings bitfields";
-	case CSR_PSKEY_USE_OLD_BCSP_LE:
-		return "Use the old version of BCSP link establishment";
-	case CSR_PSKEY_PCM_CVSD_USE_NEW_FILTER:
-		return "CVSD uses the new filter if available";
-	case CSR_PSKEY_PCM_FORMAT:
-		return "PCM data format";
-	case CSR_PSKEY_CODEC_OUT_GAIN:
-		return "Audio output gain when using built-in codec";
-	case CSR_PSKEY_CODEC_IN_GAIN:
-		return "Audio input gain when using built-in codec";
-	case CSR_PSKEY_CODEC_PIO:
-		return "PIO to enable when built-in codec is enabled";
-	case CSR_PSKEY_PCM_LOW_JITTER_CONFIG:
-		return "PCM interface settings for low jitter master mode";
-	case CSR_PSKEY_HOSTIO_SCO_PCM_THRESHOLDS:
-		return "Thresholds for SCO PCM buffers";
-	case CSR_PSKEY_HOSTIO_SCO_HCI_THRESHOLDS:
-		return "Thresholds for SCO HCI buffers";
-	case CSR_PSKEY_HOSTIO_MAP_SCO_PCM_SLOT:
-		return "Route SCO data to specified slot in pcm frame";
-	case CSR_PSKEY_UART_BAUDRATE:
-		return "UART Baud rate";
-	case CSR_PSKEY_UART_CONFIG_BCSP:
-		return "UART configuration when using BCSP";
-	case CSR_PSKEY_UART_CONFIG_H4:
-		return "UART configuration when using H4";
-	case CSR_PSKEY_UART_CONFIG_H5:
-		return "UART configuration when using H5";
-	case CSR_PSKEY_UART_CONFIG_USR:
-		return "UART configuration when under VM control";
-	case CSR_PSKEY_UART_TX_CRCS:
-		return "Use CRCs for BCSP or H5";
-	case CSR_PSKEY_UART_ACK_TIMEOUT:
-		return "Acknowledgement timeout for BCSP and H5";
-	case CSR_PSKEY_UART_TX_MAX_ATTEMPTS:
-		return "Max times to send reliable BCSP or H5 message";
-	case CSR_PSKEY_UART_TX_WINDOW_SIZE:
-		return "Transmit window size for BCSP and H5";
-	case CSR_PSKEY_UART_HOST_WAKE:
-		return "UART host wakeup";
-	case CSR_PSKEY_HOSTIO_THROTTLE_TIMEOUT:
-		return "Host interface performance control.";
-	case CSR_PSKEY_PCM_ALWAYS_ENABLE:
-		return "PCM port is always enable when chip is running";
-	case CSR_PSKEY_UART_HOST_WAKE_SIGNAL:
-		return "Signal to use for uart host wakeup protocol";
-	case CSR_PSKEY_UART_CONFIG_H4DS:
-		return "UART configuration when using H4DS";
-	case CSR_PSKEY_H4DS_WAKE_DURATION:
-		return "How long to spend waking the host when using H4DS";
-	case CSR_PSKEY_H4DS_MAXWU:
-		return "Maximum number of H4DS Wake-Up messages to send";
-	case CSR_PSKEY_H4DS_LE_TIMER_PERIOD:
-		return "H4DS Link Establishment Tsync and Tconf period";
-	case CSR_PSKEY_H4DS_TWU_TIMER_PERIOD:
-		return "H4DS Twu timer period";
-	case CSR_PSKEY_H4DS_UART_IDLE_TIMER_PERIOD:
-		return "H4DS Tuart_idle timer period";
-	case CSR_PSKEY_ANA_FTRIM:
-		return "Crystal frequency trim";
-	case CSR_PSKEY_WD_TIMEOUT:
-		return "Watchdog timeout (microseconds)";
-	case CSR_PSKEY_WD_PERIOD:
-		return "Watchdog period (microseconds)";
-	case CSR_PSKEY_HOST_INTERFACE:
-		return "Host interface";
-	case CSR_PSKEY_HQ_HOST_TIMEOUT:
-		return "HQ host command timeout";
-	case CSR_PSKEY_HQ_ACTIVE:
-		return "Enable host query task?";
-	case CSR_PSKEY_BCCMD_SECURITY_ACTIVE:
-		return "Enable configuration security";
-	case CSR_PSKEY_ANA_FREQ:
-		return "Crystal frequency";
-	case CSR_PSKEY_PIO_PROTECT_MASK:
-		return "Access to PIO pins";
-	case CSR_PSKEY_PMALLOC_SIZES:
-		return "pmalloc sizes array";
-	case CSR_PSKEY_UART_BAUD_RATE:
-		return "UART Baud rate (pre 18)";
-	case CSR_PSKEY_UART_CONFIG:
-		return "UART configuration bitfield";
-	case CSR_PSKEY_STUB:
-		return "Stub";
-	case CSR_PSKEY_TXRX_PIO_CONTROL:
-		return "TX and RX PIO control";
-	case CSR_PSKEY_ANA_RX_LEVEL:
-		return "ANA_RX_LVL register initial value";
-	case CSR_PSKEY_ANA_RX_FTRIM:
-		return "ANA_RX_FTRIM register initial value";
-	case CSR_PSKEY_PSBC_DATA_VERSION:
-		return "Persistent store version";
-	case CSR_PSKEY_PCM0_ATTENUATION:
-		return "Volume control on PCM channel 0";
-	case CSR_PSKEY_LO_LVL_MAX:
-		return "Maximum value of LO level control register";
-	case CSR_PSKEY_LO_ADC_AMPL_MIN:
-		return "Minimum value of the LO amplitude measured on the ADC";
-	case CSR_PSKEY_LO_ADC_AMPL_MAX:
-		return "Maximum value of the LO amplitude measured on the ADC";
-	case CSR_PSKEY_IQ_TRIM_CHANNEL:
-		return "IQ calibration channel";
-	case CSR_PSKEY_IQ_TRIM_GAIN:
-		return "IQ calibration gain";
-	case CSR_PSKEY_IQ_TRIM_ENABLE:
-		return "IQ calibration enable";
-	case CSR_PSKEY_TX_OFFSET_HALF_MHZ:
-		return "Transmit offset";
-	case CSR_PSKEY_GBL_MISC_ENABLES:
-		return "Global miscellaneous hardware enables";
-	case CSR_PSKEY_UART_SLEEP_TIMEOUT:
-		return "Time in ms to deep sleep if nothing received";
-	case CSR_PSKEY_DEEP_SLEEP_STATE:
-		return "Deep sleep state usage";
-	case CSR_PSKEY_IQ_ENABLE_PHASE_TRIM:
-		return "IQ phase enable";
-	case CSR_PSKEY_HCI_HANDLE_FREEZE_PERIOD:
-		return "Time for which HCI handle is frozen after link removal";
-	case CSR_PSKEY_MAX_FROZEN_HCI_HANDLES:
-		return "Maximum number of frozen HCI handles";
-	case CSR_PSKEY_PAGETABLE_DESTRUCTION_DELAY:
-		return "Delay from freezing buf handle to deleting page table";
-	case CSR_PSKEY_IQ_TRIM_PIO_SETTINGS:
-		return "IQ PIO settings";
-	case CSR_PSKEY_USE_EXTERNAL_CLOCK:
-		return "Device uses an external clock";
-	case CSR_PSKEY_DEEP_SLEEP_WAKE_CTS:
-		return "Exit deep sleep on CTS line activity";
-	case CSR_PSKEY_FC_HC2H_FLUSH_DELAY:
-		return "Delay from disconnect to flushing HC->H FC tokens";
-	case CSR_PSKEY_RX_HIGHSIDE:
-		return "Disable the HIGHSIDE bit in ANA_CONFIG";
-	case CSR_PSKEY_TX_PRE_LVL:
-		return "TX pre-amplifier level";
-	case CSR_PSKEY_RX_SINGLE_ENDED:
-		return "RX single ended";
-	case CSR_PSKEY_TX_FILTER_CONFIG:
-		return "TX filter configuration";
-	case CSR_PSKEY_CLOCK_REQUEST_ENABLE:
-		return "External clock request enable";
-	case CSR_PSKEY_RX_MIN_ATTEN:
-		return "Minimum attenuation allowed for receiver";
-	case CSR_PSKEY_XTAL_TARGET_AMPLITUDE:
-		return "Crystal target amplitude";
-	case CSR_PSKEY_PCM_MIN_CPU_CLOCK:
-		return "Minimum CPU clock speed with PCM port running";
-	case CSR_PSKEY_HOST_INTERFACE_PIO_USB:
-		return "USB host interface selection PIO line";
-	case CSR_PSKEY_CPU_IDLE_MODE:
-		return "CPU idle mode when radio is active";
-	case CSR_PSKEY_DEEP_SLEEP_CLEAR_RTS:
-		return "Deep sleep clears the UART RTS line";
-	case CSR_PSKEY_RF_RESONANCE_TRIM:
-		return "Frequency trim for IQ and LNA resonant circuits";
-	case CSR_PSKEY_DEEP_SLEEP_PIO_WAKE:
-		return "PIO line to wake the chip from deep sleep";
-	case CSR_PSKEY_DRAIN_BORE_TIMERS:
-		return "Energy consumption measurement settings";
-	case CSR_PSKEY_DRAIN_TX_POWER_BASE:
-		return "Energy consumption measurement settings";
-	case CSR_PSKEY_MODULE_ID:
-		return "Module serial number";
-	case CSR_PSKEY_MODULE_DESIGN:
-		return "Module design ID";
-	case CSR_PSKEY_MODULE_SECURITY_CODE:
-		return "Module security code";
-	case CSR_PSKEY_VM_DISABLE:
-		return "VM disable";
-	case CSR_PSKEY_MOD_MANUF0:
-		return "Module manufactuer data 0";
-	case CSR_PSKEY_MOD_MANUF1:
-		return "Module manufactuer data 1";
-	case CSR_PSKEY_MOD_MANUF2:
-		return "Module manufactuer data 2";
-	case CSR_PSKEY_MOD_MANUF3:
-		return "Module manufactuer data 3";
-	case CSR_PSKEY_MOD_MANUF4:
-		return "Module manufactuer data 4";
-	case CSR_PSKEY_MOD_MANUF5:
-		return "Module manufactuer data 5";
-	case CSR_PSKEY_MOD_MANUF6:
-		return "Module manufactuer data 6";
-	case CSR_PSKEY_MOD_MANUF7:
-		return "Module manufactuer data 7";
-	case CSR_PSKEY_MOD_MANUF8:
-		return "Module manufactuer data 8";
-	case CSR_PSKEY_MOD_MANUF9:
-		return "Module manufactuer data 9";
-	case CSR_PSKEY_DUT_VM_DISABLE:
-		return "VM disable when entering radiotest modes";
-	case CSR_PSKEY_USR0:
-		return "User configuration data 0";
-	case CSR_PSKEY_USR1:
-		return "User configuration data 1";
-	case CSR_PSKEY_USR2:
-		return "User configuration data 2";
-	case CSR_PSKEY_USR3:
-		return "User configuration data 3";
-	case CSR_PSKEY_USR4:
-		return "User configuration data 4";
-	case CSR_PSKEY_USR5:
-		return "User configuration data 5";
-	case CSR_PSKEY_USR6:
-		return "User configuration data 6";
-	case CSR_PSKEY_USR7:
-		return "User configuration data 7";
-	case CSR_PSKEY_USR8:
-		return "User configuration data 8";
-	case CSR_PSKEY_USR9:
-		return "User configuration data 9";
-	case CSR_PSKEY_USR10:
-		return "User configuration data 10";
-	case CSR_PSKEY_USR11:
-		return "User configuration data 11";
-	case CSR_PSKEY_USR12:
-		return "User configuration data 12";
-	case CSR_PSKEY_USR13:
-		return "User configuration data 13";
-	case CSR_PSKEY_USR14:
-		return "User configuration data 14";
-	case CSR_PSKEY_USR15:
-		return "User configuration data 15";
-	case CSR_PSKEY_USR16:
-		return "User configuration data 16";
-	case CSR_PSKEY_USR17:
-		return "User configuration data 17";
-	case CSR_PSKEY_USR18:
-		return "User configuration data 18";
-	case CSR_PSKEY_USR19:
-		return "User configuration data 19";
-	case CSR_PSKEY_USR20:
-		return "User configuration data 20";
-	case CSR_PSKEY_USR21:
-		return "User configuration data 21";
-	case CSR_PSKEY_USR22:
-		return "User configuration data 22";
-	case CSR_PSKEY_USR23:
-		return "User configuration data 23";
-	case CSR_PSKEY_USR24:
-		return "User configuration data 24";
-	case CSR_PSKEY_USR25:
-		return "User configuration data 25";
-	case CSR_PSKEY_USR26:
-		return "User configuration data 26";
-	case CSR_PSKEY_USR27:
-		return "User configuration data 27";
-	case CSR_PSKEY_USR28:
-		return "User configuration data 28";
-	case CSR_PSKEY_USR29:
-		return "User configuration data 29";
-	case CSR_PSKEY_USR30:
-		return "User configuration data 30";
-	case CSR_PSKEY_USR31:
-		return "User configuration data 31";
-	case CSR_PSKEY_USR32:
-		return "User configuration data 32";
-	case CSR_PSKEY_USR33:
-		return "User configuration data 33";
-	case CSR_PSKEY_USR34:
-		return "User configuration data 34";
-	case CSR_PSKEY_USR35:
-		return "User configuration data 35";
-	case CSR_PSKEY_USR36:
-		return "User configuration data 36";
-	case CSR_PSKEY_USR37:
-		return "User configuration data 37";
-	case CSR_PSKEY_USR38:
-		return "User configuration data 38";
-	case CSR_PSKEY_USR39:
-		return "User configuration data 39";
-	case CSR_PSKEY_USR40:
-		return "User configuration data 40";
-	case CSR_PSKEY_USR41:
-		return "User configuration data 41";
-	case CSR_PSKEY_USR42:
-		return "User configuration data 42";
-	case CSR_PSKEY_USR43:
-		return "User configuration data 43";
-	case CSR_PSKEY_USR44:
-		return "User configuration data 44";
-	case CSR_PSKEY_USR45:
-		return "User configuration data 45";
-	case CSR_PSKEY_USR46:
-		return "User configuration data 46";
-	case CSR_PSKEY_USR47:
-		return "User configuration data 47";
-	case CSR_PSKEY_USR48:
-		return "User configuration data 48";
-	case CSR_PSKEY_USR49:
-		return "User configuration data 49";
-	case CSR_PSKEY_USB_VERSION:
-		return "USB specification version number";
-	case CSR_PSKEY_USB_DEVICE_CLASS_CODES:
-		return "USB device class codes";
-	case CSR_PSKEY_USB_VENDOR_ID:
-		return "USB vendor identifier";
-	case CSR_PSKEY_USB_PRODUCT_ID:
-		return "USB product identifier";
-	case CSR_PSKEY_USB_MANUF_STRING:
-		return "USB manufacturer string";
-	case CSR_PSKEY_USB_PRODUCT_STRING:
-		return "USB product string";
-	case CSR_PSKEY_USB_SERIAL_NUMBER_STRING:
-		return "USB serial number string";
-	case CSR_PSKEY_USB_CONFIG_STRING:
-		return "USB configuration string";
-	case CSR_PSKEY_USB_ATTRIBUTES:
-		return "USB attributes bitmap";
-	case CSR_PSKEY_USB_MAX_POWER:
-		return "USB device maximum power consumption";
-	case CSR_PSKEY_USB_BT_IF_CLASS_CODES:
-		return "USB Bluetooth interface class codes";
-	case CSR_PSKEY_USB_LANGID:
-		return "USB language strings supported";
-	case CSR_PSKEY_USB_DFU_CLASS_CODES:
-		return "USB DFU class codes block";
-	case CSR_PSKEY_USB_DFU_PRODUCT_ID:
-		return "USB DFU product ID";
-	case CSR_PSKEY_USB_PIO_DETACH:
-		return "USB detach/attach PIO line";
-	case CSR_PSKEY_USB_PIO_WAKEUP:
-		return "USB wakeup PIO line";
-	case CSR_PSKEY_USB_PIO_PULLUP:
-		return "USB D+ pullup PIO line";
-	case CSR_PSKEY_USB_PIO_VBUS:
-		return "USB VBus detection PIO Line";
-	case CSR_PSKEY_USB_PIO_WAKE_TIMEOUT:
-		return "Timeout for assertion of USB PIO wake signal";
-	case CSR_PSKEY_USB_PIO_RESUME:
-		return "PIO signal used in place of bus resume";
-	case CSR_PSKEY_USB_BT_SCO_IF_CLASS_CODES:
-		return "USB Bluetooth SCO interface class codes";
-	case CSR_PSKEY_USB_SUSPEND_PIO_LEVEL:
-		return "USB PIO levels to set when suspended";
-	case CSR_PSKEY_USB_SUSPEND_PIO_DIR:
-		return "USB PIO I/O directions to set when suspended";
-	case CSR_PSKEY_USB_SUSPEND_PIO_MASK:
-		return "USB PIO lines to be set forcibly in suspend";
-	case CSR_PSKEY_USB_ENDPOINT_0_MAX_PACKET_SIZE:
-		return "The maxmimum packet size for USB endpoint 0";
-	case CSR_PSKEY_USB_CONFIG:
-		return "USB config params for new chips (>bc2)";
-	case CSR_PSKEY_RADIOTEST_ATTEN_INIT:
-		return "Radio test initial attenuator";
-	case CSR_PSKEY_RADIOTEST_FIRST_TRIM_TIME:
-		return "IQ first calibration period in test";
-	case CSR_PSKEY_RADIOTEST_SUBSEQUENT_TRIM_TIME:
-		return "IQ subsequent calibration period in test";
-	case CSR_PSKEY_RADIOTEST_LO_LVL_TRIM_ENABLE:
-		return "LO_LVL calibration enable";
-	case CSR_PSKEY_RADIOTEST_DISABLE_MODULATION:
-		return "Disable modulation during radiotest transmissions";
-	case CSR_PSKEY_RFCOMM_FCON_THRESHOLD:
-		return "RFCOMM aggregate flow control on threshold";
-	case CSR_PSKEY_RFCOMM_FCOFF_THRESHOLD:
-		return "RFCOMM aggregate flow control off threshold";
-	case CSR_PSKEY_IPV6_STATIC_ADDR:
-		return "Static IPv6 address";
-	case CSR_PSKEY_IPV4_STATIC_ADDR:
-		return "Static IPv4 address";
-	case CSR_PSKEY_IPV6_STATIC_PREFIX_LEN:
-		return "Static IPv6 prefix length";
-	case CSR_PSKEY_IPV6_STATIC_ROUTER_ADDR:
-		return "Static IPv6 router address";
-	case CSR_PSKEY_IPV4_STATIC_SUBNET_MASK:
-		return "Static IPv4 subnet mask";
-	case CSR_PSKEY_IPV4_STATIC_ROUTER_ADDR:
-		return "Static IPv4 router address";
-	case CSR_PSKEY_MDNS_NAME:
-		return "Multicast DNS name";
-	case CSR_PSKEY_FIXED_PIN:
-		return "Fixed PIN";
-	case CSR_PSKEY_MDNS_PORT:
-		return "Multicast DNS port";
-	case CSR_PSKEY_MDNS_TTL:
-		return "Multicast DNS TTL";
-	case CSR_PSKEY_MDNS_IPV4_ADDR:
-		return "Multicast DNS IPv4 address";
-	case CSR_PSKEY_ARP_CACHE_TIMEOUT:
-		return "ARP cache timeout";
-	case CSR_PSKEY_HFP_POWER_TABLE:
-		return "HFP power table";
-	case CSR_PSKEY_DRAIN_BORE_TIMER_COUNTERS:
-		return "Energy consumption estimation timer counters";
-	case CSR_PSKEY_DRAIN_BORE_COUNTERS:
-		return "Energy consumption estimation counters";
-	case CSR_PSKEY_LOOP_FILTER_TRIM:
-		return "Trim value to optimise loop filter";
-	case CSR_PSKEY_DRAIN_BORE_CURRENT_PEAK:
-		return "Energy consumption estimation current peak";
-	case CSR_PSKEY_VM_E2_CACHE_LIMIT:
-		return "Maximum RAM for caching EEPROM VM application";
-	case CSR_PSKEY_FORCE_16MHZ_REF_PIO:
-		return "PIO line to force 16 MHz reference to be assumed";
-	case CSR_PSKEY_CDMA_LO_REF_LIMITS:
-		return "Local oscillator frequency reference limits for CDMA";
-	case CSR_PSKEY_CDMA_LO_ERROR_LIMITS:
-		return "Local oscillator frequency error limits for CDMA";
-	case CSR_PSKEY_CLOCK_STARTUP_DELAY:
-		return "Clock startup delay in milliseconds";
-	case CSR_PSKEY_DEEP_SLEEP_CORRECTION_FACTOR:
-		return "Deep sleep clock correction factor";
-	case CSR_PSKEY_TEMPERATURE_CALIBRATION:
-		return "Temperature in deg C for a given internal setting";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA:
-		return "Temperature for given internal PA adjustment";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL:
-		return "Temperature for a given TX_PRE_LVL adjustment";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB:
-		return "Temperature for a given TX_BB adjustment";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_ANA_FTRIM:
-		return "Temperature for given crystal trim adjustment";
-	case CSR_PSKEY_TEST_DELTA_OFFSET:
-		return "Frequency offset applied to synthesiser in test mode";
-	case CSR_PSKEY_RX_DYNAMIC_LVL_OFFSET:
-		return "Receiver dynamic level offset depending on channel";
-	case CSR_PSKEY_TEST_FORCE_OFFSET:
-		return "Force use of exact value in PSKEY_TEST_DELTA_OFFSET";
-	case CSR_PSKEY_RF_TRAP_BAD_DIVISION_RATIOS:
-		return "Trap bad division ratios in radio frequency tables";
-	case CSR_PSKEY_RADIOTEST_CDMA_LO_REF_LIMITS:
-		return "LO frequency reference limits for CDMA in radiotest";
-	case CSR_PSKEY_INITIAL_BOOTMODE:
-		return "Initial device bootmode";
-	case CSR_PSKEY_ONCHIP_HCI_CLIENT:
-		return "HCI traffic routed internally";
-	case CSR_PSKEY_RX_ATTEN_BACKOFF:
-		return "Receiver attenuation back-off";
-	case CSR_PSKEY_RX_ATTEN_UPDATE_RATE:
-		return "Receiver attenuation update rate";
-	case CSR_PSKEY_SYNTH_TXRX_THRESHOLDS:
-		return "Local oscillator tuning voltage limits for tx and rx";
-	case CSR_PSKEY_MIN_WAIT_STATES:
-		return "Flash wait state indicator";
-	case CSR_PSKEY_RSSI_CORRECTION:
-		return "RSSI correction factor.";
-	case CSR_PSKEY_SCHED_THROTTLE_TIMEOUT:
-		return "Scheduler performance control.";
-	case CSR_PSKEY_DEEP_SLEEP_USE_EXTERNAL_CLOCK:
-		return "Deep sleep uses external 32 kHz clock source";
-	case CSR_PSKEY_TRIM_RADIO_FILTERS:
-		return "Trim rx and tx radio filters if true.";
-	case CSR_PSKEY_TRANSMIT_OFFSET:
-		return "Transmit offset in units of 62.5 kHz";
-	case CSR_PSKEY_USB_VM_CONTROL:
-		return "VM application will supply USB descriptors";
-	case CSR_PSKEY_MR_ANA_RX_FTRIM:
-		return "Medium rate value for the ANA_RX_FTRIM register";
-	case CSR_PSKEY_I2C_CONFIG:
-		return "I2C configuration";
-	case CSR_PSKEY_IQ_LVL_RX:
-		return "IQ demand level for reception";
-	case CSR_PSKEY_MR_TX_FILTER_CONFIG:
-		return "TX filter configuration used for enhanced data rate";
-	case CSR_PSKEY_MR_TX_CONFIG2:
-		return "TX filter configuration used for enhanced data rate";
-	case CSR_PSKEY_USB_DONT_RESET_BOOTMODE_ON_HOST_RESET:
-		return "Don't reset bootmode if USB host resets";
-	case CSR_PSKEY_LC_USE_THROTTLING:
-		return "Adjust packet selection on packet error rate";
-	case CSR_PSKEY_CHARGER_TRIM:
-		return "Trim value for the current charger";
-	case CSR_PSKEY_CLOCK_REQUEST_FEATURES:
-		return "Clock request is tristated if enabled";
-	case CSR_PSKEY_TRANSMIT_OFFSET_CLASS1:
-		return "Transmit offset / 62.5 kHz for class 1 radios";
-	case CSR_PSKEY_TX_AVOID_PA_CLASS1_PIO:
-		return "PIO line asserted in class1 operation to avoid PA";
-	case CSR_PSKEY_MR_PIO_CONFIG:
-		return "PIO line asserted in class1 operation to avoid PA";
-	case CSR_PSKEY_UART_CONFIG2:
-		return "The UART Sampling point";
-	case CSR_PSKEY_CLASS1_IQ_LVL:
-		return "IQ demand level for class 1 power level";
-	case CSR_PSKEY_CLASS1_TX_CONFIG2:
-		return "TX filter configuration used for class 1 tx power";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA_CLASS1:
-		return "Temperature for given internal PA adjustment";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_EXTERNAL_PA_CLASS1:
-		return "Temperature for given internal PA adjustment";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL_MR:
-		return "Temperature adjustment for TX_PRE_LVL in EDR";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_HEADER:
-		return "Temperature for a given TX_BB in EDR header";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_PAYLOAD:
-		return "Temperature for a given TX_BB in EDR payload";
-	case CSR_PSKEY_RX_MR_EQ_TAPS:
-		return "Adjust receiver configuration for EDR";
-	case CSR_PSKEY_TX_PRE_LVL_CLASS1:
-		return "TX pre-amplifier level in class 1 operation";
-	case CSR_PSKEY_ANALOGUE_ATTENUATOR:
-		return "TX analogue attenuator setting";
-	case CSR_PSKEY_MR_RX_FILTER_TRIM:
-		return "Trim for receiver used in EDR.";
-	case CSR_PSKEY_MR_RX_FILTER_RESPONSE:
-		return "Filter response for receiver used in EDR.";
-	case CSR_PSKEY_PIO_WAKEUP_STATE:
-		return "PIO deep sleep wake up state ";
-	case CSR_PSKEY_MR_TX_IF_ATTEN_OFF_TEMP:
-		return "TX IF atten off temperature when using EDR.";
-	case CSR_PSKEY_LO_DIV_LATCH_BYPASS:
-		return "Bypass latch for LO dividers";
-	case CSR_PSKEY_LO_VCO_STANDBY:
-		return "Use standby mode for the LO VCO";
-	case CSR_PSKEY_SLOW_CLOCK_FILTER_SHIFT:
-		return "Slow clock sampling filter constant";
-	case CSR_PSKEY_SLOW_CLOCK_FILTER_DIVIDER:
-		return "Slow clock filter fractional threshold";
-	case CSR_PSKEY_USB_ATTRIBUTES_POWER:
-		return "USB self powered";
-	case CSR_PSKEY_USB_ATTRIBUTES_WAKEUP:
-		return "USB responds to wake-up";
-	case CSR_PSKEY_DFU_ATTRIBUTES_MANIFESTATION_TOLERANT:
-		return "DFU manifestation tolerant";
-	case CSR_PSKEY_DFU_ATTRIBUTES_CAN_UPLOAD:
-		return "DFU can upload";
-	case CSR_PSKEY_DFU_ATTRIBUTES_CAN_DOWNLOAD:
-		return "DFU can download";
-	case CSR_PSKEY_UART_CONFIG_STOP_BITS:
-		return "UART: stop bits";
-	case CSR_PSKEY_UART_CONFIG_PARITY_BIT:
-		return "UART: parity bit";
-	case CSR_PSKEY_UART_CONFIG_FLOW_CTRL_EN:
-		return "UART: hardware flow control";
-	case CSR_PSKEY_UART_CONFIG_RTS_AUTO_EN:
-		return "UART: RTS auto-enabled";
-	case CSR_PSKEY_UART_CONFIG_RTS:
-		return "UART: RTS asserted";
-	case CSR_PSKEY_UART_CONFIG_TX_ZERO_EN:
-		return "UART: TX zero enable";
-	case CSR_PSKEY_UART_CONFIG_NON_BCSP_EN:
-		return "UART: enable BCSP-specific hardware";
-	case CSR_PSKEY_UART_CONFIG_RX_RATE_DELAY:
-		return "UART: RX rate delay";
-	case CSR_PSKEY_UART_SEQ_TIMEOUT:
-		return "UART: BCSP ack timeout";
-	case CSR_PSKEY_UART_SEQ_RETRIES:
-		return "UART: retry limit in sequencing layer";
-	case CSR_PSKEY_UART_SEQ_WINSIZE:
-		return "UART: BCSP transmit window size";
-	case CSR_PSKEY_UART_USE_CRC_ON_TX:
-		return "UART: use BCSP CRCs";
-	case CSR_PSKEY_UART_HOST_INITIAL_STATE:
-		return "UART: initial host state";
-	case CSR_PSKEY_UART_HOST_ATTENTION_SPAN:
-		return "UART: host attention span";
-	case CSR_PSKEY_UART_HOST_WAKEUP_TIME:
-		return "UART: host wakeup time";
-	case CSR_PSKEY_UART_HOST_WAKEUP_WAIT:
-		return "UART: host wakeup wait";
-	case CSR_PSKEY_BCSP_LM_MODE:
-		return "BCSP link establishment mode";
-	case CSR_PSKEY_BCSP_LM_SYNC_RETRIES:
-		return "BCSP link establishment sync retries";
-	case CSR_PSKEY_BCSP_LM_TSHY:
-		return "BCSP link establishment Tshy";
-	case CSR_PSKEY_UART_DFU_CONFIG_STOP_BITS:
-		return "DFU mode UART: stop bits";
-	case CSR_PSKEY_UART_DFU_CONFIG_PARITY_BIT:
-		return "DFU mode UART: parity bit";
-	case CSR_PSKEY_UART_DFU_CONFIG_FLOW_CTRL_EN:
-		return "DFU mode UART: hardware flow control";
-	case CSR_PSKEY_UART_DFU_CONFIG_RTS_AUTO_EN:
-		return "DFU mode UART: RTS auto-enabled";
-	case CSR_PSKEY_UART_DFU_CONFIG_RTS:
-		return "DFU mode UART: RTS asserted";
-	case CSR_PSKEY_UART_DFU_CONFIG_TX_ZERO_EN:
-		return "DFU mode UART: TX zero enable";
-	case CSR_PSKEY_UART_DFU_CONFIG_NON_BCSP_EN:
-		return "DFU mode UART: enable BCSP-specific hardware";
-	case CSR_PSKEY_UART_DFU_CONFIG_RX_RATE_DELAY:
-		return "DFU mode UART: RX rate delay";
-	case CSR_PSKEY_AMUX_AIO0:
-		return "Multiplexer for AIO 0";
-	case CSR_PSKEY_AMUX_AIO1:
-		return "Multiplexer for AIO 1";
-	case CSR_PSKEY_AMUX_AIO2:
-		return "Multiplexer for AIO 2";
-	case CSR_PSKEY_AMUX_AIO3:
-		return "Multiplexer for AIO 3";
-	case CSR_PSKEY_LOCAL_NAME_SIMPLIFIED:
-		return "Local Name (simplified)";
-	case CSR_PSKEY_EXTENDED_STUB:
-		return "Extended stub";
-	default:
-		return "Unknown";
-	}
-}
-
-char *csr_pskeytoval(uint16_t pskey)
-{
-	switch (pskey) {
-	case CSR_PSKEY_BDADDR:
-		return "BDADDR";
-	case CSR_PSKEY_COUNTRYCODE:
-		return "COUNTRYCODE";
-	case CSR_PSKEY_CLASSOFDEVICE:
-		return "CLASSOFDEVICE";
-	case CSR_PSKEY_DEVICE_DRIFT:
-		return "DEVICE_DRIFT";
-	case CSR_PSKEY_DEVICE_JITTER:
-		return "DEVICE_JITTER";
-	case CSR_PSKEY_MAX_ACLS:
-		return "MAX_ACLS";
-	case CSR_PSKEY_MAX_SCOS:
-		return "MAX_SCOS";
-	case CSR_PSKEY_MAX_REMOTE_MASTERS:
-		return "MAX_REMOTE_MASTERS";
-	case CSR_PSKEY_ENABLE_MASTERY_WITH_SLAVERY:
-		return "ENABLE_MASTERY_WITH_SLAVERY";
-	case CSR_PSKEY_H_HC_FC_MAX_ACL_PKT_LEN:
-		return "H_HC_FC_MAX_ACL_PKT_LEN";
-	case CSR_PSKEY_H_HC_FC_MAX_SCO_PKT_LEN:
-		return "H_HC_FC_MAX_SCO_PKT_LEN";
-	case CSR_PSKEY_H_HC_FC_MAX_ACL_PKTS:
-		return "H_HC_FC_MAX_ACL_PKTS";
-	case CSR_PSKEY_H_HC_FC_MAX_SCO_PKTS:
-		return "H_HC_FC_MAX_SCO_PKTS";
-	case CSR_PSKEY_LC_FC_BUFFER_LOW_WATER_MARK:
-		return "LC_FC_BUFFER_LOW_WATER_MARK";
-	case CSR_PSKEY_LC_MAX_TX_POWER:
-		return "LC_MAX_TX_POWER";
-	case CSR_PSKEY_TX_GAIN_RAMP:
-		return "TX_GAIN_RAMP";
-	case CSR_PSKEY_LC_POWER_TABLE:
-		return "LC_POWER_TABLE";
-	case CSR_PSKEY_LC_PEER_POWER_PERIOD:
-		return "LC_PEER_POWER_PERIOD";
-	case CSR_PSKEY_LC_FC_POOLS_LOW_WATER_MARK:
-		return "LC_FC_POOLS_LOW_WATER_MARK";
-	case CSR_PSKEY_LC_DEFAULT_TX_POWER:
-		return "LC_DEFAULT_TX_POWER";
-	case CSR_PSKEY_LC_RSSI_GOLDEN_RANGE:
-		return "LC_RSSI_GOLDEN_RANGE";
-	case CSR_PSKEY_LC_COMBO_DISABLE_PIO_MASK:
-		return "LC_COMBO_DISABLE_PIO_MASK";
-	case CSR_PSKEY_LC_COMBO_PRIORITY_PIO_MASK:
-		return "LC_COMBO_PRIORITY_PIO_MASK";
-	case CSR_PSKEY_LC_COMBO_DOT11_CHANNEL_PIO_BASE:
-		return "LC_COMBO_DOT11_CHANNEL_PIO_BASE";
-	case CSR_PSKEY_LC_COMBO_DOT11_BLOCK_CHANNELS:
-		return "LC_COMBO_DOT11_BLOCK_CHANNELS";
-	case CSR_PSKEY_LC_MAX_TX_POWER_NO_RSSI:
-		return "LC_MAX_TX_POWER_NO_RSSI";
-	case CSR_PSKEY_LC_CONNECTION_RX_WINDOW:
-		return "LC_CONNECTION_RX_WINDOW";
-	case CSR_PSKEY_LC_COMBO_DOT11_TX_PROTECTION_MODE:
-		return "LC_COMBO_DOT11_TX_PROTECTION_MODE";
-	case CSR_PSKEY_LC_ENHANCED_POWER_TABLE:
-		return "LC_ENHANCED_POWER_TABLE";
-	case CSR_PSKEY_LC_WIDEBAND_RSSI_CONFIG:
-		return "LC_WIDEBAND_RSSI_CONFIG";
-	case CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_LEAD:
-		return "LC_COMBO_DOT11_PRIORITY_LEAD";
-	case CSR_PSKEY_BT_CLOCK_INIT:
-		return "BT_CLOCK_INIT";
-	case CSR_PSKEY_TX_MR_MOD_DELAY:
-		return "TX_MR_MOD_DELAY";
-	case CSR_PSKEY_RX_MR_SYNC_TIMING:
-		return "RX_MR_SYNC_TIMING";
-	case CSR_PSKEY_RX_MR_SYNC_CONFIG:
-		return "RX_MR_SYNC_CONFIG";
-	case CSR_PSKEY_LC_LOST_SYNC_SLOTS:
-		return "LC_LOST_SYNC_SLOTS";
-	case CSR_PSKEY_RX_MR_SAMP_CONFIG:
-		return "RX_MR_SAMP_CONFIG";
-	case CSR_PSKEY_AGC_HYST_LEVELS:
-		return "AGC_HYST_LEVELS";
-	case CSR_PSKEY_RX_LEVEL_LOW_SIGNAL:
-		return "RX_LEVEL_LOW_SIGNAL";
-	case CSR_PSKEY_AGC_IQ_LVL_VALUES:
-		return "AGC_IQ_LVL_VALUES";
-	case CSR_PSKEY_MR_FTRIM_OFFSET_12DB:
-		return "MR_FTRIM_OFFSET_12DB";
-	case CSR_PSKEY_MR_FTRIM_OFFSET_6DB:
-		return "MR_FTRIM_OFFSET_6DB";
-	case CSR_PSKEY_NO_CAL_ON_BOOT:
-		return "NO_CAL_ON_BOOT";
-	case CSR_PSKEY_RSSI_HI_TARGET:
-		return "RSSI_HI_TARGET";
-	case CSR_PSKEY_PREFERRED_MIN_ATTENUATION:
-		return "PREFERRED_MIN_ATTENUATION";
-	case CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_OVERRIDE:
-		return "LC_COMBO_DOT11_PRIORITY_OVERRIDE";
-	case CSR_PSKEY_LC_MULTISLOT_HOLDOFF:
-		return "LC_MULTISLOT_HOLDOFF";
-	case CSR_PSKEY_FREE_KEY_PIGEON_HOLE:
-		return "FREE_KEY_PIGEON_HOLE";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR0:
-		return "LINK_KEY_BD_ADDR0";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR1:
-		return "LINK_KEY_BD_ADDR1";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR2:
-		return "LINK_KEY_BD_ADDR2";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR3:
-		return "LINK_KEY_BD_ADDR3";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR4:
-		return "LINK_KEY_BD_ADDR4";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR5:
-		return "LINK_KEY_BD_ADDR5";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR6:
-		return "LINK_KEY_BD_ADDR6";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR7:
-		return "LINK_KEY_BD_ADDR7";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR8:
-		return "LINK_KEY_BD_ADDR8";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR9:
-		return "LINK_KEY_BD_ADDR9";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR10:
-		return "LINK_KEY_BD_ADDR10";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR11:
-		return "LINK_KEY_BD_ADDR11";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR12:
-		return "LINK_KEY_BD_ADDR12";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR13:
-		return "LINK_KEY_BD_ADDR13";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR14:
-		return "LINK_KEY_BD_ADDR14";
-	case CSR_PSKEY_LINK_KEY_BD_ADDR15:
-		return "LINK_KEY_BD_ADDR15";
-	case CSR_PSKEY_ENC_KEY_LMIN:
-		return "ENC_KEY_LMIN";
-	case CSR_PSKEY_ENC_KEY_LMAX:
-		return "ENC_KEY_LMAX";
-	case CSR_PSKEY_LOCAL_SUPPORTED_FEATURES:
-		return "LOCAL_SUPPORTED_FEATURES";
-	case CSR_PSKEY_LM_USE_UNIT_KEY:
-		return "LM_USE_UNIT_KEY";
-	case CSR_PSKEY_HCI_NOP_DISABLE:
-		return "HCI_NOP_DISABLE";
-	case CSR_PSKEY_LM_MAX_EVENT_FILTERS:
-		return "LM_MAX_EVENT_FILTERS";
-	case CSR_PSKEY_LM_USE_ENC_MODE_BROADCAST:
-		return "LM_USE_ENC_MODE_BROADCAST";
-	case CSR_PSKEY_LM_TEST_SEND_ACCEPTED_TWICE:
-		return "LM_TEST_SEND_ACCEPTED_TWICE";
-	case CSR_PSKEY_LM_MAX_PAGE_HOLD_TIME:
-		return "LM_MAX_PAGE_HOLD_TIME";
-	case CSR_PSKEY_AFH_ADAPTATION_RESPONSE_TIME:
-		return "AFH_ADAPTATION_RESPONSE_TIME";
-	case CSR_PSKEY_AFH_OPTIONS:
-		return "AFH_OPTIONS";
-	case CSR_PSKEY_AFH_RSSI_RUN_PERIOD:
-		return "AFH_RSSI_RUN_PERIOD";
-	case CSR_PSKEY_AFH_REENABLE_CHANNEL_TIME:
-		return "AFH_REENABLE_CHANNEL_TIME";
-	case CSR_PSKEY_NO_DROP_ON_ACR_MS_FAIL:
-		return "NO_DROP_ON_ACR_MS_FAIL";
-	case CSR_PSKEY_MAX_PRIVATE_KEYS:
-		return "MAX_PRIVATE_KEYS";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR0:
-		return "PRIVATE_LINK_KEY_BD_ADDR0";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR1:
-		return "PRIVATE_LINK_KEY_BD_ADDR1";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR2:
-		return "PRIVATE_LINK_KEY_BD_ADDR2";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR3:
-		return "PRIVATE_LINK_KEY_BD_ADDR3";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR4:
-		return "PRIVATE_LINK_KEY_BD_ADDR4";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR5:
-		return "PRIVATE_LINK_KEY_BD_ADDR5";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR6:
-		return "PRIVATE_LINK_KEY_BD_ADDR6";
-	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR7:
-		return "PRIVATE_LINK_KEY_BD_ADDR7";
-	case CSR_PSKEY_LOCAL_SUPPORTED_COMMANDS:
-		return "LOCAL_SUPPORTED_COMMANDS";
-	case CSR_PSKEY_LM_MAX_ABSENCE_INDEX:
-		return "LM_MAX_ABSENCE_INDEX";
-	case CSR_PSKEY_DEVICE_NAME:
-		return "DEVICE_NAME";
-	case CSR_PSKEY_AFH_RSSI_THRESHOLD:
-		return "AFH_RSSI_THRESHOLD";
-	case CSR_PSKEY_LM_CASUAL_SCAN_INTERVAL:
-		return "LM_CASUAL_SCAN_INTERVAL";
-	case CSR_PSKEY_AFH_MIN_MAP_CHANGE:
-		return "AFH_MIN_MAP_CHANGE";
-	case CSR_PSKEY_AFH_RSSI_LP_RUN_PERIOD:
-		return "AFH_RSSI_LP_RUN_PERIOD";
-	case CSR_PSKEY_HCI_LMP_LOCAL_VERSION:
-		return "HCI_LMP_LOCAL_VERSION";
-	case CSR_PSKEY_LMP_REMOTE_VERSION:
-		return "LMP_REMOTE_VERSION";
-	case CSR_PSKEY_HOLD_ERROR_MESSAGE_NUMBER:
-		return "HOLD_ERROR_MESSAGE_NUMBER";
-	case CSR_PSKEY_DFU_ATTRIBUTES:
-		return "DFU_ATTRIBUTES";
-	case CSR_PSKEY_DFU_DETACH_TO:
-		return "DFU_DETACH_TO";
-	case CSR_PSKEY_DFU_TRANSFER_SIZE:
-		return "DFU_TRANSFER_SIZE";
-	case CSR_PSKEY_DFU_ENABLE:
-		return "DFU_ENABLE";
-	case CSR_PSKEY_DFU_LIN_REG_ENABLE:
-		return "DFU_LIN_REG_ENABLE";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_MSB:
-		return "DFUENC_VMAPP_PK_MODULUS_MSB";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_LSB:
-		return "DFUENC_VMAPP_PK_MODULUS_LSB";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_M_DASH:
-		return "DFUENC_VMAPP_PK_M_DASH";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_R2N_MSB:
-		return "DFUENC_VMAPP_PK_R2N_MSB";
-	case CSR_PSKEY_DFUENC_VMAPP_PK_R2N_LSB:
-		return "DFUENC_VMAPP_PK_R2N_LSB";
-	case CSR_PSKEY_BCSP_LM_PS_BLOCK:
-		return "BCSP_LM_PS_BLOCK";
-	case CSR_PSKEY_HOSTIO_FC_PS_BLOCK:
-		return "HOSTIO_FC_PS_BLOCK";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO0:
-		return "HOSTIO_PROTOCOL_INFO0";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO1:
-		return "HOSTIO_PROTOCOL_INFO1";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO2:
-		return "HOSTIO_PROTOCOL_INFO2";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO3:
-		return "HOSTIO_PROTOCOL_INFO3";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO4:
-		return "HOSTIO_PROTOCOL_INFO4";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO5:
-		return "HOSTIO_PROTOCOL_INFO5";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO6:
-		return "HOSTIO_PROTOCOL_INFO6";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO7:
-		return "HOSTIO_PROTOCOL_INFO7";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO8:
-		return "HOSTIO_PROTOCOL_INFO8";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO9:
-		return "HOSTIO_PROTOCOL_INFO9";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO10:
-		return "HOSTIO_PROTOCOL_INFO10";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO11:
-		return "HOSTIO_PROTOCOL_INFO11";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO12:
-		return "HOSTIO_PROTOCOL_INFO12";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO13:
-		return "HOSTIO_PROTOCOL_INFO13";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO14:
-		return "HOSTIO_PROTOCOL_INFO14";
-	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO15:
-		return "HOSTIO_PROTOCOL_INFO15";
-	case CSR_PSKEY_HOSTIO_UART_RESET_TIMEOUT:
-		return "HOSTIO_UART_RESET_TIMEOUT";
-	case CSR_PSKEY_HOSTIO_USE_HCI_EXTN:
-		return "HOSTIO_USE_HCI_EXTN";
-	case CSR_PSKEY_HOSTIO_USE_HCI_EXTN_CCFC:
-		return "HOSTIO_USE_HCI_EXTN_CCFC";
-	case CSR_PSKEY_HOSTIO_HCI_EXTN_PAYLOAD_SIZE:
-		return "HOSTIO_HCI_EXTN_PAYLOAD_SIZE";
-	case CSR_PSKEY_BCSP_LM_CNF_CNT_LIMIT:
-		return "BCSP_LM_CNF_CNT_LIMIT";
-	case CSR_PSKEY_HOSTIO_MAP_SCO_PCM:
-		return "HOSTIO_MAP_SCO_PCM";
-	case CSR_PSKEY_HOSTIO_AWKWARD_PCM_SYNC:
-		return "HOSTIO_AWKWARD_PCM_SYNC";
-	case CSR_PSKEY_HOSTIO_BREAK_POLL_PERIOD:
-		return "HOSTIO_BREAK_POLL_PERIOD";
-	case CSR_PSKEY_HOSTIO_MIN_UART_HCI_SCO_SIZE:
-		return "HOSTIO_MIN_UART_HCI_SCO_SIZE";
-	case CSR_PSKEY_HOSTIO_MAP_SCO_CODEC:
-		return "HOSTIO_MAP_SCO_CODEC";
-	case CSR_PSKEY_PCM_CVSD_TX_HI_FREQ_BOOST:
-		return "PCM_CVSD_TX_HI_FREQ_BOOST";
-	case CSR_PSKEY_PCM_CVSD_RX_HI_FREQ_BOOST:
-		return "PCM_CVSD_RX_HI_FREQ_BOOST";
-	case CSR_PSKEY_PCM_CONFIG32:
-		return "PCM_CONFIG32";
-	case CSR_PSKEY_USE_OLD_BCSP_LE:
-		return "USE_OLD_BCSP_LE";
-	case CSR_PSKEY_PCM_CVSD_USE_NEW_FILTER:
-		return "PCM_CVSD_USE_NEW_FILTER";
-	case CSR_PSKEY_PCM_FORMAT:
-		return "PCM_FORMAT";
-	case CSR_PSKEY_CODEC_OUT_GAIN:
-		return "CODEC_OUT_GAIN";
-	case CSR_PSKEY_CODEC_IN_GAIN:
-		return "CODEC_IN_GAIN";
-	case CSR_PSKEY_CODEC_PIO:
-		return "CODEC_PIO";
-	case CSR_PSKEY_PCM_LOW_JITTER_CONFIG:
-		return "PCM_LOW_JITTER_CONFIG";
-	case CSR_PSKEY_HOSTIO_SCO_PCM_THRESHOLDS:
-		return "HOSTIO_SCO_PCM_THRESHOLDS";
-	case CSR_PSKEY_HOSTIO_SCO_HCI_THRESHOLDS:
-		return "HOSTIO_SCO_HCI_THRESHOLDS";
-	case CSR_PSKEY_HOSTIO_MAP_SCO_PCM_SLOT:
-		return "HOSTIO_MAP_SCO_PCM_SLOT";
-	case CSR_PSKEY_UART_BAUDRATE:
-		return "UART_BAUDRATE";
-	case CSR_PSKEY_UART_CONFIG_BCSP:
-		return "UART_CONFIG_BCSP";
-	case CSR_PSKEY_UART_CONFIG_H4:
-		return "UART_CONFIG_H4";
-	case CSR_PSKEY_UART_CONFIG_H5:
-		return "UART_CONFIG_H5";
-	case CSR_PSKEY_UART_CONFIG_USR:
-		return "UART_CONFIG_USR";
-	case CSR_PSKEY_UART_TX_CRCS:
-		return "UART_TX_CRCS";
-	case CSR_PSKEY_UART_ACK_TIMEOUT:
-		return "UART_ACK_TIMEOUT";
-	case CSR_PSKEY_UART_TX_MAX_ATTEMPTS:
-		return "UART_TX_MAX_ATTEMPTS";
-	case CSR_PSKEY_UART_TX_WINDOW_SIZE:
-		return "UART_TX_WINDOW_SIZE";
-	case CSR_PSKEY_UART_HOST_WAKE:
-		return "UART_HOST_WAKE";
-	case CSR_PSKEY_HOSTIO_THROTTLE_TIMEOUT:
-		return "HOSTIO_THROTTLE_TIMEOUT";
-	case CSR_PSKEY_PCM_ALWAYS_ENABLE:
-		return "PCM_ALWAYS_ENABLE";
-	case CSR_PSKEY_UART_HOST_WAKE_SIGNAL:
-		return "UART_HOST_WAKE_SIGNAL";
-	case CSR_PSKEY_UART_CONFIG_H4DS:
-		return "UART_CONFIG_H4DS";
-	case CSR_PSKEY_H4DS_WAKE_DURATION:
-		return "H4DS_WAKE_DURATION";
-	case CSR_PSKEY_H4DS_MAXWU:
-		return "H4DS_MAXWU";
-	case CSR_PSKEY_H4DS_LE_TIMER_PERIOD:
-		return "H4DS_LE_TIMER_PERIOD";
-	case CSR_PSKEY_H4DS_TWU_TIMER_PERIOD:
-		return "H4DS_TWU_TIMER_PERIOD";
-	case CSR_PSKEY_H4DS_UART_IDLE_TIMER_PERIOD:
-		return "H4DS_UART_IDLE_TIMER_PERIOD";
-	case CSR_PSKEY_ANA_FTRIM:
-		return "ANA_FTRIM";
-	case CSR_PSKEY_WD_TIMEOUT:
-		return "WD_TIMEOUT";
-	case CSR_PSKEY_WD_PERIOD:
-		return "WD_PERIOD";
-	case CSR_PSKEY_HOST_INTERFACE:
-		return "HOST_INTERFACE";
-	case CSR_PSKEY_HQ_HOST_TIMEOUT:
-		return "HQ_HOST_TIMEOUT";
-	case CSR_PSKEY_HQ_ACTIVE:
-		return "HQ_ACTIVE";
-	case CSR_PSKEY_BCCMD_SECURITY_ACTIVE:
-		return "BCCMD_SECURITY_ACTIVE";
-	case CSR_PSKEY_ANA_FREQ:
-		return "ANA_FREQ";
-	case CSR_PSKEY_PIO_PROTECT_MASK:
-		return "PIO_PROTECT_MASK";
-	case CSR_PSKEY_PMALLOC_SIZES:
-		return "PMALLOC_SIZES";
-	case CSR_PSKEY_UART_BAUD_RATE:
-		return "UART_BAUD_RATE";
-	case CSR_PSKEY_UART_CONFIG:
-		return "UART_CONFIG";
-	case CSR_PSKEY_STUB:
-		return "STUB";
-	case CSR_PSKEY_TXRX_PIO_CONTROL:
-		return "TXRX_PIO_CONTROL";
-	case CSR_PSKEY_ANA_RX_LEVEL:
-		return "ANA_RX_LEVEL";
-	case CSR_PSKEY_ANA_RX_FTRIM:
-		return "ANA_RX_FTRIM";
-	case CSR_PSKEY_PSBC_DATA_VERSION:
-		return "PSBC_DATA_VERSION";
-	case CSR_PSKEY_PCM0_ATTENUATION:
-		return "PCM0_ATTENUATION";
-	case CSR_PSKEY_LO_LVL_MAX:
-		return "LO_LVL_MAX";
-	case CSR_PSKEY_LO_ADC_AMPL_MIN:
-		return "LO_ADC_AMPL_MIN";
-	case CSR_PSKEY_LO_ADC_AMPL_MAX:
-		return "LO_ADC_AMPL_MAX";
-	case CSR_PSKEY_IQ_TRIM_CHANNEL:
-		return "IQ_TRIM_CHANNEL";
-	case CSR_PSKEY_IQ_TRIM_GAIN:
-		return "IQ_TRIM_GAIN";
-	case CSR_PSKEY_IQ_TRIM_ENABLE:
-		return "IQ_TRIM_ENABLE";
-	case CSR_PSKEY_TX_OFFSET_HALF_MHZ:
-		return "TX_OFFSET_HALF_MHZ";
-	case CSR_PSKEY_GBL_MISC_ENABLES:
-		return "GBL_MISC_ENABLES";
-	case CSR_PSKEY_UART_SLEEP_TIMEOUT:
-		return "UART_SLEEP_TIMEOUT";
-	case CSR_PSKEY_DEEP_SLEEP_STATE:
-		return "DEEP_SLEEP_STATE";
-	case CSR_PSKEY_IQ_ENABLE_PHASE_TRIM:
-		return "IQ_ENABLE_PHASE_TRIM";
-	case CSR_PSKEY_HCI_HANDLE_FREEZE_PERIOD:
-		return "HCI_HANDLE_FREEZE_PERIOD";
-	case CSR_PSKEY_MAX_FROZEN_HCI_HANDLES:
-		return "MAX_FROZEN_HCI_HANDLES";
-	case CSR_PSKEY_PAGETABLE_DESTRUCTION_DELAY:
-		return "PAGETABLE_DESTRUCTION_DELAY";
-	case CSR_PSKEY_IQ_TRIM_PIO_SETTINGS:
-		return "IQ_TRIM_PIO_SETTINGS";
-	case CSR_PSKEY_USE_EXTERNAL_CLOCK:
-		return "USE_EXTERNAL_CLOCK";
-	case CSR_PSKEY_DEEP_SLEEP_WAKE_CTS:
-		return "DEEP_SLEEP_WAKE_CTS";
-	case CSR_PSKEY_FC_HC2H_FLUSH_DELAY:
-		return "FC_HC2H_FLUSH_DELAY";
-	case CSR_PSKEY_RX_HIGHSIDE:
-		return "RX_HIGHSIDE";
-	case CSR_PSKEY_TX_PRE_LVL:
-		return "TX_PRE_LVL";
-	case CSR_PSKEY_RX_SINGLE_ENDED:
-		return "RX_SINGLE_ENDED";
-	case CSR_PSKEY_TX_FILTER_CONFIG:
-		return "TX_FILTER_CONFIG";
-	case CSR_PSKEY_CLOCK_REQUEST_ENABLE:
-		return "CLOCK_REQUEST_ENABLE";
-	case CSR_PSKEY_RX_MIN_ATTEN:
-		return "RX_MIN_ATTEN";
-	case CSR_PSKEY_XTAL_TARGET_AMPLITUDE:
-		return "XTAL_TARGET_AMPLITUDE";
-	case CSR_PSKEY_PCM_MIN_CPU_CLOCK:
-		return "PCM_MIN_CPU_CLOCK";
-	case CSR_PSKEY_HOST_INTERFACE_PIO_USB:
-		return "HOST_INTERFACE_PIO_USB";
-	case CSR_PSKEY_CPU_IDLE_MODE:
-		return "CPU_IDLE_MODE";
-	case CSR_PSKEY_DEEP_SLEEP_CLEAR_RTS:
-		return "DEEP_SLEEP_CLEAR_RTS";
-	case CSR_PSKEY_RF_RESONANCE_TRIM:
-		return "RF_RESONANCE_TRIM";
-	case CSR_PSKEY_DEEP_SLEEP_PIO_WAKE:
-		return "DEEP_SLEEP_PIO_WAKE";
-	case CSR_PSKEY_DRAIN_BORE_TIMERS:
-		return "DRAIN_BORE_TIMERS";
-	case CSR_PSKEY_DRAIN_TX_POWER_BASE:
-		return "DRAIN_TX_POWER_BASE";
-	case CSR_PSKEY_MODULE_ID:
-		return "MODULE_ID";
-	case CSR_PSKEY_MODULE_DESIGN:
-		return "MODULE_DESIGN";
-	case CSR_PSKEY_MODULE_SECURITY_CODE:
-		return "MODULE_SECURITY_CODE";
-	case CSR_PSKEY_VM_DISABLE:
-		return "VM_DISABLE";
-	case CSR_PSKEY_MOD_MANUF0:
-		return "MOD_MANUF0";
-	case CSR_PSKEY_MOD_MANUF1:
-		return "MOD_MANUF1";
-	case CSR_PSKEY_MOD_MANUF2:
-		return "MOD_MANUF2";
-	case CSR_PSKEY_MOD_MANUF3:
-		return "MOD_MANUF3";
-	case CSR_PSKEY_MOD_MANUF4:
-		return "MOD_MANUF4";
-	case CSR_PSKEY_MOD_MANUF5:
-		return "MOD_MANUF5";
-	case CSR_PSKEY_MOD_MANUF6:
-		return "MOD_MANUF6";
-	case CSR_PSKEY_MOD_MANUF7:
-		return "MOD_MANUF7";
-	case CSR_PSKEY_MOD_MANUF8:
-		return "MOD_MANUF8";
-	case CSR_PSKEY_MOD_MANUF9:
-		return "MOD_MANUF9";
-	case CSR_PSKEY_DUT_VM_DISABLE:
-		return "DUT_VM_DISABLE";
-	case CSR_PSKEY_USR0:
-		return "USR0";
-	case CSR_PSKEY_USR1:
-		return "USR1";
-	case CSR_PSKEY_USR2:
-		return "USR2";
-	case CSR_PSKEY_USR3:
-		return "USR3";
-	case CSR_PSKEY_USR4:
-		return "USR4";
-	case CSR_PSKEY_USR5:
-		return "USR5";
-	case CSR_PSKEY_USR6:
-		return "USR6";
-	case CSR_PSKEY_USR7:
-		return "USR7";
-	case CSR_PSKEY_USR8:
-		return "USR8";
-	case CSR_PSKEY_USR9:
-		return "USR9";
-	case CSR_PSKEY_USR10:
-		return "USR10";
-	case CSR_PSKEY_USR11:
-		return "USR11";
-	case CSR_PSKEY_USR12:
-		return "USR12";
-	case CSR_PSKEY_USR13:
-		return "USR13";
-	case CSR_PSKEY_USR14:
-		return "USR14";
-	case CSR_PSKEY_USR15:
-		return "USR15";
-	case CSR_PSKEY_USR16:
-		return "USR16";
-	case CSR_PSKEY_USR17:
-		return "USR17";
-	case CSR_PSKEY_USR18:
-		return "USR18";
-	case CSR_PSKEY_USR19:
-		return "USR19";
-	case CSR_PSKEY_USR20:
-		return "USR20";
-	case CSR_PSKEY_USR21:
-		return "USR21";
-	case CSR_PSKEY_USR22:
-		return "USR22";
-	case CSR_PSKEY_USR23:
-		return "USR23";
-	case CSR_PSKEY_USR24:
-		return "USR24";
-	case CSR_PSKEY_USR25:
-		return "USR25";
-	case CSR_PSKEY_USR26:
-		return "USR26";
-	case CSR_PSKEY_USR27:
-		return "USR27";
-	case CSR_PSKEY_USR28:
-		return "USR28";
-	case CSR_PSKEY_USR29:
-		return "USR29";
-	case CSR_PSKEY_USR30:
-		return "USR30";
-	case CSR_PSKEY_USR31:
-		return "USR31";
-	case CSR_PSKEY_USR32:
-		return "USR32";
-	case CSR_PSKEY_USR33:
-		return "USR33";
-	case CSR_PSKEY_USR34:
-		return "USR34";
-	case CSR_PSKEY_USR35:
-		return "USR35";
-	case CSR_PSKEY_USR36:
-		return "USR36";
-	case CSR_PSKEY_USR37:
-		return "USR37";
-	case CSR_PSKEY_USR38:
-		return "USR38";
-	case CSR_PSKEY_USR39:
-		return "USR39";
-	case CSR_PSKEY_USR40:
-		return "USR40";
-	case CSR_PSKEY_USR41:
-		return "USR41";
-	case CSR_PSKEY_USR42:
-		return "USR42";
-	case CSR_PSKEY_USR43:
-		return "USR43";
-	case CSR_PSKEY_USR44:
-		return "USR44";
-	case CSR_PSKEY_USR45:
-		return "USR45";
-	case CSR_PSKEY_USR46:
-		return "USR46";
-	case CSR_PSKEY_USR47:
-		return "USR47";
-	case CSR_PSKEY_USR48:
-		return "USR48";
-	case CSR_PSKEY_USR49:
-		return "USR49";
-	case CSR_PSKEY_USB_VERSION:
-		return "USB_VERSION";
-	case CSR_PSKEY_USB_DEVICE_CLASS_CODES:
-		return "USB_DEVICE_CLASS_CODES";
-	case CSR_PSKEY_USB_VENDOR_ID:
-		return "USB_VENDOR_ID";
-	case CSR_PSKEY_USB_PRODUCT_ID:
-		return "USB_PRODUCT_ID";
-	case CSR_PSKEY_USB_MANUF_STRING:
-		return "USB_MANUF_STRING";
-	case CSR_PSKEY_USB_PRODUCT_STRING:
-		return "USB_PRODUCT_STRING";
-	case CSR_PSKEY_USB_SERIAL_NUMBER_STRING:
-		return "USB_SERIAL_NUMBER_STRING";
-	case CSR_PSKEY_USB_CONFIG_STRING:
-		return "USB_CONFIG_STRING";
-	case CSR_PSKEY_USB_ATTRIBUTES:
-		return "USB_ATTRIBUTES";
-	case CSR_PSKEY_USB_MAX_POWER:
-		return "USB_MAX_POWER";
-	case CSR_PSKEY_USB_BT_IF_CLASS_CODES:
-		return "USB_BT_IF_CLASS_CODES";
-	case CSR_PSKEY_USB_LANGID:
-		return "USB_LANGID";
-	case CSR_PSKEY_USB_DFU_CLASS_CODES:
-		return "USB_DFU_CLASS_CODES";
-	case CSR_PSKEY_USB_DFU_PRODUCT_ID:
-		return "USB_DFU_PRODUCT_ID";
-	case CSR_PSKEY_USB_PIO_DETACH:
-		return "USB_PIO_DETACH";
-	case CSR_PSKEY_USB_PIO_WAKEUP:
-		return "USB_PIO_WAKEUP";
-	case CSR_PSKEY_USB_PIO_PULLUP:
-		return "USB_PIO_PULLUP";
-	case CSR_PSKEY_USB_PIO_VBUS:
-		return "USB_PIO_VBUS";
-	case CSR_PSKEY_USB_PIO_WAKE_TIMEOUT:
-		return "USB_PIO_WAKE_TIMEOUT";
-	case CSR_PSKEY_USB_PIO_RESUME:
-		return "USB_PIO_RESUME";
-	case CSR_PSKEY_USB_BT_SCO_IF_CLASS_CODES:
-		return "USB_BT_SCO_IF_CLASS_CODES";
-	case CSR_PSKEY_USB_SUSPEND_PIO_LEVEL:
-		return "USB_SUSPEND_PIO_LEVEL";
-	case CSR_PSKEY_USB_SUSPEND_PIO_DIR:
-		return "USB_SUSPEND_PIO_DIR";
-	case CSR_PSKEY_USB_SUSPEND_PIO_MASK:
-		return "USB_SUSPEND_PIO_MASK";
-	case CSR_PSKEY_USB_ENDPOINT_0_MAX_PACKET_SIZE:
-		return "USB_ENDPOINT_0_MAX_PACKET_SIZE";
-	case CSR_PSKEY_USB_CONFIG:
-		return "USB_CONFIG";
-	case CSR_PSKEY_RADIOTEST_ATTEN_INIT:
-		return "RADIOTEST_ATTEN_INIT";
-	case CSR_PSKEY_RADIOTEST_FIRST_TRIM_TIME:
-		return "RADIOTEST_FIRST_TRIM_TIME";
-	case CSR_PSKEY_RADIOTEST_SUBSEQUENT_TRIM_TIME:
-		return "RADIOTEST_SUBSEQUENT_TRIM_TIME";
-	case CSR_PSKEY_RADIOTEST_LO_LVL_TRIM_ENABLE:
-		return "RADIOTEST_LO_LVL_TRIM_ENABLE";
-	case CSR_PSKEY_RADIOTEST_DISABLE_MODULATION:
-		return "RADIOTEST_DISABLE_MODULATION";
-	case CSR_PSKEY_RFCOMM_FCON_THRESHOLD:
-		return "RFCOMM_FCON_THRESHOLD";
-	case CSR_PSKEY_RFCOMM_FCOFF_THRESHOLD:
-		return "RFCOMM_FCOFF_THRESHOLD";
-	case CSR_PSKEY_IPV6_STATIC_ADDR:
-		return "IPV6_STATIC_ADDR";
-	case CSR_PSKEY_IPV4_STATIC_ADDR:
-		return "IPV4_STATIC_ADDR";
-	case CSR_PSKEY_IPV6_STATIC_PREFIX_LEN:
-		return "IPV6_STATIC_PREFIX_LEN";
-	case CSR_PSKEY_IPV6_STATIC_ROUTER_ADDR:
-		return "IPV6_STATIC_ROUTER_ADDR";
-	case CSR_PSKEY_IPV4_STATIC_SUBNET_MASK:
-		return "IPV4_STATIC_SUBNET_MASK";
-	case CSR_PSKEY_IPV4_STATIC_ROUTER_ADDR:
-		return "IPV4_STATIC_ROUTER_ADDR";
-	case CSR_PSKEY_MDNS_NAME:
-		return "MDNS_NAME";
-	case CSR_PSKEY_FIXED_PIN:
-		return "FIXED_PIN";
-	case CSR_PSKEY_MDNS_PORT:
-		return "MDNS_PORT";
-	case CSR_PSKEY_MDNS_TTL:
-		return "MDNS_TTL";
-	case CSR_PSKEY_MDNS_IPV4_ADDR:
-		return "MDNS_IPV4_ADDR";
-	case CSR_PSKEY_ARP_CACHE_TIMEOUT:
-		return "ARP_CACHE_TIMEOUT";
-	case CSR_PSKEY_HFP_POWER_TABLE:
-		return "HFP_POWER_TABLE";
-	case CSR_PSKEY_DRAIN_BORE_TIMER_COUNTERS:
-		return "DRAIN_BORE_TIMER_COUNTERS";
-	case CSR_PSKEY_DRAIN_BORE_COUNTERS:
-		return "DRAIN_BORE_COUNTERS";
-	case CSR_PSKEY_LOOP_FILTER_TRIM:
-		return "LOOP_FILTER_TRIM";
-	case CSR_PSKEY_DRAIN_BORE_CURRENT_PEAK:
-		return "DRAIN_BORE_CURRENT_PEAK";
-	case CSR_PSKEY_VM_E2_CACHE_LIMIT:
-		return "VM_E2_CACHE_LIMIT";
-	case CSR_PSKEY_FORCE_16MHZ_REF_PIO:
-		return "FORCE_16MHZ_REF_PIO";
-	case CSR_PSKEY_CDMA_LO_REF_LIMITS:
-		return "CDMA_LO_REF_LIMITS";
-	case CSR_PSKEY_CDMA_LO_ERROR_LIMITS:
-		return "CDMA_LO_ERROR_LIMITS";
-	case CSR_PSKEY_CLOCK_STARTUP_DELAY:
-		return "CLOCK_STARTUP_DELAY";
-	case CSR_PSKEY_DEEP_SLEEP_CORRECTION_FACTOR:
-		return "DEEP_SLEEP_CORRECTION_FACTOR";
-	case CSR_PSKEY_TEMPERATURE_CALIBRATION:
-		return "TEMPERATURE_CALIBRATION";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA:
-		return "TEMPERATURE_VS_DELTA_INTERNAL_PA";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL:
-		return "TEMPERATURE_VS_DELTA_TX_PRE_LVL";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB:
-		return "TEMPERATURE_VS_DELTA_TX_BB";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_ANA_FTRIM:
-		return "TEMPERATURE_VS_DELTA_ANA_FTRIM";
-	case CSR_PSKEY_TEST_DELTA_OFFSET:
-		return "TEST_DELTA_OFFSET";
-	case CSR_PSKEY_RX_DYNAMIC_LVL_OFFSET:
-		return "RX_DYNAMIC_LVL_OFFSET";
-	case CSR_PSKEY_TEST_FORCE_OFFSET:
-		return "TEST_FORCE_OFFSET";
-	case CSR_PSKEY_RF_TRAP_BAD_DIVISION_RATIOS:
-		return "RF_TRAP_BAD_DIVISION_RATIOS";
-	case CSR_PSKEY_RADIOTEST_CDMA_LO_REF_LIMITS:
-		return "RADIOTEST_CDMA_LO_REF_LIMITS";
-	case CSR_PSKEY_INITIAL_BOOTMODE:
-		return "INITIAL_BOOTMODE";
-	case CSR_PSKEY_ONCHIP_HCI_CLIENT:
-		return "ONCHIP_HCI_CLIENT";
-	case CSR_PSKEY_RX_ATTEN_BACKOFF:
-		return "RX_ATTEN_BACKOFF";
-	case CSR_PSKEY_RX_ATTEN_UPDATE_RATE:
-		return "RX_ATTEN_UPDATE_RATE";
-	case CSR_PSKEY_SYNTH_TXRX_THRESHOLDS:
-		return "SYNTH_TXRX_THRESHOLDS";
-	case CSR_PSKEY_MIN_WAIT_STATES:
-		return "MIN_WAIT_STATES";
-	case CSR_PSKEY_RSSI_CORRECTION:
-		return "RSSI_CORRECTION";
-	case CSR_PSKEY_SCHED_THROTTLE_TIMEOUT:
-		return "SCHED_THROTTLE_TIMEOUT";
-	case CSR_PSKEY_DEEP_SLEEP_USE_EXTERNAL_CLOCK:
-		return "DEEP_SLEEP_USE_EXTERNAL_CLOCK";
-	case CSR_PSKEY_TRIM_RADIO_FILTERS:
-		return "TRIM_RADIO_FILTERS";
-	case CSR_PSKEY_TRANSMIT_OFFSET:
-		return "TRANSMIT_OFFSET";
-	case CSR_PSKEY_USB_VM_CONTROL:
-		return "USB_VM_CONTROL";
-	case CSR_PSKEY_MR_ANA_RX_FTRIM:
-		return "MR_ANA_RX_FTRIM";
-	case CSR_PSKEY_I2C_CONFIG:
-		return "I2C_CONFIG";
-	case CSR_PSKEY_IQ_LVL_RX:
-		return "IQ_LVL_RX";
-	case CSR_PSKEY_MR_TX_FILTER_CONFIG:
-		return "MR_TX_FILTER_CONFIG";
-	case CSR_PSKEY_MR_TX_CONFIG2:
-		return "MR_TX_CONFIG2";
-	case CSR_PSKEY_USB_DONT_RESET_BOOTMODE_ON_HOST_RESET:
-		return "USB_DONT_RESET_BOOTMODE_ON_HOST_RESET";
-	case CSR_PSKEY_LC_USE_THROTTLING:
-		return "LC_USE_THROTTLING";
-	case CSR_PSKEY_CHARGER_TRIM:
-		return "CHARGER_TRIM";
-	case CSR_PSKEY_CLOCK_REQUEST_FEATURES:
-		return "CLOCK_REQUEST_FEATURES";
-	case CSR_PSKEY_TRANSMIT_OFFSET_CLASS1:
-		return "TRANSMIT_OFFSET_CLASS1";
-	case CSR_PSKEY_TX_AVOID_PA_CLASS1_PIO:
-		return "TX_AVOID_PA_CLASS1_PIO";
-	case CSR_PSKEY_MR_PIO_CONFIG:
-		return "MR_PIO_CONFIG";
-	case CSR_PSKEY_UART_CONFIG2:
-		return "UART_CONFIG2";
-	case CSR_PSKEY_CLASS1_IQ_LVL:
-		return "CLASS1_IQ_LVL";
-	case CSR_PSKEY_CLASS1_TX_CONFIG2:
-		return "CLASS1_TX_CONFIG2";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA_CLASS1:
-		return "TEMPERATURE_VS_DELTA_INTERNAL_PA_CLASS1";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_EXTERNAL_PA_CLASS1:
-		return "TEMPERATURE_VS_DELTA_EXTERNAL_PA_CLASS1";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL_MR:
-		return "TEMPERATURE_VS_DELTA_TX_PRE_LVL_MR";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_HEADER:
-		return "TEMPERATURE_VS_DELTA_TX_BB_MR_HEADER";
-	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_PAYLOAD:
-		return "TEMPERATURE_VS_DELTA_TX_BB_MR_PAYLOAD";
-	case CSR_PSKEY_RX_MR_EQ_TAPS:
-		return "RX_MR_EQ_TAPS";
-	case CSR_PSKEY_TX_PRE_LVL_CLASS1:
-		return "TX_PRE_LVL_CLASS1";
-	case CSR_PSKEY_ANALOGUE_ATTENUATOR:
-		return "ANALOGUE_ATTENUATOR";
-	case CSR_PSKEY_MR_RX_FILTER_TRIM:
-		return "MR_RX_FILTER_TRIM";
-	case CSR_PSKEY_MR_RX_FILTER_RESPONSE:
-		return "MR_RX_FILTER_RESPONSE";
-	case CSR_PSKEY_PIO_WAKEUP_STATE:
-		return "PIO_WAKEUP_STATE";
-	case CSR_PSKEY_MR_TX_IF_ATTEN_OFF_TEMP:
-		return "MR_TX_IF_ATTEN_OFF_TEMP";
-	case CSR_PSKEY_LO_DIV_LATCH_BYPASS:
-		return "LO_DIV_LATCH_BYPASS";
-	case CSR_PSKEY_LO_VCO_STANDBY:
-		return "LO_VCO_STANDBY";
-	case CSR_PSKEY_SLOW_CLOCK_FILTER_SHIFT:
-		return "SLOW_CLOCK_FILTER_SHIFT";
-	case CSR_PSKEY_SLOW_CLOCK_FILTER_DIVIDER:
-		return "SLOW_CLOCK_FILTER_DIVIDER";
-	case CSR_PSKEY_USB_ATTRIBUTES_POWER:
-		return "USB_ATTRIBUTES_POWER";
-	case CSR_PSKEY_USB_ATTRIBUTES_WAKEUP:
-		return "USB_ATTRIBUTES_WAKEUP";
-	case CSR_PSKEY_DFU_ATTRIBUTES_MANIFESTATION_TOLERANT:
-		return "DFU_ATTRIBUTES_MANIFESTATION_TOLERANT";
-	case CSR_PSKEY_DFU_ATTRIBUTES_CAN_UPLOAD:
-		return "DFU_ATTRIBUTES_CAN_UPLOAD";
-	case CSR_PSKEY_DFU_ATTRIBUTES_CAN_DOWNLOAD:
-		return "DFU_ATTRIBUTES_CAN_DOWNLOAD";
-	case CSR_PSKEY_UART_CONFIG_STOP_BITS:
-		return "UART_CONFIG_STOP_BITS";
-	case CSR_PSKEY_UART_CONFIG_PARITY_BIT:
-		return "UART_CONFIG_PARITY_BIT";
-	case CSR_PSKEY_UART_CONFIG_FLOW_CTRL_EN:
-		return "UART_CONFIG_FLOW_CTRL_EN";
-	case CSR_PSKEY_UART_CONFIG_RTS_AUTO_EN:
-		return "UART_CONFIG_RTS_AUTO_EN";
-	case CSR_PSKEY_UART_CONFIG_RTS:
-		return "UART_CONFIG_RTS";
-	case CSR_PSKEY_UART_CONFIG_TX_ZERO_EN:
-		return "UART_CONFIG_TX_ZERO_EN";
-	case CSR_PSKEY_UART_CONFIG_NON_BCSP_EN:
-		return "UART_CONFIG_NON_BCSP_EN";
-	case CSR_PSKEY_UART_CONFIG_RX_RATE_DELAY:
-		return "UART_CONFIG_RX_RATE_DELAY";
-	case CSR_PSKEY_UART_SEQ_TIMEOUT:
-		return "UART_SEQ_TIMEOUT";
-	case CSR_PSKEY_UART_SEQ_RETRIES:
-		return "UART_SEQ_RETRIES";
-	case CSR_PSKEY_UART_SEQ_WINSIZE:
-		return "UART_SEQ_WINSIZE";
-	case CSR_PSKEY_UART_USE_CRC_ON_TX:
-		return "UART_USE_CRC_ON_TX";
-	case CSR_PSKEY_UART_HOST_INITIAL_STATE:
-		return "UART_HOST_INITIAL_STATE";
-	case CSR_PSKEY_UART_HOST_ATTENTION_SPAN:
-		return "UART_HOST_ATTENTION_SPAN";
-	case CSR_PSKEY_UART_HOST_WAKEUP_TIME:
-		return "UART_HOST_WAKEUP_TIME";
-	case CSR_PSKEY_UART_HOST_WAKEUP_WAIT:
-		return "UART_HOST_WAKEUP_WAIT";
-	case CSR_PSKEY_BCSP_LM_MODE:
-		return "BCSP_LM_MODE";
-	case CSR_PSKEY_BCSP_LM_SYNC_RETRIES:
-		return "BCSP_LM_SYNC_RETRIES";
-	case CSR_PSKEY_BCSP_LM_TSHY:
-		return "BCSP_LM_TSHY";
-	case CSR_PSKEY_UART_DFU_CONFIG_STOP_BITS:
-		return "UART_DFU_CONFIG_STOP_BITS";
-	case CSR_PSKEY_UART_DFU_CONFIG_PARITY_BIT:
-		return "UART_DFU_CONFIG_PARITY_BIT";
-	case CSR_PSKEY_UART_DFU_CONFIG_FLOW_CTRL_EN:
-		return "UART_DFU_CONFIG_FLOW_CTRL_EN";
-	case CSR_PSKEY_UART_DFU_CONFIG_RTS_AUTO_EN:
-		return "UART_DFU_CONFIG_RTS_AUTO_EN";
-	case CSR_PSKEY_UART_DFU_CONFIG_RTS:
-		return "UART_DFU_CONFIG_RTS";
-	case CSR_PSKEY_UART_DFU_CONFIG_TX_ZERO_EN:
-		return "UART_DFU_CONFIG_TX_ZERO_EN";
-	case CSR_PSKEY_UART_DFU_CONFIG_NON_BCSP_EN:
-		return "UART_DFU_CONFIG_NON_BCSP_EN";
-	case CSR_PSKEY_UART_DFU_CONFIG_RX_RATE_DELAY:
-		return "UART_DFU_CONFIG_RX_RATE_DELAY";
-	case CSR_PSKEY_AMUX_AIO0:
-		return "AMUX_AIO0";
-	case CSR_PSKEY_AMUX_AIO1:
-		return "AMUX_AIO1";
-	case CSR_PSKEY_AMUX_AIO2:
-		return "AMUX_AIO2";
-	case CSR_PSKEY_AMUX_AIO3:
-		return "AMUX_AIO3";
-	case CSR_PSKEY_LOCAL_NAME_SIMPLIFIED:
-		return "LOCAL_NAME_SIMPLIFIED";
-	case CSR_PSKEY_EXTENDED_STUB:
-		return "EXTENDED_STUB";
-	default:
-		return "UNKNOWN";
-	}
-}
-
-int csr_write_varid_valueless(int dd, uint16_t seqnum, uint16_t varid)
-{
-	unsigned char cmd[] =3D { 0x02, 0x00, 0x09, 0x00,
-				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
-				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-
-	unsigned char cp[254], rp[254];
-	struct hci_request rq;
-
-	memset(&cp, 0, sizeof(cp));
-	cp[0] =3D 0xc2;
-	memcpy(cp + 1, cmd, sizeof(cmd));
-
-	switch (varid) {
-	case CSR_VARID_COLD_RESET:
-	case CSR_VARID_WARM_RESET:
-	case CSR_VARID_COLD_HALT:
-	case CSR_VARID_WARM_HALT:
-		return hci_send_cmd(dd, OGF_VENDOR_CMD, 0x00, sizeof(cmd) + 1, cp);
-	}
-
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    =3D OGF_VENDOR_CMD;
-	rq.ocf    =3D 0x00;
-	rq.event  =3D EVT_VENDOR;
-	rq.cparam =3D cp;
-	rq.clen   =3D sizeof(cmd) + 1;
-	rq.rparam =3D rp;
-	rq.rlen   =3D sizeof(rp);
-
-	if (hci_send_req(dd, &rq, 2000) < 0)
-		return -1;
-
-	if (rp[0] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[9] + (rp[10] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	return 0;
-}
-
-int csr_write_varid_complex(int dd, uint16_t seqnum, uint16_t varid, uint8=
_t *value, uint16_t length)
-{
-	unsigned char cmd[] =3D { 0x02, 0x00, ((length / 2) + 5) & 0xff, ((length=
 / 2) + 5) >> 8,
-				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
-				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-
-	unsigned char cp[254], rp[254];
-	struct hci_request rq;
-
-	memset(&cp, 0, sizeof(cp));
-	cp[0] =3D 0xc2;
-	memcpy(cp + 1, cmd, sizeof(cmd));
-	memcpy(cp + 11, value, length);
-
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    =3D OGF_VENDOR_CMD;
-	rq.ocf    =3D 0x00;
-	rq.event  =3D EVT_VENDOR;
-	rq.cparam =3D cp;
-	rq.clen   =3D sizeof(cmd) + length + 1;
-	rq.rparam =3D rp;
-	rq.rlen   =3D sizeof(rp);
-
-	if (hci_send_req(dd, &rq, 2000) < 0)
-		return -1;
-
-	if (rp[0] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[9] + (rp[10] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	return 0;
-}
-
-int csr_read_varid_complex(int dd, uint16_t seqnum, uint16_t varid, uint8_=
t *value, uint16_t length)
-{
-	unsigned char cmd[] =3D { 0x00, 0x00, ((length / 2) + 5) & 0xff, ((length=
 / 2) + 5) >> 8,
-				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
-				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-
-	unsigned char cp[254], rp[254];
-	struct hci_request rq;
-
-	memset(&cp, 0, sizeof(cp));
-	cp[0] =3D 0xc2;
-	memcpy(cp + 1, cmd, sizeof(cmd));
-	memcpy(cp + 11, value, length);
-
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    =3D OGF_VENDOR_CMD;
-	rq.ocf    =3D 0x00;
-	rq.event  =3D EVT_VENDOR;
-	rq.cparam =3D cp;
-	rq.clen   =3D sizeof(cmd) + length + 1;
-	rq.rparam =3D rp;
-	rq.rlen   =3D sizeof(rp);
-
-	if (hci_send_req(dd, &rq, 2000) < 0)
-		return -1;
-
-	if (rp[0] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[9] + (rp[10] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	memcpy(value, rp + 11, length);
-
-	return 0;
-}
-
-int csr_read_varid_uint16(int dd, uint16_t seqnum, uint16_t varid, uint16_=
t *value)
-{
-	unsigned char cmd[] =3D { 0x00, 0x00, 0x09, 0x00,
-				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
-				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-
-	unsigned char cp[254], rp[254];
-	struct hci_request rq;
-
-	memset(&cp, 0, sizeof(cp));
-	cp[0] =3D 0xc2;
-	memcpy(cp + 1, cmd, sizeof(cmd));
-
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    =3D OGF_VENDOR_CMD;
-	rq.ocf    =3D 0x00;
-	rq.event  =3D EVT_VENDOR;
-	rq.cparam =3D cp;
-	rq.clen   =3D sizeof(cmd) + 1;
-	rq.rparam =3D rp;
-	rq.rlen   =3D sizeof(rp);
-
-	if (hci_send_req(dd, &rq, 2000) < 0)
-		return -1;
-
-	if (rp[0] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[9] + (rp[10] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	*value =3D rp[11] + (rp[12] << 8);
-
-	return 0;
-}
-
-int csr_read_varid_uint32(int dd, uint16_t seqnum, uint16_t varid, uint32_=
t *value)
-{
-	unsigned char cmd[] =3D { 0x00, 0x00, 0x09, 0x00,
-				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
-				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-
-	unsigned char cp[254], rp[254];
-	struct hci_request rq;
-
-	memset(&cp, 0, sizeof(cp));
-	cp[0] =3D 0xc2;
-	memcpy(cp + 1, cmd, sizeof(cmd));
-
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    =3D OGF_VENDOR_CMD;
-	rq.ocf    =3D 0x00;
-	rq.event  =3D EVT_VENDOR;
-	rq.cparam =3D cp;
-	rq.clen   =3D sizeof(cmd) + 1;
-	rq.rparam =3D rp;
-	rq.rlen   =3D sizeof(rp);
-
-	if (hci_send_req(dd, &rq, 2000) < 0)
-		return -1;
-
-	if (rp[0] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[9] + (rp[10] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	*value =3D ((rp[11] + (rp[12] << 8)) << 16) + (rp[13] + (rp[14] << 8));
-
-	return 0;
-}
-
-int csr_read_pskey_complex(int dd, uint16_t seqnum, uint16_t pskey, uint16=
_t stores, uint8_t *value, uint16_t length)
-{
-	unsigned char cmd[] =3D { 0x00, 0x00, ((length / 2) + 8) & 0xff, ((length=
 / 2) + 8) >> 8,
-				seqnum & 0xff, seqnum >> 8, 0x03, 0x70, 0x00, 0x00,
-				pskey & 0xff, pskey >> 8,
-				(length / 2) & 0xff, (length / 2) >> 8,
-				stores & 0xff, stores >> 8, 0x00, 0x00 };
-
-	unsigned char cp[254], rp[254];
-	struct hci_request rq;
-
-	memset(&cp, 0, sizeof(cp));
-	cp[0] =3D 0xc2;
-	memcpy(cp + 1, cmd, sizeof(cmd));
-
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    =3D OGF_VENDOR_CMD;
-	rq.ocf    =3D 0x00;
-	rq.event  =3D EVT_VENDOR;
-	rq.cparam =3D cp;
-	rq.clen   =3D sizeof(cmd) + length - 1;
-	rq.rparam =3D rp;
-	rq.rlen   =3D sizeof(rp);
-
-	if (hci_send_req(dd, &rq, 2000) < 0)
-		return -1;
-
-	if (rp[0] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[9] + (rp[10] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	memcpy(value, rp + 17, length);
-
-	return 0;
-}
-
-int csr_write_pskey_complex(int dd, uint16_t seqnum, uint16_t pskey, uint1=
6_t stores, uint8_t *value, uint16_t length)
-{
-	unsigned char cmd[] =3D { 0x02, 0x00, ((length / 2) + 8) & 0xff, ((length=
 / 2) + 8) >> 8,
-				seqnum & 0xff, seqnum >> 8, 0x03, 0x70, 0x00, 0x00,
-				pskey & 0xff, pskey >> 8,
-				(length / 2) & 0xff, (length / 2) >> 8,
-				stores & 0xff, stores >> 8, 0x00, 0x00 };
-
-	unsigned char cp[254], rp[254];
-	struct hci_request rq;
-
-	memset(&cp, 0, sizeof(cp));
-	cp[0] =3D 0xc2;
-	memcpy(cp + 1, cmd, sizeof(cmd));
-
-	memcpy(cp + 17, value, length);
-
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    =3D OGF_VENDOR_CMD;
-	rq.ocf    =3D 0x00;
-	rq.event  =3D EVT_VENDOR;
-	rq.cparam =3D cp;
-	rq.clen   =3D sizeof(cmd) + length - 1;
-	rq.rparam =3D rp;
-	rq.rlen   =3D sizeof(rp);
-
-	if (hci_send_req(dd, &rq, 2000) < 0)
-		return -1;
-
-	if (rp[0] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[9] + (rp[10] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	return 0;
-}
-
-int csr_read_pskey_uint16(int dd, uint16_t seqnum, uint16_t pskey, uint16_=
t stores, uint16_t *value)
-{
-	uint8_t array[2] =3D { 0x00, 0x00 };
-	int err;
-
-	err =3D csr_read_pskey_complex(dd, seqnum, pskey, stores, array, 2);
-
-	*value =3D array[0] + (array[1] << 8);
-
-	return err;
-}
-
-int csr_write_pskey_uint16(int dd, uint16_t seqnum, uint16_t pskey, uint16=
_t stores, uint16_t value)
-{
-	uint8_t array[2] =3D { value & 0xff, value >> 8 };
-
-	return csr_write_pskey_complex(dd, seqnum, pskey, stores, array, 2);
-}
-
-int csr_read_pskey_uint32(int dd, uint16_t seqnum, uint16_t pskey, uint16_=
t stores, uint32_t *value)
-{
-	uint8_t array[4] =3D { 0x00, 0x00, 0x00, 0x00 };
-	int err;
-
-	err =3D csr_read_pskey_complex(dd, seqnum, pskey, stores, array, 4);
-
-	*value =3D ((array[0] + (array[1] << 8)) << 16) +
-						(array[2] + (array[3] << 8));
-
-	return err;
-}
-
-int csr_write_pskey_uint32(int dd, uint16_t seqnum, uint16_t pskey, uint16=
_t stores, uint32_t value)
-{
-	uint8_t array[4] =3D { (value & 0xff0000) >> 16, value >> 24,
-					value & 0xff, (value & 0xff00) >> 8 };
-
-	return csr_write_pskey_complex(dd, seqnum, pskey, stores, array, 4);
-}
-
-int psr_put(uint16_t pskey, uint8_t *value, uint16_t size)
-{
-	struct psr_data *item;
-
-	item =3D malloc(sizeof(*item));
-	if (!item)
-		return -ENOMEM;
-
-	item->pskey =3D pskey;
-
-	if (size > 0) {
-		item->value =3D malloc(size);
-		if (!item->value) {
-			free(item);
-			return -ENOMEM;
-		}
-
-		memcpy(item->value, value, size);
-		item->size =3D size;
-	} else {
-		item->value =3D NULL;
-		item->size =3D 0;
-	}
-
-	item->next =3D NULL;
-
-	if (!head)
-		head =3D item;
-	else
-		tail->next =3D item;
-
-	tail =3D item;
-
-	return 0;
-}
-
-int psr_get(uint16_t *pskey, uint8_t *value, uint16_t *size)
-{
-	struct psr_data *item =3D head;
-
-	if (!head)
-		return -ENOENT;
-
-	*pskey =3D item->pskey;
-
-	if (item->value) {
-		if (value && item->size > 0)
-			memcpy(value, item->value, item->size);
-		free(item->value);
-		*size =3D item->size;
-	} else
-		*size =3D 0;
-
-	if (head =3D=3D tail)
-		tail =3D NULL;
-
-	head =3D head->next;
-	free(item);
-
-	return 0;
-}
-
-static int parse_line(char *str)
-{
-	uint8_t array[256];
-	uint16_t value, pskey, length =3D 0;
-	char *off, *end;
-
-	pskey =3D strtol(str + 1, NULL, 16);
-	off =3D strstr(str, "=3D");
-	if (!off)
-		return -EIO;
-
-	off++;
-
-	while (length <=3D sizeof(array) - 2) {
-		value =3D strtol(off, &end, 16);
-		if (value =3D=3D 0 && off =3D=3D end)
-			break;
-
-		array[length++] =3D value & 0xff;
-		array[length++] =3D value >> 8;
-
-		if (*end =3D=3D '\0')
-			break;
-
-		off =3D end + 1;
-	}
-
-	return psr_put(pskey, array, length);
-}
-
-int psr_read(const char *filename)
-{
-	struct stat st;
-	char *str, *map, *off, *end;
-	int fd, err =3D 0;
-
-	fd =3D open(filename, O_RDONLY);
-	if (fd < 0)
-		return fd;
-
-	if (fstat(fd, &st) < 0) {
-		err =3D -errno;
-		goto close;
-	}
-
-	map =3D mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
-	if (!map || map =3D=3D MAP_FAILED) {
-		err =3D -errno;
-		goto close;
-	}
-
-	off =3D map;
-
-	while (1) {
-		if (*off =3D=3D '\r' || *off =3D=3D '\n') {
-			off++;
-			continue;
-		}
-
-		end =3D strpbrk(off, "\r\n");
-		if (!end)
-			break;
-
-		str =3D malloc(end - off + 1);
-		if (!str)
-			break;
-
-		memset(str, 0, end - off + 1);
-		strncpy(str, off, end - off);
-		if (*str =3D=3D '&')
-			parse_line(str);
-
-		free(str);
-		off =3D end + 1;
-	}
-
-	munmap(map, st.st_size);
-
-close:
-	close(fd);
-
-	return err;
-}
-
-int psr_print(void)
-{
-	uint8_t array[256];
-	uint16_t pskey, length;
-	char *str, val[7];
-	int i;
-
-	while (1) {
-		if (psr_get(&pskey, array, &length) < 0)
-			break;
-
-		str =3D csr_pskeytoval(pskey);
-		if (!strcasecmp(str, "UNKNOWN")) {
-			sprintf(val, "0x%04x", pskey);
-			str =3D NULL;
-		}
-
-		printf("// %s%s\n&%04x =3D", str ? "PSKEY_" : "",
-						str ? str : val, pskey);
-		for (i =3D 0; i < length / 2; i++)
-			printf(" %02x%02x", array[i * 2 + 1], array[i * 2]);
-		printf("\n");
-	}
-
-	return 0;
-}
diff --git a/tools/csr.h b/tools/csr.h
deleted file mode 100644
index cc245a550..000000000
--- a/tools/csr.h
+++ /dev/null
@@ -1,555 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2003-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 =
 USA
- *
- */
-
-#include <stdint.h>
-#include <termios.h>
-
-#define CSR_VARID_PS_CLR_ALL			0x000b	/* valueless */
-#define CSR_VARID_PS_FACTORY_SET		0x000c	/* valueless */
-#define CSR_VARID_PS_CLR_ALL_STORES		0x082d	/* uint16 */
-#define CSR_VARID_BC01_STATUS			0x2801	/* uint16 */
-#define CSR_VARID_BUILDID			0x2819	/* uint16 */
-#define CSR_VARID_CHIPVER			0x281a	/* uint16 */
-#define CSR_VARID_CHIPREV			0x281b	/* uint16 */
-#define CSR_VARID_INTERFACE_VERSION		0x2825	/* uint16 */
-#define CSR_VARID_RAND				0x282a	/* uint16 */
-#define CSR_VARID_MAX_CRYPT_KEY_LENGTH		0x282c	/* uint16 */
-#define CSR_VARID_CHIPANAREV			0x2836	/* uint16 */
-#define CSR_VARID_BUILDID_LOADER		0x2838	/* uint16 */
-#define CSR_VARID_BT_CLOCK			0x2c00	/* uint32 */
-#define CSR_VARID_PS_NEXT			0x3005	/* complex */
-#define CSR_VARID_PS_SIZE			0x3006	/* complex */
-#define CSR_VARID_ADC_RES			0x3007	/* complex */
-#define CSR_VARID_CRYPT_KEY_LENGTH		0x3008	/* complex */
-#define CSR_VARID_PICONET_INSTANCE		0x3009	/* complex */
-#define CSR_VARID_GET_CLR_EVT			0x300a	/* complex */
-#define CSR_VARID_GET_NEXT_BUILDDEF		0x300b	/* complex */
-#define CSR_VARID_PS_MEMORY_TYPE		0x3012	/* complex */
-#define CSR_VARID_READ_BUILD_NAME		0x301c	/* complex */
-#define CSR_VARID_COLD_RESET			0x4001	/* valueless */
-#define CSR_VARID_WARM_RESET			0x4002	/* valueless */
-#define CSR_VARID_COLD_HALT			0x4003	/* valueless */
-#define CSR_VARID_WARM_HALT			0x4004	/* valueless */
-#define CSR_VARID_INIT_BT_STACK			0x4005	/* valueless */
-#define CSR_VARID_ACTIVATE_BT_STACK		0x4006	/* valueless */
-#define CSR_VARID_ENABLE_TX			0x4007	/* valueless */
-#define CSR_VARID_DISABLE_TX			0x4008	/* valueless */
-#define CSR_VARID_RECAL				0x4009	/* valueless */
-#define CSR_VARID_PS_FACTORY_RESTORE		0x400d	/* valueless */
-#define CSR_VARID_PS_FACTORY_RESTORE_ALL	0x400e	/* valueless */
-#define CSR_VARID_PS_DEFRAG_RESET		0x400f	/* valueless */
-#define CSR_VARID_KILL_VM_APPLICATION		0x4010	/* valueless */
-#define CSR_VARID_HOPPING_ON			0x4011	/* valueless */
-#define CSR_VARID_CANCEL_PAGE			0x4012	/* valueless */
-#define CSR_VARID_PS_CLR			0x4818	/* uint16 */
-#define CSR_VARID_MAP_SCO_PCM			0x481c	/* uint16 */
-#define CSR_VARID_ADC				0x4829	/* uint16 */
-#define CSR_VARID_SINGLE_CHAN			0x482e	/* uint16 */
-#define CSR_VARID_RADIOTEST			0x5004	/* complex */
-#define CSR_VARID_PS_CLR_STORES			0x500c	/* complex */
-#define CSR_VARID_NO_VARIABLE			0x6000	/* valueless */
-#define CSR_VARID_CONFIG_UART			0x6802	/* uint16 */
-#define CSR_VARID_PANIC_ARG			0x6805	/* uint16 */
-#define CSR_VARID_FAULT_ARG			0x6806	/* uint16 */
-#define CSR_VARID_MAX_TX_POWER			0x6827	/* int8 */
-#define CSR_VARID_DEFAULT_TX_POWER		0x682b	/* int8 */
-#define CSR_VARID_PS				0x7003	/* complex */
-
-#define CSR_PSKEY_BDADDR					0x0001	/* bdaddr / uint16[] =3D { 0x00A5A5, 0=
x5b, 0x0002 } */
-#define CSR_PSKEY_COUNTRYCODE					0x0002	/* uint16 */
-#define CSR_PSKEY_CLASSOFDEVICE					0x0003	/* bdcod */
-#define CSR_PSKEY_DEVICE_DRIFT					0x0004	/* uint16 */
-#define CSR_PSKEY_DEVICE_JITTER					0x0005	/* uint16 */
-#define CSR_PSKEY_MAX_ACLS					0x000d	/* uint16 */
-#define CSR_PSKEY_MAX_SCOS					0x000e	/* uint16 */
-#define CSR_PSKEY_MAX_REMOTE_MASTERS				0x000f	/* uint16 */
-#define CSR_PSKEY_ENABLE_MASTERY_WITH_SLAVERY			0x0010	/* bool */
-#define CSR_PSKEY_H_HC_FC_MAX_ACL_PKT_LEN			0x0011	/* uint16 */
-#define CSR_PSKEY_H_HC_FC_MAX_SCO_PKT_LEN			0x0012	/* uint8 */
-#define CSR_PSKEY_H_HC_FC_MAX_ACL_PKTS				0x0013	/* uint16 */
-#define CSR_PSKEY_H_HC_FC_MAX_SCO_PKTS				0x0014	/* uint16 */
-#define CSR_PSKEY_LC_FC_BUFFER_LOW_WATER_MARK			0x0015	/* lc_fc_lwm */
-#define CSR_PSKEY_LC_MAX_TX_POWER				0x0017	/* int16 */
-#define CSR_PSKEY_TX_GAIN_RAMP					0x001d	/* uint16 */
-#define CSR_PSKEY_LC_POWER_TABLE				0x001e	/* power_setting[] */
-#define CSR_PSKEY_LC_PEER_POWER_PERIOD				0x001f	/* TIME */
-#define CSR_PSKEY_LC_FC_POOLS_LOW_WATER_MARK			0x0020	/* lc_fc_lwm */
-#define CSR_PSKEY_LC_DEFAULT_TX_POWER				0x0021	/* int16 */
-#define CSR_PSKEY_LC_RSSI_GOLDEN_RANGE				0x0022	/* uint8 */
-#define CSR_PSKEY_LC_COMBO_DISABLE_PIO_MASK			0x0028	/* uint16[] */
-#define CSR_PSKEY_LC_COMBO_PRIORITY_PIO_MASK			0x0029	/* uint16[] */
-#define CSR_PSKEY_LC_COMBO_DOT11_CHANNEL_PIO_BASE		0x002a	/* uint16 */
-#define CSR_PSKEY_LC_COMBO_DOT11_BLOCK_CHANNELS			0x002b	/* uint16 */
-#define CSR_PSKEY_LC_MAX_TX_POWER_NO_RSSI			0x002d	/* int8 */
-#define CSR_PSKEY_LC_CONNECTION_RX_WINDOW			0x002e	/* uint16 */
-#define CSR_PSKEY_LC_COMBO_DOT11_TX_PROTECTION_MODE		0x0030	/* uint16 */
-#define CSR_PSKEY_LC_ENHANCED_POWER_TABLE			0x0031	/* enhanced_power_setti=
ng[] */
-#define CSR_PSKEY_LC_WIDEBAND_RSSI_CONFIG			0x0032	/* wideband_rssi_config=
 */
-#define CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_LEAD			0x0033	/* uint16 */
-#define CSR_PSKEY_BT_CLOCK_INIT					0x0034	/* uint32 */
-#define CSR_PSKEY_TX_MR_MOD_DELAY				0x0038	/* uint8 */
-#define CSR_PSKEY_RX_MR_SYNC_TIMING				0x0039	/* uint16 */
-#define CSR_PSKEY_RX_MR_SYNC_CONFIG				0x003a	/* uint16 */
-#define CSR_PSKEY_LC_LOST_SYNC_SLOTS				0x003b	/* uint16 */
-#define CSR_PSKEY_RX_MR_SAMP_CONFIG				0x003c	/* uint16 */
-#define CSR_PSKEY_AGC_HYST_LEVELS				0x003d	/* agc_hyst_config */
-#define CSR_PSKEY_RX_LEVEL_LOW_SIGNAL				0x003e	/* uint16 */
-#define CSR_PSKEY_AGC_IQ_LVL_VALUES				0x003f	/* IQ_LVL_VAL[] */
-#define CSR_PSKEY_MR_FTRIM_OFFSET_12DB				0x0040	/* uint16 */
-#define CSR_PSKEY_MR_FTRIM_OFFSET_6DB				0x0041	/* uint16 */
-#define CSR_PSKEY_NO_CAL_ON_BOOT				0x0042	/* bool */
-#define CSR_PSKEY_RSSI_HI_TARGET				0x0043	/* uint8 */
-#define CSR_PSKEY_PREFERRED_MIN_ATTENUATION			0x0044	/* uint8 */
-#define CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_OVERRIDE		0x0045	/* bool */
-#define CSR_PSKEY_LC_MULTISLOT_HOLDOFF				0x0047	/* TIME */
-#define CSR_PSKEY_FREE_KEY_PIGEON_HOLE				0x00c9	/* uint16 */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR0				0x00ca	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR1				0x00cb	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR2				0x00cc	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR3				0x00cd	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR4				0x00ce	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR5				0x00cf	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR6				0x00d0	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR7				0x00d1	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR8				0x00d2	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR9				0x00d3	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR10				0x00d4	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR11				0x00d5	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR12				0x00d6	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR13				0x00d7	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR14				0x00d8	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_LINK_KEY_BD_ADDR15				0x00d9	/* LM_LINK_KEY_BD_ADDR_T */
-#define CSR_PSKEY_ENC_KEY_LMIN					0x00da	/* uint16 */
-#define CSR_PSKEY_ENC_KEY_LMAX					0x00db	/* uint16 */
-#define CSR_PSKEY_LOCAL_SUPPORTED_FEATURES			0x00ef	/* uint16[] =3D { 0xff=
ff, 0xfe8f, 0xf99b, 0x8000 }*/
-#define CSR_PSKEY_LM_USE_UNIT_KEY				0x00f0	/* bool */
-#define CSR_PSKEY_HCI_NOP_DISABLE				0x00f2	/* bool */
-#define CSR_PSKEY_LM_MAX_EVENT_FILTERS				0x00f4	/* uint8 */
-#define CSR_PSKEY_LM_USE_ENC_MODE_BROADCAST			0x00f5	/* bool */
-#define CSR_PSKEY_LM_TEST_SEND_ACCEPTED_TWICE			0x00f6	/* bool */
-#define CSR_PSKEY_LM_MAX_PAGE_HOLD_TIME				0x00f7	/* uint16 */
-#define CSR_PSKEY_AFH_ADAPTATION_RESPONSE_TIME			0x00f8	/* uint16 */
-#define CSR_PSKEY_AFH_OPTIONS					0x00f9	/* uint16 */
-#define CSR_PSKEY_AFH_RSSI_RUN_PERIOD				0x00fa	/* uint16 */
-#define CSR_PSKEY_AFH_REENABLE_CHANNEL_TIME			0x00fb	/* uint16 */
-#define CSR_PSKEY_NO_DROP_ON_ACR_MS_FAIL			0x00fc	/* bool */
-#define CSR_PSKEY_MAX_PRIVATE_KEYS				0x00fd	/* uint8 */
-#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR0			0x00fe	/* LM_LINK_KEY_BD_ADD=
R_T */
-#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR1			0x00ff	/* LM_LINK_KEY_BD_ADD=
R_T */
-#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR2			0x0100	/* LM_LINK_KEY_BD_ADD=
R_T */
-#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR3			0x0101	/* LM_LINK_KEY_BD_ADD=
R_T */
-#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR4			0x0102	/* LM_LINK_KEY_BD_ADD=
R_T */
-#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR5			0x0103	/* LM_LINK_KEY_BD_ADD=
R_T */
-#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR6			0x0104	/* LM_LINK_KEY_BD_ADD=
R_T */
-#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR7			0x0105	/* LM_LINK_KEY_BD_ADD=
R_T */
-#define CSR_PSKEY_LOCAL_SUPPORTED_COMMANDS			0x0106	/* uint16[] =3D { 0xff=
ff, 0x03ff, 0xfffe, 0xffff, 0xffff, 0xffff, 0x0ff3, 0xfff8, 0x003f } */
-#define CSR_PSKEY_LM_MAX_ABSENCE_INDEX				0x0107	/* uint8 */
-#define CSR_PSKEY_DEVICE_NAME					0x0108	/* uint16[] */
-#define CSR_PSKEY_AFH_RSSI_THRESHOLD				0x0109	/* uint16 */
-#define CSR_PSKEY_LM_CASUAL_SCAN_INTERVAL			0x010a	/* uint16 */
-#define CSR_PSKEY_AFH_MIN_MAP_CHANGE				0x010b	/* uint16[] */
-#define CSR_PSKEY_AFH_RSSI_LP_RUN_PERIOD			0x010c	/* uint16 */
-#define CSR_PSKEY_HCI_LMP_LOCAL_VERSION				0x010d	/* uint16 */
-#define CSR_PSKEY_LMP_REMOTE_VERSION				0x010e	/* uint8 */
-#define CSR_PSKEY_HOLD_ERROR_MESSAGE_NUMBER			0x0113	/* uint16 */
-#define CSR_PSKEY_DFU_ATTRIBUTES				0x0136	/* uint8 */
-#define CSR_PSKEY_DFU_DETACH_TO					0x0137	/* uint16 */
-#define CSR_PSKEY_DFU_TRANSFER_SIZE				0x0138	/* uint16 */
-#define CSR_PSKEY_DFU_ENABLE					0x0139	/* bool */
-#define CSR_PSKEY_DFU_LIN_REG_ENABLE				0x013a	/* bool */
-#define CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_MSB			0x015e	/* uint16[] */
-#define CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_LSB			0x015f	/* uint16[] */
-#define CSR_PSKEY_DFUENC_VMAPP_PK_M_DASH			0x0160	/* uint16 */
-#define CSR_PSKEY_DFUENC_VMAPP_PK_R2N_MSB			0x0161	/* uint16[] */
-#define CSR_PSKEY_DFUENC_VMAPP_PK_R2N_LSB			0x0162	/* uint16[] */
-#define CSR_PSKEY_BCSP_LM_PS_BLOCK				0x0192	/* BCSP_LM_PS_BLOCK */
-#define CSR_PSKEY_HOSTIO_FC_PS_BLOCK				0x0193	/* HOSTIO_FC_PS_BLOCK */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO0				0x0194	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO1				0x0195	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO2				0x0196	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO3				0x0197	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO4				0x0198	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO5				0x0199	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO6				0x019a	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO7				0x019b	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO8				0x019c	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO9				0x019d	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO10			0x019e	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO11			0x019f	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO12			0x01a0	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO13			0x01a1	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO14			0x01a2	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO15			0x01a3	/* PROTOCOL_INFO */
-#define CSR_PSKEY_HOSTIO_UART_RESET_TIMEOUT			0x01a4	/* TIME */
-#define CSR_PSKEY_HOSTIO_USE_HCI_EXTN				0x01a5	/* bool */
-#define CSR_PSKEY_HOSTIO_USE_HCI_EXTN_CCFC			0x01a6	/* bool */
-#define CSR_PSKEY_HOSTIO_HCI_EXTN_PAYLOAD_SIZE			0x01a7	/* uint16 */
-#define CSR_PSKEY_BCSP_LM_CNF_CNT_LIMIT				0x01aa	/* uint16 */
-#define CSR_PSKEY_HOSTIO_MAP_SCO_PCM				0x01ab	/* bool */
-#define CSR_PSKEY_HOSTIO_AWKWARD_PCM_SYNC			0x01ac	/* bool */
-#define CSR_PSKEY_HOSTIO_BREAK_POLL_PERIOD			0x01ad	/* TIME */
-#define CSR_PSKEY_HOSTIO_MIN_UART_HCI_SCO_SIZE			0x01ae	/* uint16 */
-#define CSR_PSKEY_HOSTIO_MAP_SCO_CODEC				0x01b0	/* bool */
-#define CSR_PSKEY_PCM_CVSD_TX_HI_FREQ_BOOST			0x01b1	/* uint16 */
-#define CSR_PSKEY_PCM_CVSD_RX_HI_FREQ_BOOST			0x01b2	/* uint16 */
-#define CSR_PSKEY_PCM_CONFIG32					0x01b3	/* uint32 */
-#define CSR_PSKEY_USE_OLD_BCSP_LE				0x01b4	/* uint16 */
-#define CSR_PSKEY_PCM_CVSD_USE_NEW_FILTER			0x01b5	/* bool */
-#define CSR_PSKEY_PCM_FORMAT					0x01b6	/* uint16 */
-#define CSR_PSKEY_CODEC_OUT_GAIN				0x01b7	/* uint16 */
-#define CSR_PSKEY_CODEC_IN_GAIN					0x01b8	/* uint16 */
-#define CSR_PSKEY_CODEC_PIO					0x01b9	/* uint16 */
-#define CSR_PSKEY_PCM_LOW_JITTER_CONFIG				0x01ba	/* uint32 */
-#define CSR_PSKEY_HOSTIO_SCO_PCM_THRESHOLDS			0x01bb	/* uint16[] */
-#define CSR_PSKEY_HOSTIO_SCO_HCI_THRESHOLDS			0x01bc	/* uint16[] */
-#define CSR_PSKEY_HOSTIO_MAP_SCO_PCM_SLOT			0x01bd	/* uint16 */
-#define CSR_PSKEY_UART_BAUDRATE					0x01be	/* uint16 */
-#define CSR_PSKEY_UART_CONFIG_BCSP				0x01bf	/* uint16 */
-#define CSR_PSKEY_UART_CONFIG_H4				0x01c0	/* uint16 */
-#define CSR_PSKEY_UART_CONFIG_H5				0x01c1	/* uint16 */
-#define CSR_PSKEY_UART_CONFIG_USR				0x01c2	/* uint16 */
-#define CSR_PSKEY_UART_TX_CRCS					0x01c3	/* bool */
-#define CSR_PSKEY_UART_ACK_TIMEOUT				0x01c4	/* uint16 */
-#define CSR_PSKEY_UART_TX_MAX_ATTEMPTS				0x01c5	/* uint16 */
-#define CSR_PSKEY_UART_TX_WINDOW_SIZE				0x01c6	/* uint16 */
-#define CSR_PSKEY_UART_HOST_WAKE				0x01c7	/* uint16[] */
-#define CSR_PSKEY_HOSTIO_THROTTLE_TIMEOUT			0x01c8	/* TIME */
-#define CSR_PSKEY_PCM_ALWAYS_ENABLE				0x01c9	/* bool */
-#define CSR_PSKEY_UART_HOST_WAKE_SIGNAL				0x01ca	/* uint16 */
-#define CSR_PSKEY_UART_CONFIG_H4DS				0x01cb	/* uint16 */
-#define CSR_PSKEY_H4DS_WAKE_DURATION				0x01cc	/* uint16 */
-#define CSR_PSKEY_H4DS_MAXWU					0x01cd	/* uint16 */
-#define CSR_PSKEY_H4DS_LE_TIMER_PERIOD				0x01cf	/* uint16 */
-#define CSR_PSKEY_H4DS_TWU_TIMER_PERIOD				0x01d0	/* uint16 */
-#define CSR_PSKEY_H4DS_UART_IDLE_TIMER_PERIOD			0x01d1	/* uint16 */
-#define CSR_PSKEY_ANA_FTRIM					0x01f6	/* uint16 */
-#define CSR_PSKEY_WD_TIMEOUT					0x01f7	/* TIME */
-#define CSR_PSKEY_WD_PERIOD					0x01f8	/* TIME */
-#define CSR_PSKEY_HOST_INTERFACE				0x01f9	/* phys_bus */
-#define CSR_PSKEY_HQ_HOST_TIMEOUT				0x01fb	/* TIME */
-#define CSR_PSKEY_HQ_ACTIVE					0x01fc	/* bool */
-#define CSR_PSKEY_BCCMD_SECURITY_ACTIVE				0x01fd	/* bool */
-#define CSR_PSKEY_ANA_FREQ					0x01fe	/* uint16 */
-#define CSR_PSKEY_PIO_PROTECT_MASK				0x0202	/* uint16 */
-#define CSR_PSKEY_PMALLOC_SIZES					0x0203	/* uint16[] */
-#define CSR_PSKEY_UART_BAUD_RATE				0x0204	/* uint16 */
-#define CSR_PSKEY_UART_CONFIG					0x0205	/* uint16 */
-#define CSR_PSKEY_STUB						0x0207	/* uint16 */
-#define CSR_PSKEY_TXRX_PIO_CONTROL				0x0209	/* uint16 */
-#define CSR_PSKEY_ANA_RX_LEVEL					0x020b	/* uint16 */
-#define CSR_PSKEY_ANA_RX_FTRIM					0x020c	/* uint16 */
-#define CSR_PSKEY_PSBC_DATA_VERSION				0x020d	/* uint16 */
-#define CSR_PSKEY_PCM0_ATTENUATION				0x020f	/* uint16 */
-#define CSR_PSKEY_LO_LVL_MAX					0x0211	/* uint16 */
-#define CSR_PSKEY_LO_ADC_AMPL_MIN				0x0212	/* uint16 */
-#define CSR_PSKEY_LO_ADC_AMPL_MAX				0x0213	/* uint16 */
-#define CSR_PSKEY_IQ_TRIM_CHANNEL				0x0214	/* uint16 */
-#define CSR_PSKEY_IQ_TRIM_GAIN					0x0215	/* uint16 */
-#define CSR_PSKEY_IQ_TRIM_ENABLE				0x0216	/* iq_trim_enable_flag */
-#define CSR_PSKEY_TX_OFFSET_HALF_MHZ				0x0217	/* int16 */
-#define CSR_PSKEY_GBL_MISC_ENABLES				0x0221	/* uint16 */
-#define CSR_PSKEY_UART_SLEEP_TIMEOUT				0x0222	/* uint16 */
-#define CSR_PSKEY_DEEP_SLEEP_STATE				0x0229	/* deep_sleep_state */
-#define CSR_PSKEY_IQ_ENABLE_PHASE_TRIM				0x022d	/* bool */
-#define CSR_PSKEY_HCI_HANDLE_FREEZE_PERIOD			0x0237	/* TIME */
-#define CSR_PSKEY_MAX_FROZEN_HCI_HANDLES			0x0238	/* uint16 */
-#define CSR_PSKEY_PAGETABLE_DESTRUCTION_DELAY			0x0239	/* TIME */
-#define CSR_PSKEY_IQ_TRIM_PIO_SETTINGS				0x023a	/* uint8 */
-#define CSR_PSKEY_USE_EXTERNAL_CLOCK				0x023b	/* bool */
-#define CSR_PSKEY_DEEP_SLEEP_WAKE_CTS				0x023c	/* uint16 */
-#define CSR_PSKEY_FC_HC2H_FLUSH_DELAY				0x023d	/* TIME */
-#define CSR_PSKEY_RX_HIGHSIDE					0x023e	/* bool */
-#define CSR_PSKEY_TX_PRE_LVL					0x0240	/* uint8 */
-#define CSR_PSKEY_RX_SINGLE_ENDED				0x0242	/* bool */
-#define CSR_PSKEY_TX_FILTER_CONFIG				0x0243	/* uint32 */
-#define CSR_PSKEY_CLOCK_REQUEST_ENABLE				0x0246	/* uint16 */
-#define CSR_PSKEY_RX_MIN_ATTEN					0x0249	/* uint16 */
-#define CSR_PSKEY_XTAL_TARGET_AMPLITUDE				0x024b	/* uint8 */
-#define CSR_PSKEY_PCM_MIN_CPU_CLOCK				0x024d	/* uint16 */
-#define CSR_PSKEY_HOST_INTERFACE_PIO_USB			0x0250	/* uint16 */
-#define CSR_PSKEY_CPU_IDLE_MODE					0x0251	/* cpu_idle_mode */
-#define CSR_PSKEY_DEEP_SLEEP_CLEAR_RTS				0x0252	/* bool */
-#define CSR_PSKEY_RF_RESONANCE_TRIM				0x0254	/* uint16 */
-#define CSR_PSKEY_DEEP_SLEEP_PIO_WAKE				0x0255	/* uint16 */
-#define CSR_PSKEY_DRAIN_BORE_TIMERS				0x0256	/* uint32[] */
-#define CSR_PSKEY_DRAIN_TX_POWER_BASE				0x0257	/* uint16 */
-#define CSR_PSKEY_MODULE_ID					0x0259	/* uint32 */
-#define CSR_PSKEY_MODULE_DESIGN					0x025a	/* uint16 */
-#define CSR_PSKEY_MODULE_SECURITY_CODE				0x025c	/* uint16[] */
-#define CSR_PSKEY_VM_DISABLE					0x025d	/* bool */
-#define CSR_PSKEY_MOD_MANUF0					0x025e	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF1					0x025f	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF2					0x0260	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF3					0x0261	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF4					0x0262	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF5					0x0263	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF6					0x0264	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF7					0x0265	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF8					0x0266	/* uint16[] */
-#define CSR_PSKEY_MOD_MANUF9					0x0267	/* uint16[] */
-#define CSR_PSKEY_DUT_VM_DISABLE				0x0268	/* bool */
-#define CSR_PSKEY_USR0						0x028a	/* uint16[] */
-#define CSR_PSKEY_USR1						0x028b	/* uint16[] */
-#define CSR_PSKEY_USR2						0x028c	/* uint16[] */
-#define CSR_PSKEY_USR3						0x028d	/* uint16[] */
-#define CSR_PSKEY_USR4						0x028e	/* uint16[] */
-#define CSR_PSKEY_USR5						0x028f	/* uint16[] */
-#define CSR_PSKEY_USR6						0x0290	/* uint16[] */
-#define CSR_PSKEY_USR7						0x0291	/* uint16[] */
-#define CSR_PSKEY_USR8						0x0292	/* uint16[] */
-#define CSR_PSKEY_USR9						0x0293	/* uint16[] */
-#define CSR_PSKEY_USR10						0x0294	/* uint16[] */
-#define CSR_PSKEY_USR11						0x0295	/* uint16[] */
-#define CSR_PSKEY_USR12						0x0296	/* uint16[] */
-#define CSR_PSKEY_USR13						0x0297	/* uint16[] */
-#define CSR_PSKEY_USR14						0x0298	/* uint16[] */
-#define CSR_PSKEY_USR15						0x0299	/* uint16[] */
-#define CSR_PSKEY_USR16						0x029a	/* uint16[] */
-#define CSR_PSKEY_USR17						0x029b	/* uint16[] */
-#define CSR_PSKEY_USR18						0x029c	/* uint16[] */
-#define CSR_PSKEY_USR19						0x029d	/* uint16[] */
-#define CSR_PSKEY_USR20						0x029e	/* uint16[] */
-#define CSR_PSKEY_USR21						0x029f	/* uint16[] */
-#define CSR_PSKEY_USR22						0x02a0	/* uint16[] */
-#define CSR_PSKEY_USR23						0x02a1	/* uint16[] */
-#define CSR_PSKEY_USR24						0x02a2	/* uint16[] */
-#define CSR_PSKEY_USR25						0x02a3	/* uint16[] */
-#define CSR_PSKEY_USR26						0x02a4	/* uint16[] */
-#define CSR_PSKEY_USR27						0x02a5	/* uint16[] */
-#define CSR_PSKEY_USR28						0x02a6	/* uint16[] */
-#define CSR_PSKEY_USR29						0x02a7	/* uint16[] */
-#define CSR_PSKEY_USR30						0x02a8	/* uint16[] */
-#define CSR_PSKEY_USR31						0x02a9	/* uint16[] */
-#define CSR_PSKEY_USR32						0x02aa	/* uint16[] */
-#define CSR_PSKEY_USR33						0x02ab	/* uint16[] */
-#define CSR_PSKEY_USR34						0x02ac	/* uint16[] */
-#define CSR_PSKEY_USR35						0x02ad	/* uint16[] */
-#define CSR_PSKEY_USR36						0x02ae	/* uint16[] */
-#define CSR_PSKEY_USR37						0x02af	/* uint16[] */
-#define CSR_PSKEY_USR38						0x02b0	/* uint16[] */
-#define CSR_PSKEY_USR39						0x02b1	/* uint16[] */
-#define CSR_PSKEY_USR40						0x02b2	/* uint16[] */
-#define CSR_PSKEY_USR41						0x02b3	/* uint16[] */
-#define CSR_PSKEY_USR42						0x02b4	/* uint16[] */
-#define CSR_PSKEY_USR43						0x02b5	/* uint16[] */
-#define CSR_PSKEY_USR44						0x02b6	/* uint16[] */
-#define CSR_PSKEY_USR45						0x02b7	/* uint16[] */
-#define CSR_PSKEY_USR46						0x02b8	/* uint16[] */
-#define CSR_PSKEY_USR47						0x02b9	/* uint16[] */
-#define CSR_PSKEY_USR48						0x02ba	/* uint16[] */
-#define CSR_PSKEY_USR49						0x02bb	/* uint16[] */
-#define CSR_PSKEY_USB_VERSION					0x02bc	/* uint16 */
-#define CSR_PSKEY_USB_DEVICE_CLASS_CODES			0x02bd	/* usbclass */
-#define CSR_PSKEY_USB_VENDOR_ID					0x02be	/* uint16 */
-#define CSR_PSKEY_USB_PRODUCT_ID				0x02bf	/* uint16 */
-#define CSR_PSKEY_USB_MANUF_STRING				0x02c1	/* unicodestring */
-#define CSR_PSKEY_USB_PRODUCT_STRING				0x02c2	/* unicodestring */
-#define CSR_PSKEY_USB_SERIAL_NUMBER_STRING			0x02c3	/* unicodestring */
-#define CSR_PSKEY_USB_CONFIG_STRING				0x02c4	/* unicodestring */
-#define CSR_PSKEY_USB_ATTRIBUTES				0x02c5	/* uint8 */
-#define CSR_PSKEY_USB_MAX_POWER					0x02c6	/* uint16 */
-#define CSR_PSKEY_USB_BT_IF_CLASS_CODES				0x02c7	/* usbclass */
-#define CSR_PSKEY_USB_LANGID					0x02c9	/* uint16 */
-#define CSR_PSKEY_USB_DFU_CLASS_CODES				0x02ca	/* usbclass */
-#define CSR_PSKEY_USB_DFU_PRODUCT_ID				0x02cb	/* uint16 */
-#define CSR_PSKEY_USB_PIO_DETACH				0x02ce	/* uint16 */
-#define CSR_PSKEY_USB_PIO_WAKEUP				0x02cf	/* uint16 */
-#define CSR_PSKEY_USB_PIO_PULLUP				0x02d0	/* uint16 */
-#define CSR_PSKEY_USB_PIO_VBUS					0x02d1	/* uint16 */
-#define CSR_PSKEY_USB_PIO_WAKE_TIMEOUT				0x02d2	/* uint16 */
-#define CSR_PSKEY_USB_PIO_RESUME				0x02d3	/* uint16 */
-#define CSR_PSKEY_USB_BT_SCO_IF_CLASS_CODES			0x02d4	/* usbclass */
-#define CSR_PSKEY_USB_SUSPEND_PIO_LEVEL				0x02d5	/* uint16 */
-#define CSR_PSKEY_USB_SUSPEND_PIO_DIR				0x02d6	/* uint16 */
-#define CSR_PSKEY_USB_SUSPEND_PIO_MASK				0x02d7	/* uint16 */
-#define CSR_PSKEY_USB_ENDPOINT_0_MAX_PACKET_SIZE		0x02d8	/* uint8 */
-#define CSR_PSKEY_USB_CONFIG					0x02d9	/* uint16 */
-#define CSR_PSKEY_RADIOTEST_ATTEN_INIT				0x0320	/* uint16 */
-#define CSR_PSKEY_RADIOTEST_FIRST_TRIM_TIME			0x0326	/* TIME */
-#define CSR_PSKEY_RADIOTEST_SUBSEQUENT_TRIM_TIME		0x0327	/* TIME */
-#define CSR_PSKEY_RADIOTEST_LO_LVL_TRIM_ENABLE			0x0328	/* bool */
-#define CSR_PSKEY_RADIOTEST_DISABLE_MODULATION			0x032c	/* bool */
-#define CSR_PSKEY_RFCOMM_FCON_THRESHOLD				0x0352	/* uint16 */
-#define CSR_PSKEY_RFCOMM_FCOFF_THRESHOLD			0x0353	/* uint16 */
-#define CSR_PSKEY_IPV6_STATIC_ADDR				0x0354	/* uint16[] */
-#define CSR_PSKEY_IPV4_STATIC_ADDR				0x0355	/* uint32 */
-#define CSR_PSKEY_IPV6_STATIC_PREFIX_LEN			0x0356	/* uint8 */
-#define CSR_PSKEY_IPV6_STATIC_ROUTER_ADDR			0x0357	/* uint16[] */
-#define CSR_PSKEY_IPV4_STATIC_SUBNET_MASK			0x0358	/* uint32 */
-#define CSR_PSKEY_IPV4_STATIC_ROUTER_ADDR			0x0359	/* uint32 */
-#define CSR_PSKEY_MDNS_NAME					0x035a	/* char[] */
-#define CSR_PSKEY_FIXED_PIN					0x035b	/* uint8[] */
-#define CSR_PSKEY_MDNS_PORT					0x035c	/* uint16 */
-#define CSR_PSKEY_MDNS_TTL					0x035d	/* uint8 */
-#define CSR_PSKEY_MDNS_IPV4_ADDR				0x035e	/* uint32 */
-#define CSR_PSKEY_ARP_CACHE_TIMEOUT				0x035f	/* uint16 */
-#define CSR_PSKEY_HFP_POWER_TABLE				0x0360	/* uint16[] */
-#define CSR_PSKEY_DRAIN_BORE_TIMER_COUNTERS			0x03e7	/* uint32[] */
-#define CSR_PSKEY_DRAIN_BORE_COUNTERS				0x03e6	/* uint32[] */
-#define CSR_PSKEY_LOOP_FILTER_TRIM				0x03e4	/* uint16 */
-#define CSR_PSKEY_DRAIN_BORE_CURRENT_PEAK			0x03e3	/* uint32[] */
-#define CSR_PSKEY_VM_E2_CACHE_LIMIT				0x03e2	/* uint16 */
-#define CSR_PSKEY_FORCE_16MHZ_REF_PIO				0x03e1	/* uint16 */
-#define CSR_PSKEY_CDMA_LO_REF_LIMITS				0x03df	/* uint16 */
-#define CSR_PSKEY_CDMA_LO_ERROR_LIMITS				0x03de	/* uint16 */
-#define CSR_PSKEY_CLOCK_STARTUP_DELAY				0x03dd	/* uint16 */
-#define CSR_PSKEY_DEEP_SLEEP_CORRECTION_FACTOR			0x03dc	/* int16 */
-#define CSR_PSKEY_TEMPERATURE_CALIBRATION			0x03db	/* temperature_calibrat=
ion */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA		0x03da	/* temperature_=
calibration[] */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL		0x03d9	/* temperature_c=
alibration[] */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB			0x03d8	/* temperature_calib=
ration[] */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_ANA_FTRIM		0x03d7	/* temperature_ca=
libration[] */
-#define CSR_PSKEY_TEST_DELTA_OFFSET				0x03d6	/* uint16 */
-#define CSR_PSKEY_RX_DYNAMIC_LVL_OFFSET				0x03d4	/* uint16 */
-#define CSR_PSKEY_TEST_FORCE_OFFSET				0x03d3	/* bool */
-#define CSR_PSKEY_RF_TRAP_BAD_DIVISION_RATIOS			0x03cf	/* uint16 */
-#define CSR_PSKEY_RADIOTEST_CDMA_LO_REF_LIMITS			0x03ce	/* uint16 */
-#define CSR_PSKEY_INITIAL_BOOTMODE				0x03cd	/* int16 */
-#define CSR_PSKEY_ONCHIP_HCI_CLIENT				0x03cc	/* bool */
-#define CSR_PSKEY_RX_ATTEN_BACKOFF				0x03ca	/* uint16 */
-#define CSR_PSKEY_RX_ATTEN_UPDATE_RATE				0x03c9	/* uint16 */
-#define CSR_PSKEY_SYNTH_TXRX_THRESHOLDS				0x03c7	/* uint16 */
-#define CSR_PSKEY_MIN_WAIT_STATES				0x03c6	/* uint16 */
-#define CSR_PSKEY_RSSI_CORRECTION				0x03c5	/* int8 */
-#define CSR_PSKEY_SCHED_THROTTLE_TIMEOUT			0x03c4	/* TIME */
-#define CSR_PSKEY_DEEP_SLEEP_USE_EXTERNAL_CLOCK			0x03c3	/* bool */
-#define CSR_PSKEY_TRIM_RADIO_FILTERS				0x03c2	/* uint16 */
-#define CSR_PSKEY_TRANSMIT_OFFSET				0x03c1	/* int16 */
-#define CSR_PSKEY_USB_VM_CONTROL				0x03c0	/* bool */
-#define CSR_PSKEY_MR_ANA_RX_FTRIM				0x03bf	/* uint16 */
-#define CSR_PSKEY_I2C_CONFIG					0x03be	/* uint16 */
-#define CSR_PSKEY_IQ_LVL_RX					0x03bd	/* uint16 */
-#define CSR_PSKEY_MR_TX_FILTER_CONFIG				0x03bb	/* uint32 */
-#define CSR_PSKEY_MR_TX_CONFIG2					0x03ba	/* uint16 */
-#define CSR_PSKEY_USB_DONT_RESET_BOOTMODE_ON_HOST_RESET		0x03b9	/* bool */
-#define CSR_PSKEY_LC_USE_THROTTLING				0x03b8	/* bool */
-#define CSR_PSKEY_CHARGER_TRIM					0x03b7	/* uint16 */
-#define CSR_PSKEY_CLOCK_REQUEST_FEATURES			0x03b6	/* uint16 */
-#define CSR_PSKEY_TRANSMIT_OFFSET_CLASS1			0x03b4	/* int16 */
-#define CSR_PSKEY_TX_AVOID_PA_CLASS1_PIO			0x03b3	/* uint16 */
-#define CSR_PSKEY_MR_PIO_CONFIG					0x03b2	/* uint16 */
-#define CSR_PSKEY_UART_CONFIG2					0x03b1	/* uint8 */
-#define CSR_PSKEY_CLASS1_IQ_LVL					0x03b0	/* uint16 */
-#define CSR_PSKEY_CLASS1_TX_CONFIG2				0x03af	/* uint16 */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA_CLASS1	0x03ae	/* temper=
ature_calibration[] */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_EXTERNAL_PA_CLASS1	0x03ad	/* temper=
ature_calibration[] */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL_MR		0x03ac	/* temperatur=
e_calibration[] */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_HEADER		0x03ab	/* temperat=
ure_calibration[] */
-#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_PAYLOAD		0x03aa	/* tempera=
ture_calibration[] */
-#define CSR_PSKEY_RX_MR_EQ_TAPS					0x03a9	/* uint16[] */
-#define CSR_PSKEY_TX_PRE_LVL_CLASS1				0x03a8	/* uint8 */
-#define CSR_PSKEY_ANALOGUE_ATTENUATOR				0x03a7	/* bool */
-#define CSR_PSKEY_MR_RX_FILTER_TRIM				0x03a6	/* uint16 */
-#define CSR_PSKEY_MR_RX_FILTER_RESPONSE				0x03a5	/* int16[] */
-#define CSR_PSKEY_PIO_WAKEUP_STATE				0x039f	/* uint16 */
-#define CSR_PSKEY_MR_TX_IF_ATTEN_OFF_TEMP			0x0394	/* int16 */
-#define CSR_PSKEY_LO_DIV_LATCH_BYPASS				0x0393	/* bool */
-#define CSR_PSKEY_LO_VCO_STANDBY				0x0392	/* bool */
-#define CSR_PSKEY_SLOW_CLOCK_FILTER_SHIFT			0x0391	/* uint16 */
-#define CSR_PSKEY_SLOW_CLOCK_FILTER_DIVIDER			0x0390	/* uint16 */
-#define CSR_PSKEY_USB_ATTRIBUTES_POWER				0x03f2	/* bool */
-#define CSR_PSKEY_USB_ATTRIBUTES_WAKEUP				0x03f3	/* bool */
-#define CSR_PSKEY_DFU_ATTRIBUTES_MANIFESTATION_TOLERANT		0x03f4	/* bool */
-#define CSR_PSKEY_DFU_ATTRIBUTES_CAN_UPLOAD			0x03f5	/* bool */
-#define CSR_PSKEY_DFU_ATTRIBUTES_CAN_DOWNLOAD			0x03f6	/* bool */
-#define CSR_PSKEY_UART_CONFIG_STOP_BITS				0x03fc	/* bool */
-#define CSR_PSKEY_UART_CONFIG_PARITY_BIT			0x03fd	/* uint16 */
-#define CSR_PSKEY_UART_CONFIG_FLOW_CTRL_EN			0x03fe	/* bool */
-#define CSR_PSKEY_UART_CONFIG_RTS_AUTO_EN			0x03ff	/* bool */
-#define CSR_PSKEY_UART_CONFIG_RTS				0x0400	/* bool */
-#define CSR_PSKEY_UART_CONFIG_TX_ZERO_EN			0x0401	/* bool */
-#define CSR_PSKEY_UART_CONFIG_NON_BCSP_EN			0x0402	/* bool */
-#define CSR_PSKEY_UART_CONFIG_RX_RATE_DELAY			0x0403	/* uint16 */
-#define CSR_PSKEY_UART_SEQ_TIMEOUT				0x0405	/* uint16 */
-#define CSR_PSKEY_UART_SEQ_RETRIES				0x0406	/* uint16 */
-#define CSR_PSKEY_UART_SEQ_WINSIZE				0x0407	/* uint16 */
-#define CSR_PSKEY_UART_USE_CRC_ON_TX				0x0408	/* bool */
-#define CSR_PSKEY_UART_HOST_INITIAL_STATE			0x0409	/* hwakeup_state */
-#define CSR_PSKEY_UART_HOST_ATTENTION_SPAN			0x040a	/* uint16 */
-#define CSR_PSKEY_UART_HOST_WAKEUP_TIME				0x040b	/* uint16 */
-#define CSR_PSKEY_UART_HOST_WAKEUP_WAIT				0x040c	/* uint16 */
-#define CSR_PSKEY_BCSP_LM_MODE					0x0410	/* uint16 */
-#define CSR_PSKEY_BCSP_LM_SYNC_RETRIES				0x0411	/* uint16 */
-#define CSR_PSKEY_BCSP_LM_TSHY					0x0412	/* uint16 */
-#define CSR_PSKEY_UART_DFU_CONFIG_STOP_BITS			0x0417	/* bool */
-#define CSR_PSKEY_UART_DFU_CONFIG_PARITY_BIT			0x0418	/* uint16 */
-#define CSR_PSKEY_UART_DFU_CONFIG_FLOW_CTRL_EN			0x0419	/* bool */
-#define CSR_PSKEY_UART_DFU_CONFIG_RTS_AUTO_EN			0x041a	/* bool */
-#define CSR_PSKEY_UART_DFU_CONFIG_RTS				0x041b	/* bool */
-#define CSR_PSKEY_UART_DFU_CONFIG_TX_ZERO_EN			0x041c	/* bool */
-#define CSR_PSKEY_UART_DFU_CONFIG_NON_BCSP_EN			0x041d	/* bool */
-#define CSR_PSKEY_UART_DFU_CONFIG_RX_RATE_DELAY			0x041e	/* uint16 */
-#define CSR_PSKEY_AMUX_AIO0					0x041f	/* ana_amux_sel */
-#define CSR_PSKEY_AMUX_AIO1					0x0420	/* ana_amux_sel */
-#define CSR_PSKEY_AMUX_AIO2					0x0421	/* ana_amux_sel */
-#define CSR_PSKEY_AMUX_AIO3					0x0422	/* ana_amux_sel */
-#define CSR_PSKEY_LOCAL_NAME_SIMPLIFIED				0x0423	/* local_name_complete */
-#define CSR_PSKEY_EXTENDED_STUB					0x2001	/* uint16 */
-
-char *csr_builddeftostr(uint16_t def);
-char *csr_buildidtostr(uint16_t id);
-char *csr_chipvertostr(uint16_t ver, uint16_t rev);
-char *csr_pskeytostr(uint16_t pskey);
-char *csr_pskeytoval(uint16_t pskey);
-
-int csr_open_hci(char *device);
-int csr_read_hci(uint16_t varid, uint8_t *value, uint16_t length);
-int csr_write_hci(uint16_t varid, uint8_t *value, uint16_t length);
-void csr_close_hci(void);
-
-int csr_open_usb(char *device);
-int csr_read_usb(uint16_t varid, uint8_t *value, uint16_t length);
-int csr_write_usb(uint16_t varid, uint8_t *value, uint16_t length);
-void csr_close_usb(void);
-
-int csr_open_bcsp(char *device, speed_t bcsp_rate);
-int csr_read_bcsp(uint16_t varid, uint8_t *value, uint16_t length);
-int csr_write_bcsp(uint16_t varid, uint8_t *value, uint16_t length);
-void csr_close_bcsp(void);
-
-int csr_open_h4(char *device);
-int csr_read_h4(uint16_t varid, uint8_t *value, uint16_t length);
-int csr_write_h4(uint16_t varid, uint8_t *value, uint16_t length);
-void csr_close_h4(void);
-
-int csr_open_3wire(char *device);
-int csr_read_3wire(uint16_t varid, uint8_t *value, uint16_t length);
-int csr_write_3wire(uint16_t varid, uint8_t *value, uint16_t length);
-void csr_close_3wire(void);
-
-int csr_write_varid_valueless(int dd, uint16_t seqnum, uint16_t varid);
-int csr_write_varid_complex(int dd, uint16_t seqnum, uint16_t varid, uint8=
_t *value, uint16_t length);
-int csr_read_varid_complex(int dd, uint16_t seqnum, uint16_t varid, uint8_=
t *value, uint16_t length);
-int csr_read_varid_uint16(int dd, uint16_t seqnum, uint16_t varid, uint16_=
t *value);
-int csr_read_varid_uint32(int dd, uint16_t seqnum, uint16_t varid, uint32_=
t *value);
-int csr_read_pskey_complex(int dd, uint16_t seqnum, uint16_t pskey, uint16=
_t stores, uint8_t *value, uint16_t length);
-int csr_write_pskey_complex(int dd, uint16_t seqnum, uint16_t pskey, uint1=
6_t stores, uint8_t *value, uint16_t length);
-int csr_read_pskey_uint16(int dd, uint16_t seqnum, uint16_t pskey, uint16_=
t stores, uint16_t *value);
-int csr_write_pskey_uint16(int dd, uint16_t seqnum, uint16_t pskey, uint16=
_t stores, uint16_t value);
-int csr_read_pskey_uint32(int dd, uint16_t seqnum, uint16_t pskey, uint16_=
t stores, uint32_t *value);
-int csr_write_pskey_uint32(int dd, uint16_t seqnum, uint16_t pskey, uint16=
_t stores, uint32_t value);
-
-int psr_put(uint16_t pskey, uint8_t *value, uint16_t size);
-int psr_get(uint16_t *pskey, uint8_t *value, uint16_t *size);
-int psr_read(const char *filename);
-int psr_print(void);
diff --git a/tools/csr_3wire.c b/tools/csr_3wire.c
deleted file mode 100644
index 33fcf389a..000000000
--- a/tools/csr_3wire.c
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 =
 USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <stdint.h>
-
-#include "csr.h"
-
-static uint16_t seqnum =3D 0x0000;
-
-int csr_open_3wire(char *device)
-{
-	fprintf(stderr, "Transport not implemented\n");
-
-	return -1;
-}
-
-static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid, u=
int8_t *value, uint16_t length)
-{
-	errno =3D EIO;
-
-	return -1;
-}
-
-int csr_read_3wire(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0000, seqnum++, varid, value, length);
-}
-
-int csr_write_3wire(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0002, seqnum++, varid, value, length);
-}
-
-void csr_close_3wire(void)
-{
-}
diff --git a/tools/csr_bcsp.c b/tools/csr_bcsp.c
deleted file mode 100644
index e3eea34df..000000000
--- a/tools/csr_bcsp.c
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 =
 USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdint.h>
-#include <termios.h>
-
-#include "csr.h"
-#include "ubcsp.h"
-
-static uint16_t seqnum =3D 0x0000;
-
-static int fd =3D -1;
-
-static struct ubcsp_packet send_packet;
-static uint8_t send_buffer[512];
-
-static struct ubcsp_packet receive_packet;
-static uint8_t receive_buffer[512];
-
-int csr_open_bcsp(char *device, speed_t bcsp_rate)
-{
-	struct termios ti;
-	uint8_t delay, activity =3D 0x00;
-	int timeout =3D 0;
-
-	if (!device)
-		device =3D "/dev/ttyS0";
-
-	fd =3D open(device, O_RDWR | O_NOCTTY);
-	if (fd < 0) {
-		fprintf(stderr, "Can't open serial port: %s (%d)\n",
-						strerror(errno), errno);
-		return -1;
-	}
-
-	tcflush(fd, TCIOFLUSH);
-
-	if (tcgetattr(fd, &ti) < 0) {
-		fprintf(stderr, "Can't get port settings: %s (%d)\n",
-						strerror(errno), errno);
-		close(fd);
-		return -1;
-	}
-
-	cfmakeraw(&ti);
-
-	ti.c_cflag |=3D  CLOCAL;
-	ti.c_cflag &=3D ~CRTSCTS;
-	ti.c_cflag |=3D  PARENB;
-	ti.c_cflag &=3D ~PARODD;
-	ti.c_cflag &=3D ~CSIZE;
-	ti.c_cflag |=3D  CS8;
-	ti.c_cflag &=3D ~CSTOPB;
-
-	ti.c_cc[VMIN] =3D 1;
-	ti.c_cc[VTIME] =3D 0;
-
-	cfsetospeed(&ti, bcsp_rate);
-
-	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
-		fprintf(stderr, "Can't change port settings: %s (%d)\n",
-						strerror(errno), errno);
-		close(fd);
-		return -1;
-	}
-
-	tcflush(fd, TCIOFLUSH);
-
-	if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK) < 0) {
-		fprintf(stderr, "Can't set non blocking mode: %s (%d)\n",
-						strerror(errno), errno);
-		close(fd);
-		return -1;
-	}
-
-	memset(&send_packet, 0, sizeof(send_packet));
-	memset(&receive_packet, 0, sizeof(receive_packet));
-
-	ubcsp_initialize();
-
-	send_packet.length =3D 512;
-	send_packet.payload =3D send_buffer;
-
-	receive_packet.length =3D 512;
-	receive_packet.payload =3D receive_buffer;
-
-	ubcsp_receive_packet(&receive_packet);
-
-	while (1) {
-		delay =3D ubcsp_poll(&activity);
-
-		if (activity & UBCSP_PACKET_SENT)
-			break;
-
-		if (delay) {
-			usleep(delay * 100);
-
-			if (timeout++ > 5000) {
-				fprintf(stderr, "Initialization timed out\n");
-				return -1;
-			}
-		}
-	}
-
-	return 0;
-}
-
-void put_uart(uint8_t ch)
-{
-	if (write(fd, &ch, 1) < 0)
-		fprintf(stderr, "UART write error\n");
-}
-
-uint8_t get_uart(uint8_t *ch)
-{
-	int res =3D read(fd, ch, 1);
-	return res > 0 ? res : 0;
-}
-
-static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid, u=
int8_t *value, uint16_t length)
-{
-	unsigned char cp[254], rp[254];
-	uint8_t cmd[10];
-	uint16_t size;
-	uint8_t delay, activity =3D 0x00;
-	int timeout =3D 0, sent =3D 0;
-
-	size =3D (length < 8) ? 9 : ((length + 1) / 2) + 5;
-
-	cmd[0] =3D command & 0xff;
-	cmd[1] =3D command >> 8;
-	cmd[2] =3D size & 0xff;
-	cmd[3] =3D size >> 8;
-	cmd[4] =3D seqnum & 0xff;
-	cmd[5] =3D seqnum >> 8;
-	cmd[6] =3D varid & 0xff;
-	cmd[7] =3D varid >> 8;
-	cmd[8] =3D 0x00;
-	cmd[9] =3D 0x00;
-
-	memset(cp, 0, sizeof(cp));
-	cp[0] =3D 0x00;
-	cp[1] =3D 0xfc;
-	cp[2] =3D (size * 2) + 1;
-	cp[3] =3D 0xc2;
-	memcpy(cp + 4, cmd, sizeof(cmd));
-	memcpy(cp + 14, value, length);
-
-	receive_packet.length =3D 512;
-	ubcsp_receive_packet(&receive_packet);
-
-	send_packet.channel  =3D 5;
-	send_packet.reliable =3D 1;
-	send_packet.length   =3D (size * 2) + 4;
-	memcpy(send_packet.payload, cp, (size * 2) + 4);
-
-	ubcsp_send_packet(&send_packet);
-
-	while (1) {
-		delay =3D ubcsp_poll(&activity);
-
-		if (activity & UBCSP_PACKET_SENT) {
-			switch (varid) {
-			case CSR_VARID_COLD_RESET:
-			case CSR_VARID_WARM_RESET:
-			case CSR_VARID_COLD_HALT:
-			case CSR_VARID_WARM_HALT:
-				return 0;
-			}
-
-			sent =3D 1;
-			timeout =3D 0;
-		}
-
-		if (activity & UBCSP_PACKET_RECEIVED) {
-			if (sent && receive_packet.channel =3D=3D 5 &&
-					receive_packet.payload[0] =3D=3D 0xff) {
-				memcpy(rp, receive_packet.payload,
-							receive_packet.length);
-				break;
-			}
-
-			receive_packet.length =3D 512;
-			ubcsp_receive_packet(&receive_packet);
-			timeout =3D 0;
-		}
-
-		if (delay) {
-			usleep(delay * 100);
-
-			if (timeout++ > 5000) {
-				fprintf(stderr, "Operation timed out\n");
-				errno =3D ETIMEDOUT;
-				return -1;
-			}
-		}
-	}
-
-	if (rp[0] !=3D 0xff || rp[2] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[11] + (rp[12] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	memcpy(value, rp + 13, length);
-
-	return 0;
-}
-
-int csr_read_bcsp(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0000, seqnum++, varid, value, length);
-}
-
-int csr_write_bcsp(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0002, seqnum++, varid, value, length);
-}
-
-void csr_close_bcsp(void)
-{
-	close(fd);
-}
diff --git a/tools/csr_h4.c b/tools/csr_h4.c
deleted file mode 100644
index 2dcaec1e5..000000000
--- a/tools/csr_h4.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 =
 USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdint.h>
-#include <termios.h>
-
-#include "csr.h"
-
-static uint16_t seqnum =3D 0x0000;
-
-static int fd =3D -1;
-
-int csr_open_h4(char *device)
-{
-	struct termios ti;
-
-	if (!device)
-		device =3D "/dev/ttyS0";
-
-	fd =3D open(device, O_RDWR | O_NOCTTY);
-	if (fd < 0) {
-		fprintf(stderr, "Can't open serial port: %s (%d)\n",
-						strerror(errno), errno);
-		return -1;
-	}
-
-	tcflush(fd, TCIOFLUSH);
-
-	if (tcgetattr(fd, &ti) < 0) {
-		fprintf(stderr, "Can't get port settings: %s (%d)\n",
-						strerror(errno), errno);
-		close(fd);
-		return -1;
-	}
-
-	cfmakeraw(&ti);
-
-	ti.c_cflag |=3D CLOCAL;
-	ti.c_cflag |=3D CRTSCTS;
-
-	cfsetospeed(&ti, B38400);
-
-	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
-		fprintf(stderr, "Can't change port settings: %s (%d)\n",
-						strerror(errno), errno);
-		close(fd);
-		return -1;
-	}
-
-	tcflush(fd, TCIOFLUSH);
-
-	return 0;
-}
-
-static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid, u=
int8_t *value, uint16_t length)
-{
-	unsigned char cp[254], rp[254];
-	uint8_t cmd[10];
-	uint16_t size;
-	int len, offset =3D 3;
-
-	size =3D (length < 8) ? 9 : ((length + 1) / 2) + 5;
-
-	cmd[0] =3D command & 0xff;
-	cmd[1] =3D command >> 8;
-	cmd[2] =3D size & 0xff;
-	cmd[3] =3D size >> 8;
-	cmd[4] =3D seqnum & 0xff;
-	cmd[5] =3D seqnum >> 8;
-	cmd[6] =3D varid & 0xff;
-	cmd[7] =3D varid >> 8;
-	cmd[8] =3D 0x00;
-	cmd[9] =3D 0x00;
-
-	memset(cp, 0, sizeof(cp));
-	cp[0] =3D 0x01;
-	cp[1] =3D 0x00;
-	cp[2] =3D 0xfc;
-	cp[3] =3D (size * 2) + 1;
-	cp[4] =3D 0xc2;
-	memcpy(cp + 5, cmd, sizeof(cmd));
-	memcpy(cp + 15, value, length);
-
-	if (write(fd, cp, (size * 2) + 5) < 0)
-		return -1;
-
-	switch (varid) {
-	case CSR_VARID_COLD_RESET:
-	case CSR_VARID_WARM_RESET:
-	case CSR_VARID_COLD_HALT:
-	case CSR_VARID_WARM_HALT:
-		return 0;
-	}
-
-	do {
-		if (read(fd, rp, 1) < 1)
-			return -1;
-	} while (rp[0] !=3D 0x04);
-
-	if (read(fd, rp + 1, 2) < 2)
-		return -1;
-
-	do {
-		len =3D read(fd, rp + offset, sizeof(rp) - offset);
-		offset +=3D len;
-	} while (offset < rp[2] + 3);
-
-	if (rp[0] !=3D 0x04 || rp[1] !=3D 0xff || rp[3] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[12] + (rp[13] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	memcpy(value, rp + 14, length);
-
-	return 0;
-}
-
-int csr_read_h4(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0000, seqnum++, varid, value, length);
-}
-
-int csr_write_h4(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0002, seqnum++, varid, value, length);
-}
-
-void csr_close_h4(void)
-{
-	close(fd);
-}
diff --git a/tools/csr_hci.c b/tools/csr_hci.c
deleted file mode 100644
index d2e4ab9c6..000000000
--- a/tools/csr_hci.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 =
 USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <string.h>
-#include <sys/socket.h>
-
-#include "lib/bluetooth.h"
-#include "lib/hci.h"
-#include "lib/hci_lib.h"
-
-#include "csr.h"
-
-static uint16_t seqnum =3D 0x0000;
-
-static int dd =3D -1;
-
-int csr_open_hci(char *device)
-{
-	struct hci_dev_info di;
-	struct hci_version ver;
-	int dev =3D 0;
-
-	if (device) {
-		dev =3D hci_devid(device);
-		if (dev < 0) {
-			fprintf(stderr, "Device not available\n");
-			return -1;
-		}
-	}
-
-	dd =3D hci_open_dev(dev);
-	if (dd < 0) {
-		fprintf(stderr, "Can't open device hci%d: %s (%d)\n",
-						dev, strerror(errno), errno);
-		return -1;
-	}
-
-	if (hci_devinfo(dev, &di) < 0) {
-		fprintf(stderr, "Can't get device info for hci%d: %s (%d)\n",
-						dev, strerror(errno), errno);
-		hci_close_dev(dd);
-		return -1;
-	}
-
-	if (hci_read_local_version(dd, &ver, 1000) < 0) {
-		fprintf(stderr, "Can't read version info for hci%d: %s (%d)\n",
-						dev, strerror(errno), errno);
-		hci_close_dev(dd);
-		return -1;
-	}
-
-	if (ver.manufacturer !=3D 10) {
-		fprintf(stderr, "Unsupported manufacturer\n");
-		hci_close_dev(dd);
-		return -1;
-	}
-
-	return 0;
-}
-
-static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid, u=
int8_t *value, uint16_t length)
-{
-	unsigned char cp[254], rp[254];
-	struct hci_request rq;
-	uint8_t cmd[10];
-	uint16_t size;
-
-	size =3D (length < 8) ? 9 : ((length + 1) / 2) + 5;
-
-	cmd[0] =3D command & 0xff;
-	cmd[1] =3D command >> 8;
-	cmd[2] =3D size & 0xff;
-	cmd[3] =3D size >> 8;
-	cmd[4] =3D seqnum & 0xff;
-	cmd[5] =3D seqnum >> 8;
-	cmd[6] =3D varid & 0xff;
-	cmd[7] =3D varid >> 8;
-	cmd[8] =3D 0x00;
-	cmd[9] =3D 0x00;
-
-	memset(cp, 0, sizeof(cp));
-	cp[0] =3D 0xc2;
-	memcpy(cp + 1, cmd, sizeof(cmd));
-	memcpy(cp + 11, value, length);
-
-	switch (varid) {
-	case CSR_VARID_COLD_RESET:
-	case CSR_VARID_WARM_RESET:
-	case CSR_VARID_COLD_HALT:
-	case CSR_VARID_WARM_HALT:
-		return hci_send_cmd(dd, OGF_VENDOR_CMD, 0x00, (size * 2) + 1, cp);
-	}
-
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    =3D OGF_VENDOR_CMD;
-	rq.ocf    =3D 0x00;
-	rq.event  =3D EVT_VENDOR;
-	rq.cparam =3D cp;
-	rq.clen   =3D (size * 2) + 1;
-	rq.rparam =3D rp;
-	rq.rlen   =3D sizeof(rp);
-
-	if (hci_send_req(dd, &rq, 2000) < 0)
-		return -1;
-
-	if (rp[0] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[9] + (rp[10] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	memcpy(value, rp + 11, length);
-
-	return 0;
-}
-
-int csr_read_hci(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0000, seqnum++, varid, value, length);
-}
-
-int csr_write_hci(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0002, seqnum++, varid, value, length);
-}
-
-void csr_close_hci(void)
-{
-	hci_close_dev(dd);
-}
diff --git a/tools/csr_usb.c b/tools/csr_usb.c
deleted file mode 100644
index 32fdf1f14..000000000
--- a/tools/csr_usb.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 =
 USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <errno.h>
-#include <ctype.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <dirent.h>
-#include <limits.h>
-#include <sys/ioctl.h>
-
-#include "csr.h"
-
-#define USB_TYPE_CLASS			(0x01 << 5)
-
-#define USB_RECIP_DEVICE		0x00
-
-#define USB_ENDPOINT_IN			0x80
-#define USB_ENDPOINT_OUT		0x00
-
-struct usbfs_ctrltransfer {
-	uint8_t  bmRequestType;
-	uint8_t  bRequest;
-	uint16_t wValue;
-	uint16_t wIndex;
-	uint16_t wLength;
-	uint32_t timeout;	/* in milliseconds */
-	void *data;		/* pointer to data */
-};
-
-struct usbfs_bulktransfer {
-	unsigned int ep;
-	unsigned int len;
-	unsigned int timeout;   /* in milliseconds */
-	void *data;		/* pointer to data */
-};
-
-#define USBFS_IOCTL_CONTROL	_IOWR('U', 0, struct usbfs_ctrltransfer)
-#define USBFS_IOCTL_BULK	_IOWR('U', 2, struct usbfs_bulktransfer)
-#define USBFS_IOCTL_CLAIMINTF	_IOR('U', 15, unsigned int)
-#define USBFS_IOCTL_RELEASEINTF	_IOR('U', 16, unsigned int)
-
-static int read_value(const char *name, const char *attr, bool hex_number)
-{
-	char path[PATH_MAX];
-	FILE *file;
-	int n, value;
-
-	snprintf(path, sizeof(path), "/sys/bus/usb/devices/%s/%s", name, attr);
-
-	file =3D fopen(path, "r");
-	if (!file)
-		return -1;
-
-	n =3D fscanf(file, hex_number ? "%d" : "%04x", &value);
-	if (n !=3D 1) {
-		fclose(file);
-		return -1;
-	}
-
-	fclose(file);
-	return value;
-}
-
-#define read_hex_value(name, file) read_value((name), (file), true)
-#define read_num_value(name, file) read_value((name), (file), false)
-
-static char *check_device(const char *name)
-{
-	char path[PATH_MAX];
-	int busnum, devnum, vendor, product;
-
-	busnum =3D read_num_value(name, "busnum");
-	if (busnum < 0)
-		return NULL;
-
-	devnum =3D read_num_value(name, "devnum");
-	if (devnum < 0)
-		return NULL;
-
-	snprintf(path, sizeof(path), "/dev/bus/usb/%03u/%03u", busnum, devnum);
-
-	vendor =3D read_hex_value(name, "idVendor");
-	if (vendor < 0)
-		return NULL;
-
-	product =3D read_hex_value(name, "idProduct");
-	if (product < 0)
-		return NULL;
-
-	if (vendor !=3D 0x0a12 || product !=3D 0x0001)
-		return NULL;
-
-	return strdup(path);
-}
-
-static char *find_device(void)
-{
-	char *path =3D NULL;
-	DIR *dir;
-
-	dir =3D opendir("/sys/bus/usb/devices");
-	if (!dir)
-		return NULL;
-
-	while (1) {
-		struct dirent *d;
-
-		d =3D readdir(dir);
-		if (!d)
-			break;
-
-		if ((!isdigit(d->d_name[0]) && strncmp(d->d_name, "usb", 3))
-						|| strchr(d->d_name, ':'))
-			continue;
-
-		path =3D check_device(d->d_name);
-		if (path)
-			break;
-	}
-
-	closedir(dir);
-
-	return path;
-}
-
-static uint16_t seqnum =3D 0x0000;
-static int handle =3D -1;
-
-int csr_open_usb(char *device)
-{
-	int interface =3D 0;
-	char *path;
-
-	path =3D find_device();
-	if (!path) {
-		fprintf(stderr, "Device not available\n");
-		return -1;
-	}
-
-	handle =3D open(path, O_RDWR, O_CLOEXEC | O_NONBLOCK);
-
-	free(path);
-
-	if (handle < 0) {
-		fprintf(stderr, "Can't open device: %s (%d)\n",
-						strerror(errno), errno);
-		return -1;
-	}
-
-	if (ioctl(handle, USBFS_IOCTL_CLAIMINTF, &interface) < 0) {
-		fprintf(stderr, "Can't claim interface: %s (%d)\n",
-						strerror(errno), errno);
-		close(handle);
-		handle =3D -1;
-		return -1;
-	}
-
-	return 0;
-}
-
-static int control_write(int fd, void *data, unsigned short size)
-{
-	struct usbfs_ctrltransfer transfer;
-
-	transfer.bmRequestType =3D USB_TYPE_CLASS | USB_ENDPOINT_OUT |
-							USB_RECIP_DEVICE;
-	transfer.bRequest =3D 0;
-	transfer.wValue =3D 0;
-	transfer.wIndex =3D 0;
-	transfer.wLength =3D size,
-	transfer.timeout =3D 2000;
-	transfer.data =3D data;
-
-	if (ioctl(fd, USBFS_IOCTL_CONTROL, &transfer) < 0) {
-		fprintf(stderr, "Control transfer failed: %s (%d)\n",
-						strerror(errno), errno);
-		return -1;
-	}
-
-	return 0;
-}
-
-static int interrupt_read(int fd, unsigned char endpoint,
-					void *data, unsigned short size)
-{
-	struct usbfs_bulktransfer transfer;
-
-	transfer.ep =3D endpoint;
-	transfer.len =3D size,
-	transfer.timeout =3D 20;
-	transfer.data =3D data;
-
-	return ioctl(fd, USBFS_IOCTL_BULK, &transfer);
-}
-
-static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid,
-					uint8_t *value, uint16_t length)
-{
-	unsigned char cp[254], rp[254];
-	uint8_t cmd[10];
-	uint16_t size;
-	int len, offset =3D 0;
-
-	size =3D (length < 8) ? 9 : ((length + 1) / 2) + 5;
-
-	cmd[0] =3D command & 0xff;
-	cmd[1] =3D command >> 8;
-	cmd[2] =3D size & 0xff;
-	cmd[3] =3D size >> 8;
-	cmd[4] =3D seqnum & 0xff;
-	cmd[5] =3D seqnum >> 8;
-	cmd[6] =3D varid & 0xff;
-	cmd[7] =3D varid >> 8;
-	cmd[8] =3D 0x00;
-	cmd[9] =3D 0x00;
-
-	memset(cp, 0, sizeof(cp));
-	cp[0] =3D 0x00;
-	cp[1] =3D 0xfc;
-	cp[2] =3D (size * 2) + 1;
-	cp[3] =3D 0xc2;
-	memcpy(cp + 4, cmd, sizeof(cmd));
-	memcpy(cp + 14, value, length);
-
-	interrupt_read(handle, USB_ENDPOINT_IN | 0x01, rp, sizeof(rp));
-
-	control_write(handle, cp, (size * 2) + 4);
-
-	switch (varid) {
-	case CSR_VARID_COLD_RESET:
-	case CSR_VARID_WARM_RESET:
-	case CSR_VARID_COLD_HALT:
-	case CSR_VARID_WARM_HALT:
-		return 0;
-	}
-
-	do {
-		len =3D interrupt_read(handle, USB_ENDPOINT_IN | 0x01,
-					rp + offset, sizeof(rp) - offset);
-		if (len < 0)
-			break;
-		offset +=3D len;
-	} while (len > 0);
-
-	if (rp[0] !=3D 0xff || rp[2] !=3D 0xc2) {
-		errno =3D EIO;
-		return -1;
-	}
-
-	if ((rp[11] + (rp[12] << 8)) !=3D 0) {
-		errno =3D ENXIO;
-		return -1;
-	}
-
-	memcpy(value, rp + 13, length);
-
-	return 0;
-}
-
-int csr_read_usb(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0000, seqnum++, varid, value, length);
-}
-
-int csr_write_usb(uint16_t varid, uint8_t *value, uint16_t length)
-{
-	return do_command(0x0002, seqnum++, varid, value, length);
-}
-
-void csr_close_usb(void)
-{
-	int interface =3D 0;
-
-	ioctl(handle, USBFS_IOCTL_RELEASEINTF, &interface);
-
-	close(handle);
-	handle =3D -1;
-}
diff --git a/tools/hciconfig.c b/tools/hciconfig.c
index ddc17c4b5..a7b0b0a86 100644
--- a/tools/hciconfig.c
+++ b/tools/hciconfig.c
@@ -46,7 +46,6 @@
=20
 #include "src/textfile.h"
 #include "src/shared/util.h"
-#include "tools/csr.h"
=20
 static struct hci_dev_info di;
 static int all;
@@ -1703,30 +1702,6 @@ static void print_rev_ericsson(int dd)
 	printf("\t%s\n", buf + 1);
 }
=20
-static void print_rev_csr(int dd, uint16_t rev)
-{
-	uint16_t buildid, chipver, chiprev, maxkeylen, mapsco;
-
-	if (csr_read_varid_uint16(dd, 0, CSR_VARID_BUILDID, &buildid) < 0) {
-		printf("\t%s\n", csr_buildidtostr(rev));
-		return;
-	}
-
-	printf("\t%s\n", csr_buildidtostr(buildid));
-
-	if (!csr_read_varid_uint16(dd, 1, CSR_VARID_CHIPVER, &chipver)) {
-		if (csr_read_varid_uint16(dd, 2, CSR_VARID_CHIPREV, &chiprev) < 0)
-			chiprev =3D 0;
-		printf("\tChip version: %s\n", csr_chipvertostr(chipver, chiprev));
-	}
-
-	if (!csr_read_varid_uint16(dd, 3, CSR_VARID_MAX_CRYPT_KEY_LENGTH, &maxkey=
len))
-		printf("\tMax key size: %d bit\n", maxkeylen * 8);
-
-	if (!csr_read_pskey_uint16(dd, 4, CSR_PSKEY_HOSTIO_MAP_SCO_PCM, 0x0000, &=
mapsco))
-		printf("\tSCO mapping:  %s\n", mapsco ? "PCM" : "HCI");
-}
-
 static void print_rev_digianswer(int dd)
 {
 	struct hci_request rq;
@@ -1789,9 +1764,6 @@ static void cmd_revision(int ctl, int hdev, char *opt)
 	case 48:
 		print_rev_ericsson(dd);
 		break;
-	case 10:
-		print_rev_csr(dd, ver.hci_rev);
-		break;
 	case 12:
 		print_rev_digianswer(dd);
 		break;
diff --git a/tools/ubcsp.c b/tools/ubcsp.c
deleted file mode 100644
index b3f883a03..000000000
--- a/tools/ubcsp.c
+++ /dev/null
@@ -1,1180 +0,0 @@
-/*=0D
- *=0D
- *  BlueZ - Bluetooth protocol stack for Linux=0D
- *=0D
- *  Copyright (C) 2000-2005  CSR Ltd.=0D
- *=0D
- *=0D
- *  Permission is hereby granted, free of charge, to any person obtaining=
=0D
- *  a copy of this software and associated documentation files (the=0D
- *  "Software"), to deal in the Software without restriction, including=0D
- *  without limitation the rights to use, copy, modify, merge, publish,=0D
- *  distribute, sublicense, and/or sell copies of the Software, and to=0D
- *  permit persons to whom the Software is furnished to do so, subject to=
=0D
- *  the following conditions:=0D
- *=0D
- *  The above copyright notice and this permission notice shall be include=
d=0D
- *  in all copies or substantial portions of the Software.=0D
- *=0D
- *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,=0D
- *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF=0D
- *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.=
=0D
- *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY=0D
- *  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,=0D
- *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE=0D
- *  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.=0D
- *=0D
- */=0D
-=0D
-#ifdef HAVE_CONFIG_H=0D
-#include <config.h>=0D
-#endif=0D
-=0D
-/*************************************************************************=
****/=0D
-/*************************************************************************=
****/=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp,c                                                               =
  **/=0D
-/**                                                                       =
  **/=0D
-/** MicroBCSP - a very low cost implementation of the BCSP protocol       =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-#include "ubcsp.h"=0D
-=0D
-#if SHOW_PACKET_ERRORS || SHOW_LE_STATES=0D
-#include <stdio.h>=0D
-#include <windows.h>=0D
-#endif=0D
-=0D
-static uint16 ubcsp_calc_crc (uint8 ch, uint16 crc);=0D
-static uint16 ubcsp_crc_reverse (uint16);=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** Constant Data - ROM                                                   =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-/* This is the storage for the link establishment messages */=0D
-=0D
-static const uint8 ubcsp_le_buffer[4][4] =3D=0D
-	{=0D
-		{ 0xDA, 0xDC, 0xED, 0xED },=0D
-		{ 0xAC, 0xAF, 0xEF, 0xEE },=0D
-		{ 0xAD, 0xEF, 0xAC, 0xED },=0D
-		{ 0xDE, 0xAD, 0xD0, 0xD0 },=0D
-	};=0D
-=0D
-/* These are the link establishment headers */=0D
-/* The two version are for the CRC and non-CRC varients */=0D
-=0D
-#if UBCSP_CRC=0D
-static const uint8 ubcsp_send_le_header[4] =3D =0D
-	{=0D
-		0x40, 0x41, 0x00, 0x7E=0D
-	};=0D
-#else=0D
-static const uint8 ubcsp_send_le_header[4] =3D =0D
-	{=0D
-		0x00, 0x41, 0x00, 0xBE=0D
-	};=0D
-#endif=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** Static Data - RAM                                                     =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-/* This is the storage for all state data for ubcsp */=0D
-=0D
-static struct ubcsp_configuration ubcsp_config;=0D
-=0D
-/* This is the ACK packet header - this will be overwritten when=0D
-   we create an ack packet */=0D
-=0D
-static uint8 ubcsp_send_ack_header[4] =3D =0D
-	{=0D
-		0x00, 0x00, 0x00, 0x00=0D
-	};=0D
-=0D
-/* This is the deslip lookup table */=0D
-=0D
-static const uint8 ubcsp_deslip[2] =3D=0D
-	{=0D
-		SLIP_FRAME, SLIP_ESCAPE,=0D
-	};=0D
-=0D
-/* This is a state machine table for link establishment */=0D
-=0D
-static uint8 next_le_packet[16] =3D=0D
-	{=0D
-		ubcsp_le_sync,			// uninit=0D
-		ubcsp_le_conf,			// init=0D
-		ubcsp_le_none,			// active=0D
-		ubcsp_le_none,=0D
-		ubcsp_le_sync_resp,		// sync_resp=0D
-		ubcsp_le_sync_resp,=0D
-		ubcsp_le_none,=0D
-		ubcsp_le_none,=0D
-		ubcsp_le_none,			// conf_resp=0D
-		ubcsp_le_conf_resp,=0D
-		ubcsp_le_conf_resp,=0D
-		ubcsp_le_none,=0D
-	};=0D
-=0D
-/* This is the storage required for building send and crc data */=0D
-=0D
-static uint8 ubcsp_send_header[4];=0D
-static uint8 ubcsp_send_crc[2];=0D
-=0D
-/* This is where the receive header is stored before the payload arrives *=
/=0D
-=0D
-static uint8 ubcsp_receive_header[4];=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** Code - ROM or RAM                                                     =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_initialize                                                      =
  **/=0D
-/**                                                                       =
  **/=0D
-/** This initializes the state of the ubcsp engine to a known values      =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-void ubcsp_initialize (void)=0D
-{=0D
-	ubcsp_config.ack_number =3D 0;=0D
-	ubcsp_config.sequence_number =3D 0;=0D
-	ubcsp_config.send_ptr =3D 0;=0D
-	ubcsp_config.send_size =3D 0;=0D
-	ubcsp_config.receive_index =3D -4;=0D
-=0D
-	ubcsp_config.delay =3D 0;=0D
-=0D
-#if SHOW_LE_STATES=0D
-	printf ("Hello Link Uninitialized\n");=0D
-#endif=0D
-=0D
-	ubcsp_config.link_establishment_state =3D ubcsp_le_uninitialized;=0D
-	ubcsp_config.link_establishment_packet =3D ubcsp_le_sync;=0D
-}=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_send_packet                                                     =
  **/=0D
-/**                                                                       =
  **/=0D
-/** This sends a packet structure for sending to the ubcsp engine         =
  **/=0D
-/** This can only be called when the activity indication from ubcsp_poll  =
  **/=0D
-/** indicates that a packet can be sent with UBCSP_PACKET_SENT            =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-void ubcsp_send_packet (struct ubcsp_packet *send_packet)=0D
-{=0D
-	/* Initialize the send data to the packet we want to send */=0D
-=0D
-	ubcsp_config.send_packet =3D send_packet;=0D
-=0D
-	/* we cannot send the packet at the moment=0D
-	   when we can at the moment, just set things to 0 */=0D
-=0D
-	ubcsp_config.send_size =3D 0;=0D
-	ubcsp_config.send_ptr =3D 0;=0D
-}=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_receive_packet                                                  =
  **/=0D
-/**                                                                       =
  **/=0D
-/** This sends a packet structure for receiving to the ubcsp engine       =
  **/=0D
-/** This can only be called when the activity indication from ubcsp_poll  =
  **/=0D
-/** indicates that a packet can be sent with UBCSP_PACKET_RECEIVED        =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-void ubcsp_receive_packet (struct ubcsp_packet *receive_packet)=0D
-{=0D
-	/* Initialize the receive data to the packet we want to receive */=0D
-=0D
-	ubcsp_config.receive_packet =3D receive_packet;=0D
-=0D
-	/* setup to receive the header first */=0D
-=0D
-	ubcsp_config.receive_index =3D -4;=0D
-}=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_calc_crc                                                        =
  **/=0D
-/**                                                                       =
  **/=0D
-/** Takes the next 8 bit value ch, and updates the crc with this value    =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-=0D
-#ifdef UBCSP_CRC=0D
-=0D
-static uint16 ubcsp_calc_crc (uint8 ch, uint16 crc)=0D
-{=0D
-	/* Calculate the CRC using the above 16 entry lookup table */=0D
-=0D
-	static const uint16 crc_table[] =3D=0D
-		{=0D
-			0x0000, 0x1081, 0x2102, 0x3183,=0D
-			0x4204, 0x5285, 0x6306, 0x7387,=0D
-			0x8408, 0x9489, 0xa50a, 0xb58b,=0D
-			0xc60c, 0xd68d, 0xe70e, 0xf78f=0D
-		};=0D
-=0D
-	/* Do this four bits at a time - more code, less space */=0D
-=0D
-    crc =3D (crc >> 4) ^ crc_table[(crc ^ ch) & 0x000f];=0D
-    crc =3D (crc >> 4) ^ crc_table[(crc ^ (ch >> 4)) & 0x000f];=0D
-=0D
-	return crc;=0D
-}=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_crc_reverse                                                     =
  **/=0D
-/**                                                                       =
  **/=0D
-/** Reserves the bits in crc and returns the new value                    =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-static uint16 ubcsp_crc_reverse (uint16 crc)=0D
-{=0D
-	int32=0D
-		b,=0D
-		rev;=0D
-=0D
-	/* Reserse the bits to compute the actual CRC value */=0D
-=0D
-	for (b =3D 0, rev=3D0; b < 16; b++)=0D
-	{=0D
-		rev =3D rev << 1;=0D
-		rev |=3D (crc & 1);=0D
-		crc =3D crc >> 1;=0D
-	}=0D
-=0D
-	return rev;=0D
-}=0D
-=0D
-#endif=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_put_slip_uart                                                   =
  **/=0D
-/**                                                                       =
  **/=0D
-/** Outputs a single octet to the uart                                    =
  **/=0D
-/** If the octet needs to be escaped, then output the escape value        =
  **/=0D
-/** and then store the second octet to be output later                    =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-static void ubcsp_put_slip_uart (uint8 ch)=0D
-{=0D
-	/* output a single UART octet */=0D
-=0D
-	/* If it needs to be escaped, then output the escape octet=0D
-	   and set the send_slip_escape so that the next time we=0D
-	   output the second octet for the escape correctly.=0D
-	   This is done right at the top of ubcsp_poll */=0D
-=0D
-	if (ch =3D=3D SLIP_FRAME)=0D
-	{=0D
-		put_uart (SLIP_ESCAPE);=0D
-		ubcsp_config.send_slip_escape =3D SLIP_ESCAPE_FRAME;=0D
-	}=0D
-	else if (ch =3D=3D SLIP_ESCAPE)=0D
-	{=0D
-		put_uart (SLIP_ESCAPE);=0D
-		ubcsp_config.send_slip_escape =3D SLIP_ESCAPE_ESCAPE;=0D
-	}=0D
-	else=0D
-	{=0D
-		/* Not escaped, so just output octet */=0D
-=0D
-		put_uart (ch);=0D
-	}=0D
-}=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_which_le_payload                                                =
  **/=0D
-/**                                                                       =
  **/=0D
-/** Check the payload of this packet, and determine which of the four     =
  **/=0D
-/** link establishment packets this was.                                  =
  **/=0D
-/** Can return 5 if it is not a valid link establishment packet           =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-static uint32 ubcsp_which_le_payload (const uint8 *payload)=0D
-{=0D
-	static int32=0D
-		octet,=0D
-		loop;=0D
-=0D
-	/* Search through the various link establishment payloads to find=0D
-	   which one we have received */=0D
-=0D
-	for (loop =3D 0; loop < 4; loop ++)=0D
-	{=0D
-		for (octet =3D 0; octet < 4; octet ++)=0D
-		{=0D
-			if (payload[octet] !=3D ubcsp_le_buffer[loop][octet])=0D
-			{=0D
-				/* Bad match, just to loop again */=0D
-				goto bad_match_loop;=0D
-			}=0D
-		}=0D
-=0D
-		/* All the octets matched, return the value */=0D
-=0D
-		return loop;=0D
-=0D
-		/* Jumps out of octet loop if we got a bad match */=0D
-bad_match_loop:=0D
-		{}=0D
-	}=0D
-=0D
-	/* Non of the link establishment payloads matched - return invalid value =
*/=0D
-=0D
-	return 5;=0D
-}=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_recevied_packet                                                 =
  **/=0D
-/**                                                                       =
  **/=0D
-/** This function is called when we have a SLIP END octet and a full      =
  **/=0D
-/** packet header and possibly data in the receive packet                 =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-static uint8 ubcsp_recevied_packet (void)=0D
-{=0D
-	static uint8=0D
-		receive_crc,=0D
-		receive_seq,=0D
-		receive_ack,=0D
-		activity;=0D
-=0D
-#if UBCSP_CRC=0D
-	static int32=0D
-		loop;=0D
-=0D
-	static uint16=0D
-		crc;=0D
-#endif=0D
-=0D
-	static uint16=0D
-		length;=0D
-=0D
-	/* Keep track of what activity this received packet will cause */=0D
-=0D
-	activity =3D 0;=0D
-=0D
-	/*** Do all error checks that we can ***/=0D
-=0D
-	/* First check the header checksum */=0D
-=0D
-	if (((ubcsp_receive_header[0] + ubcsp_receive_header[1] + ubcsp_receive_h=
eader[2] + ubcsp_receive_header[3]) & 0xff) !=3D 0xff)=0D
-	{=0D
-		/* Header Checksum Error */=0D
-=0D
-#if SHOW_PACKET_ERRORS=0D
-		printf ("\n######################## Header Checksum Error %02X %02X %02X=
 %02X\n",=0D
-			ubcsp_receive_header[0],=0D
-			ubcsp_receive_header[1],=0D
-			ubcsp_receive_header[2],=0D
-			ubcsp_receive_header[3]);=0D
-#endif=0D
-=0D
-		/* If we have a header checksum error, send an ack in return=0D
-		   this gets a packet to be resent as quickly as possible */=0D
-=0D
-		ubcsp_config.send_ack =3D 1;=0D
-=0D
-		return activity;=0D
-	}=0D
-=0D
-	/* Decode the received packets header */=0D
-=0D
-	ubcsp_config.receive_packet->reliable =3D (ubcsp_receive_header[0] & 0x80=
) >> 7;=0D
-=0D
-	receive_crc =3D (ubcsp_receive_header[0] & 0x40) >> 6;=0D
-	receive_ack =3D (ubcsp_receive_header[0] & 0x38) >> 3;=0D
-	receive_seq =3D (ubcsp_receive_header[0] & 0x07);=0D
-=0D
-	ubcsp_config.receive_packet->channel =3D (ubcsp_receive_header[1] & 0x0f)=
;=0D
-=0D
-	length =3D=0D
-		((ubcsp_receive_header[1] & 0xf0) >> 4) |=0D
-		(ubcsp_receive_header[2] << 4);=0D
-=0D
-#if SHOW_PACKET_ERRORS=0D
-	if (ubcsp_config.receive_packet->reliable)=0D
-	{=0D
-		printf (" : %10d         Recv SEQ: %d ACK %d\n",=0D
-			GetTickCount () % 100000,=0D
-			receive_seq,=0D
-			receive_ack);=0D
-	}=0D
-	else if (ubcsp_config.receive_packet->channel !=3D 1)=0D
-	{=0D
-		printf (" : %10d          Recv        ACK %d\n",=0D
-			GetTickCount () % 100000,=0D
-			receive_ack);=0D
-	}=0D
-#endif=0D
-=0D
-	/* Check for length errors */=0D
-=0D
-#if UBCSP_CRC=0D
-	if (receive_crc)=0D
-	{=0D
-		/* If this packet had a CRC, then the length of the payload =0D
-		   should be 2 less than the received size of the payload */=0D
-=0D
-		if (length + 2 !=3D ubcsp_config.receive_index)=0D
-		{=0D
-			/* Slip Length Error */=0D
-=0D
-#if SHOW_PACKET_ERRORS=0D
-			printf ("\n######################## Slip Length Error (With CRC) %d,%d\=
n", length, ubcsp_config.receive_index - 2);=0D
-#endif=0D
-=0D
-			/* If we have a payload length error, send an ack in return=0D
-			   this gets a packet to be resent as quickly as possible */=0D
-=0D
-			ubcsp_config.send_ack =3D 1;=0D
-			return activity;=0D
-		}=0D
-=0D
-		/* We have a CRC at the end of this packet */=0D
-=0D
-		ubcsp_config.receive_index -=3D 2;=0D
-=0D
-		/* Calculate the packet CRC */=0D
-=0D
-		crc =3D 0xffff;=0D
-=0D
-		/* CRC the packet header */=0D
-=0D
-		for (loop =3D 0; loop < 4; loop ++)=0D
-		{=0D
-			crc =3D ubcsp_calc_crc (ubcsp_receive_header[loop], crc);=0D
-		}=0D
-=0D
-		/* CRC the packet payload - without the CRC bytes */=0D
-=0D
-		for (loop =3D 0; loop < ubcsp_config.receive_index; loop ++)=0D
-		{=0D
-			crc =3D ubcsp_calc_crc (ubcsp_config.receive_packet->payload[loop], crc=
);=0D
-		}=0D
-=0D
-		/* Reverse the CRC */=0D
-=0D
-		crc =3D ubcsp_crc_reverse (crc);=0D
-=0D
-		/* Check the CRC is correct */=0D
-=0D
-		if=0D
-		(=0D
-			(((crc & 0xff00) >> 8) !=3D ubcsp_config.receive_packet->payload[ubcsp_=
config.receive_index]) ||=0D
-			((crc & 0xff) !=3D ubcsp_config.receive_packet->payload[ubcsp_config.re=
ceive_index + 1])=0D
-		)=0D
-		{=0D
-#if SHOW_PACKET_ERRORS=0D
-			printf ("\n######################## CRC Error\n");=0D
-#endif=0D
-=0D
-			/* If we have a packet crc error, send an ack in return=0D
-			   this gets a packet to be resent as quickly as possible */=0D
-=0D
-			ubcsp_config.send_ack =3D 1;=0D
-			return activity;=0D
-		}=0D
-	}=0D
-	else=0D
-	{=0D
-#endif=0D
-		/* No CRC present, so just check the length of payload with that receive=
d */=0D
-=0D
-		if (length !=3D ubcsp_config.receive_index)=0D
-		{=0D
-			/* Slip Length Error */=0D
-=0D
-#if SHOW_PACKET_ERRORS=0D
-			printf ("\n######################## Slip Length Error (No CRC) %d,%d\n"=
, length, ubcsp_config.receive_index);=0D
-#endif=0D
-=0D
-			/* If we have a payload length error, send an ack in return=0D
-			   this gets a packet to be resent as quickly as possible */=0D
-=0D
-			ubcsp_config.send_ack =3D 1;=0D
-			return activity;=0D
-		}=0D
-#if UBCSP_CRC=0D
-	}=0D
-#endif=0D
-=0D
-	/*** We have a fully formed packet having passed all data integrity check=
s ***/=0D
-=0D
-	/* Check if we have an ACK for the last packet we sent */=0D
-=0D
-	if (receive_ack !=3D ubcsp_config.sequence_number)=0D
-	{=0D
-		/* Since we only have a window size of 1, if the ACK is not equal to SEQ=
=0D
-		   then the packet was sent */=0D
-=0D
-		if=0D
-		(=0D
-			(ubcsp_config.send_packet) &&=0D
-			(ubcsp_config.send_packet->reliable)=0D
-		)=0D
-		{=0D
-			/* We had sent a reliable packet, so clear this packet=0D
-			   Then increament the sequence number for the next packet */=0D
-=0D
-			ubcsp_config.send_packet =3D 0;=0D
-			ubcsp_config.sequence_number ++;=0D
-			ubcsp_config.delay =3D 0;=0D
-=0D
-			/* Notify the caller that we have SENT a packet */=0D
-=0D
-			activity |=3D UBCSP_PACKET_SENT;=0D
-		}=0D
-	}=0D
-=0D
-	/*** Now we can concentrate of the packet we have received ***/=0D
-=0D
-	/* Check for Link Establishment packets */=0D
-=0D
-	if (ubcsp_config.receive_packet->channel =3D=3D 1)=0D
-	{=0D
-		/* Link Establishment */=0D
-=0D
-		ubcsp_config.delay =3D 0;=0D
-=0D
-		/* Find which link establishment packet this payload means=0D
-		   This could return 5, meaning none */=0D
-=0D
-		switch (ubcsp_which_le_payload (ubcsp_config.receive_packet->payload))=0D
-		{=0D
-			case 0:=0D
-			{=0D
-				/* SYNC Recv'd */=0D
-=0D
-#if SHOW_LE_STATES=0D
-				printf ("Recv SYNC\n");=0D
-#endif=0D
-=0D
-				/* If we receive a SYNC, then we respond to it with a SYNC RESP=0D
-				   but only if we are not active.=0D
-				   If we are active, then we have a PEER RESET */=0D
-=0D
-				if (ubcsp_config.link_establishment_state < ubcsp_le_active)=0D
-				{=0D
-					ubcsp_config.link_establishment_resp =3D 1;=0D
-				}=0D
-				else=0D
-				{=0D
-					/* Peer reset !!!! */=0D
-=0D
-#if SHOW_LE_STATES=0D
-					printf ("\n\n\n\n\nPEER RESET\n\n");=0D
-#endif=0D
-=0D
-					/* Reinitialize the link */=0D
-=0D
-					ubcsp_initialize ();=0D
-=0D
-					/* Tell the host what has happened */=0D
-=0D
-					return UBCSP_PEER_RESET;=0D
-				}=0D
-				break;=0D
-			}=0D
-=0D
-			case 1:=0D
-			{=0D
-				/* SYNC RESP Recv'd */=0D
-=0D
-#if SHOW_LE_STATES=0D
-				printf ("Recv SYNC RESP\n");=0D
-#endif=0D
-=0D
-				/* If we receive a SYNC RESP, push us into the initialized state */=0D
-=0D
-				if (ubcsp_config.link_establishment_state < ubcsp_le_initialized)=0D
-				{=0D
-#if SHOW_LE_STATES=0D
-					printf ("Link Initialized\n");=0D
-#endif=0D
-					ubcsp_config.link_establishment_state =3D ubcsp_le_initialized;=0D
-				}=0D
-=0D
-				break;=0D
-			}=0D
-=0D
-			case 2:=0D
-			{=0D
-				/* CONF Recv'd */=0D
-=0D
-#if SHOW_LE_STATES=0D
-				printf ("Recv CONF\n");=0D
-#endif=0D
-=0D
-				/* If we receive a CONF, and we are initialized or active=0D
-				   then respond with a CONF RESP */=0D
-=0D
-				if (ubcsp_config.link_establishment_state >=3D ubcsp_le_initialized)=0D
-				{=0D
-					ubcsp_config.link_establishment_resp =3D 2;=0D
-				}=0D
-=0D
-				break;=0D
-			}=0D
-=0D
-			case 3:=0D
-			{=0D
-				/* CONF RESP Recv'd */=0D
-=0D
-#if SHOW_LE_STATES=0D
-				printf ("Recv CONF RESP\n");=0D
-#endif=0D
-=0D
-				/* If we received a CONF RESP, then push us into the active state */=0D
-=0D
-				if (ubcsp_config.link_establishment_state < ubcsp_le_active)=0D
-				{=0D
-#if SHOW_LE_STATES=0D
-					printf ("Link Active\n");=0D
-#endif=0D
-=0D
-					ubcsp_config.link_establishment_state =3D ubcsp_le_active;=0D
-					ubcsp_config.send_size =3D 0;=0D
-=0D
-					return activity | UBCSP_PACKET_SENT;=0D
-				}=0D
-=0D
-				break;=0D
-			}=0D
-		}=0D
-=0D
-		/* We have finished processing Link Establishment packets */=0D
-	}=0D
-	else if (ubcsp_config.receive_index)=0D
-	{=0D
-		/* We have some payload data we need to process=0D
-		   but only if we are active - otherwise, we just ignore it */=0D
-=0D
-		if (ubcsp_config.link_establishment_state =3D=3D ubcsp_le_active)=0D
-		{=0D
-			if (ubcsp_config.receive_packet->reliable)=0D
-			{=0D
-				/* If the packet we've just received was reliable=0D
-				   then send an ACK */=0D
-=0D
-				ubcsp_config.send_ack =3D 1;=0D
-=0D
-				/* We the sequence number we received is the same as =0D
-				   the last ACK we sent, then we have received a packet in sequence */=
=0D
-=0D
-				if (receive_seq =3D=3D ubcsp_config.ack_number)=0D
-				{=0D
-					/* Increase the ACK number - which will be sent in the next ACK =0D
-					   or normal packet we send */=0D
-=0D
-					ubcsp_config.ack_number ++;=0D
-=0D
-					/* Set the values in the receive_packet structure, so the caller=0D
-					   knows how much data we have */=0D
-=0D
-					ubcsp_config.receive_packet->length =3D length;=0D
-					ubcsp_config.receive_packet =3D 0;=0D
-=0D
-					/* Tell the caller that we have received a packet, and that it=0D
-					   will be ACK'ed */=0D
-=0D
-					activity |=3D UBCSP_PACKET_RECEIVED | UBCSP_PACKET_ACK;=0D
-				}=0D
-			}=0D
-			else =0D
-			{=0D
-				/* Set the values in the receive_packet structure, so the caller=0D
-				   knows how much data we have */=0D
-=0D
-				ubcsp_config.receive_packet->length =3D length;=0D
-				ubcsp_config.receive_packet =3D 0;=0D
-=0D
-				/* Tell the caller that we have received a packet */=0D
-=0D
-				activity |=3D UBCSP_PACKET_RECEIVED;=0D
-			}=0D
-		}
-	}
-
-	/* Just return any activity that occurred */
-
-	return activity;
-}
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_setup_packet                                                    =
  **/=0D
-/**                                                                       =
  **/=0D
-/** This function is called to setup a packet to be sent                  =
  **/=0D
-/** This allows just a header, or a header and payload to be sent         =
  **/=0D
-/** It also allows the header checksum to be precalcuated                 =
  **/=0D
-/** or calculated here                                                    =
  **/=0D
-/** part1 is always 4 bytes                                               =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-static void ubcsp_setup_packet (uint8 *part1, uint8 calc, uint8 *part2, ui=
nt16 len2)=0D
-{=0D
-	/* If we need to calculate the checksum, do that now */=0D
-=0D
-	if (calc)=0D
-	{=0D
-		part1[3] =3D=0D
-			~(part1[0] + part1[1] + part1[2]);=0D
-	}=0D
-=0D
-	/* Setup the header send pointer and size so we can clock this out */=0D
-=0D
-	ubcsp_config.send_ptr =3D part1;=0D
-	ubcsp_config.send_size =3D 4;=0D
-=0D
-	/* Setup the payload send pointer and size */=0D
-=0D
-	ubcsp_config.next_send_ptr =3D part2;=0D
-	ubcsp_config.next_send_size =3D len2;=0D
-=0D
-#if UBCSP_CRC=0D
-	/* Initialize the crc as required */=0D
-=0D
-	ubcsp_config.send_crc =3D -1;=0D
-=0D
-	ubcsp_config.need_send_crc =3D 1;=0D
-#endif=0D
-}=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_sent_packet                                                     =
  **/=0D
-/**                                                                       =
  **/=0D
-/** Called when we have finished sending a packet                         =
  **/=0D
-/** If this packet was unreliable, then notify caller, and clear the data =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-static uint8 ubcsp_sent_packet (void)=0D
-{=0D
-	if (ubcsp_config.send_packet)=0D
-	{=0D
-		if (!ubcsp_config.send_packet->reliable)=0D
-		{=0D
-			/* We had a packet sent that was unreliable */=0D
-=0D
-			/* Forget about this packet */=0D
-=0D
-			ubcsp_config.send_packet =3D 0;=0D
-=0D
-			/* Notify caller that they can send another one */=0D
-=0D
-			return UBCSP_PACKET_SENT;=0D
-		}=0D
-	}=0D
-=0D
-	/* We didn't have a packet, or it was reliable=0D
-	   Must wait for ACK before allowing another packet to be sent */=0D
-=0D
-	return 0;=0D
-}=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_poll                                                            =
  **/=0D
-/**                                                                       =
  **/=0D
-/** This is the main function for ubcsp                                   =
  **/=0D
-/** It performs a number of tasks                                         =
  **/=0D
-/**                                                                       =
  **/=0D
-/** 1) Send another octet to the UART - escaping as required              =
  **/=0D
-/** 2) Setup the payload to be sent after the header has been sent        =
  **/=0D
-/** 3) Send the CRC for the packet if required                            =
  **/=0D
-/**                                                                       =
  **/=0D
-/** 4) Calculate the next Link Establishment State                        =
  **/=0D
-/** 5) Send a Link Establishment packet                                   =
  **/=0D
-/** 6) Send a normal packet if available                                  =
  **/=0D
-/** 7) Send an ACK packet if required                                     =
  **/=0D
-/**                                                                       =
  **/=0D
-/** 8) Receive octets from UART and deslip them as required               =
  **/=0D
-/** 9) Place received octets into receive header or receive payload buffer=
  **/=0D
-/** 10) Process received packet when SLIP_END is received                 =
  **/=0D
-/**                                                                       =
  **/=0D
-/** 11) Keep track of ability of caller to delay recalling                =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-uint8 ubcsp_poll (uint8 *activity)=0D
-{=0D
-	uint8=0D
-		delay =3D UBCSP_POLL_TIME_IMMEDIATE;=0D
-=0D
-	uint8=0D
-		value;=0D
-=0D
-	/* Assume no activity to start with */=0D
-=0D
-	*activity =3D 0;=0D
-=0D
-	/* If we don't have to delay, then send something if we can */=0D
-=0D
-	if (!ubcsp_config.delay)=0D
-	{=0D
-		/* Do we have something we are sending to send */=0D
-=0D
-		if (ubcsp_config.send_size)=0D
-		{=0D
-			/* We have something to send so send it */=0D
-=0D
-			if (ubcsp_config.send_slip_escape)=0D
-			{=0D
-				/* Last time we send a SLIP_ESCAPE octet=0D
-				   this time send the second escape code */=0D
-=0D
-				put_uart (ubcsp_config.send_slip_escape);=0D
-=0D
-				ubcsp_config.send_slip_escape =3D 0;=0D
-			}=0D
-			else=0D
-			{=0D
-#if UBCSP_CRC=0D
-				/* get the value to send, and calculate CRC as we go */=0D
-=0D
-				value =3D *ubcsp_config.send_ptr ++;=0D
-=0D
-				ubcsp_config.send_crc =3D ubcsp_calc_crc (value, ubcsp_config.send_crc=
);=0D
-=0D
-				/* Output the octet */=0D
-=0D
-				ubcsp_put_slip_uart (value);=0D
-#else=0D
-				/* Just output the octet*/=0D
-=0D
-				ubcsp_put_slip_uart (*ubcsp_config.send_ptr ++);=0D
-#endif=0D
-			}=0D
-=0D
-			/* If we did output a SLIP_ESCAPE, then don't process the end of a bloc=
k */=0D
-=0D
-			if ((!ubcsp_config.send_slip_escape) && ((ubcsp_config.send_size =3D ub=
csp_config.send_size - 1) =3D=3D 0))=0D
-			{=0D
-				/*** We are at the end of a block - either header or payload ***/=0D
-=0D
-				/* setup the next block */=0D
-=0D
-				ubcsp_config.send_ptr =3D ubcsp_config.next_send_ptr;=0D
-				ubcsp_config.send_size =3D ubcsp_config.next_send_size;=0D
-				ubcsp_config.next_send_ptr =3D 0;=0D
-				ubcsp_config.next_send_size =3D 0;=0D
-=0D
-#if UBCSP_CRC=0D
-				/* If we have no successor block=0D
-				   then we might need to send the CRC */=0D
-=0D
-				if (!ubcsp_config.send_ptr)=0D
-				{=0D
-					if (ubcsp_config.need_send_crc)=0D
-					{=0D
-						/* reverse the CRC from what we computed along the way */=0D
-=0D
-						ubcsp_config.need_send_crc =3D 0;=0D
-=0D
-						ubcsp_config.send_crc =3D ubcsp_crc_reverse (ubcsp_config.send_crc);=
=0D
-=0D
-						/* Save in the send_crc buffer */=0D
-=0D
-						ubcsp_send_crc[0] =3D (uint8) (ubcsp_config.send_crc >> 8);=0D
-						ubcsp_send_crc[1] =3D (uint8) ubcsp_config.send_crc;=0D
-=0D
-						/* Setup to send this buffer */=0D
-=0D
-						ubcsp_config.send_ptr =3D ubcsp_send_crc;=0D
-						ubcsp_config.send_size =3D 2;=0D
-					}=0D
-					else=0D
-					{=0D
-						/* We don't need to send the crc=0D
-						   either we just have, or this packet doesn't include it */=0D
-=0D
-						/* Output the end of FRAME marker */=0D
-=0D
-						put_uart (SLIP_FRAME);=0D
-=0D
-						/* Check if this is an unreliable packet */=0D
-=0D
-						*activity |=3D ubcsp_sent_packet ();=0D
-=0D
-						/* We've sent the packet, so don't need to have be called quickly so=
on */=0D
-=0D
-						delay =3D UBCSP_POLL_TIME_DELAY;=0D
-					}=0D
-				}=0D
-#else=0D
-				/* If we have no successor block=0D
-				   then we might need to send the CRC */=0D
-=0D
-				if (!ubcsp_config.send_ptr)=0D
-				{=0D
-					/* Output the end of FRAME marker */=0D
-=0D
-					put_uart (SLIP_FRAME);=0D
-=0D
-					/* Check if this is an unreliable packet */=0D
-=0D
-					*activity |=3D ubcsp_sent_packet ();=0D
-=0D
-					/* We've sent the packet, so don't need to have be called quickly soo=
n */=0D
-=0D
-					delay =3D UBCSP_POLL_TIME_DELAY;=0D
-				}=0D
-#endif=0D
-			}=0D
-		}=0D
-		else if (ubcsp_config.link_establishment_packet =3D=3D ubcsp_le_none)=0D
-		{=0D
-			/* We didn't have something to send=0D
-			   AND we have no Link Establishment packet to send */=0D
-=0D
-			if (ubcsp_config.link_establishment_resp & 2)=0D
-			{=0D
-				/* Send the start of FRAME packet */=0D
-=0D
-				put_uart (SLIP_FRAME);=0D
-=0D
-				/* We did require a RESP packet - so setup the send */=0D
-=0D
-				ubcsp_setup_packet ((uint8*) ubcsp_send_le_header, 0, (uint8*) ubcsp_l=
e_buffer[ubcsp_le_conf_resp], 4);=0D
-=0D
-				/* We have now "sent" this packet */=0D
-=0D
-				ubcsp_config.link_establishment_resp =3D 0;=0D
-			}=0D
-			else if (ubcsp_config.send_packet)=0D
-			{=0D
-				/* There is a packet ready to be sent */=0D
-=0D
-				/* Send the start of FRAME packet */=0D
-=0D
-				put_uart (SLIP_FRAME);=0D
-=0D
-				/* Encode up the packet header using ACK and SEQ numbers */=0D
-=0D
-				ubcsp_send_header[0] =3D=0D
-					(ubcsp_config.send_packet->reliable << 7) |=0D
-#if UBCSP_CRC=0D
-					0x40 |	/* Always use CRC's */=0D
-#endif=0D
-					(ubcsp_config.ack_number << 3) | =0D
-					(ubcsp_config.sequence_number);=0D
-=0D
-				/* Encode up the packet header's channel and length */=0D
-				ubcsp_send_header[1] =3D=0D
-					(ubcsp_config.send_packet->channel & 0x0f) |=0D
-					((ubcsp_config.send_packet->length << 4) & 0xf0);=0D
-=0D
-				ubcsp_send_header[2] =3D=0D
-					(ubcsp_config.send_packet->length >> 4) & 0xff;=0D
-=0D
-				/* Let the ubcsp_setup_packet function calculate the header checksum *=
/=0D
-=0D
-				ubcsp_setup_packet ((uint8*) ubcsp_send_header, 1, ubcsp_config.send_p=
acket->payload, ubcsp_config.send_packet->length);=0D
-=0D
-				/* Don't need to send an ACK - we just place on in this packet */=0D
-=0D
-				ubcsp_config.send_ack =3D 0;=0D
-				=0D
-#if SHOW_PACKET_ERRORS=0D
-				printf (" : %10d Send %d Ack %d\n",=0D
-					GetTickCount () % 100000,=0D
-					ubcsp_config.sequence_number,=0D
-					ubcsp_config.ack_number);=0D
-#endif=0D
-			}=0D
-			else if (ubcsp_config.send_ack)=0D
-			{=0D
-				/* Send the start of FRAME packet */=0D
-=0D
-				put_uart (SLIP_FRAME);=0D
-=0D
-#if SHOW_PACKET_ERRORS=0D
-				printf (" : %10d Send ACK %d\n",=0D
-					GetTickCount () % 100000,=0D
-					ubcsp_config.ack_number);=0D
-#endif=0D
-=0D
-				/* The ack packet is already computed apart from the first octet */=0D
-=0D
-				ubcsp_send_ack_header[0] =3D=0D
-#if UBCSP_CRC=0D
-					0x40 | =0D
-#endif=0D
-					(ubcsp_config.ack_number << 3);=0D
-=0D
-				/* Let the ubcsp_setup_packet function calculate the header checksum *=
/=0D
-=0D
-				ubcsp_setup_packet (ubcsp_send_ack_header, 1, 0, 0);=0D
-=0D
-				/* We've now sent the ack */=0D
-=0D
-				ubcsp_config.send_ack =3D 0;=0D
-			}=0D
-			else=0D
-			{=0D
-				/* We didn't have a Link Establishment response packet,=0D
-				   a normal packet or an ACK packet to send */=0D
-=0D
-				delay =3D UBCSP_POLL_TIME_DELAY;=0D
-			}=0D
-		}=0D
-		else=0D
-		{=0D
-#if SHOW_PACKET_ERRORS=0D
-//			printf (" : %10d Send LE %d\n",=0D
-//				GetTickCount () % 100000,=0D
-//				ubcsp_config.link_establishment_packet);=0D
-#endif=0D
-=0D
-			/* Send A Link Establishment Message */=0D
-=0D
-			put_uart (SLIP_FRAME);=0D
-=0D
-			/* Send the Link Establishment header followed by the =0D
-			   Link Establishment packet */=0D
-=0D
-			ubcsp_setup_packet ((uint8*) ubcsp_send_le_header, 0, (uint8*) ubcsp_le=
_buffer[ubcsp_config.link_establishment_packet], 4);=0D
-=0D
-			/* start sending immediately */=0D
-=0D
-			ubcsp_config.delay =3D 0;=0D
-=0D
-			/* workout what the next link establishment packet should be */=0D
-=0D
-			ubcsp_config.link_establishment_packet =3D next_le_packet[ubcsp_config.=
link_establishment_state + ubcsp_config.link_establishment_resp * 4];=0D
-=0D
-			/* We have now delt with any response packet that we needed */=0D
-=0D
-			ubcsp_config.link_establishment_resp =3D 0;=0D
-=0D
-			return 0;=0D
-		}=0D
-	}=0D
-=0D
-	/* We now need to receive any octets from the UART */=0D
-=0D
-	while ((ubcsp_config.receive_packet) && (get_uart (&value)))=0D
-	{=0D
-		/* If the last octet was SLIP_ESCAPE, then special processing is require=
d */=0D
-=0D
-		if (ubcsp_config.receive_slip_escape)=0D
-		{=0D
-			/* WARNING - out of range values are not detected !!!=0D
-			   This will probably be caught with the checksum or CRC check */=0D
-=0D
-			value =3D ubcsp_deslip[value - SLIP_ESCAPE_FRAME];=0D
-=0D
-			ubcsp_config.receive_slip_escape =3D 0;=0D
-		}=0D
-		else=0D
-		{=0D
-			/* Check for the SLIP_FRAME octet - must be start or end of packet */=0D
-			if (value =3D=3D SLIP_FRAME)=0D
-			{=0D
-				/* If we had a full header then we have a packet */=0D
-=0D
-				if (ubcsp_config.receive_index >=3D 0)=0D
-				{=0D
-					/* process the received packet */=0D
-=0D
-					*activity |=3D ubcsp_recevied_packet ();=0D
-=0D
-					if (*activity & UBCSP_PACKET_ACK)=0D
-					{=0D
-						/* We need to ACK this packet, then don't delay its sending */=0D
-						ubcsp_config.delay =3D 0;=0D
-					}=0D
-				}=0D
-=0D
-				/* Setup to receive the next packet */=0D
-=0D
-				ubcsp_config.receive_index =3D -4;=0D
-=0D
-				/* Ok, next octet */=0D
-=0D
-				goto finished_receive;=0D
-			}=0D
-			else if (value =3D=3D SLIP_ESCAPE)=0D
-			{=0D
-				/* If we receive a SLIP_ESCAPE,=0D
-				   then remember to process the next special octet */=0D
-=0D
-				ubcsp_config.receive_slip_escape =3D 1;=0D
-=0D
-				goto finished_receive;=0D
-			}=0D
-		}=0D
-=0D
-		if (ubcsp_config.receive_index < 0)=0D
-		{=0D
-			/* We are still receiving the header */=0D
-=0D
-			ubcsp_receive_header[ubcsp_config.receive_index + 4] =3D value;=0D
-=0D
-			ubcsp_config.receive_index ++;=0D
-		}=0D
-		else if (ubcsp_config.receive_index < ubcsp_config.receive_packet->lengt=
h)
-		{
-			/* We are receiving the payload */
-			/* We might stop coming here if we are receiving a
-			   packet which is longer than the receive_packet->length
-			   given by the host */
-
-			ubcsp_config.receive_packet->payload[ubcsp_config.receive_index] =3D va=
lue;=0D
-=0D
-			ubcsp_config.receive_index ++;=0D
-		}=0D
-=0D
-finished_receive:=0D
-		{=0D
-		}=0D
-	}=0D
-=0D
-	if (ubcsp_config.delay > 0)=0D
-	{=0D
-		/* We were delayed so delay some more=0D
-		   this could be cancelled if we received something */=0D
-=0D
-		ubcsp_config.delay --;=0D
-	}=0D
-	else=0D
-	{=0D
-		/* We had no delay, so use the delay we just decided to us */=0D
-=0D
-		ubcsp_config.delay =3D delay;=0D
-	}=0D
-=0D
-	/* Report the current delay to the user */=0D
-=0D
-	return ubcsp_config.delay;=0D
-}=0D
diff --git a/tools/ubcsp.h b/tools/ubcsp.h
deleted file mode 100644
index 6a74e9a16..000000000
--- a/tools/ubcsp.h
+++ /dev/null
@@ -1,208 +0,0 @@
-/*=0D
- *=0D
- *  BlueZ - Bluetooth protocol stack for Linux=0D
- *=0D
- *  Copyright (C) 2000-2005  CSR Ltd.=0D
- *=0D
- *=0D
- *  Permission is hereby granted, free of charge, to any person obtaining=
=0D
- *  a copy of this software and associated documentation files (the=0D
- *  "Software"), to deal in the Software without restriction, including=0D
- *  without limitation the rights to use, copy, modify, merge, publish,=0D
- *  distribute, sublicense, and/or sell copies of the Software, and to=0D
- *  permit persons to whom the Software is furnished to do so, subject to=
=0D
- *  the following conditions:=0D
- *=0D
- *  The above copyright notice and this permission notice shall be include=
d=0D
- *  in all copies or substantial portions of the Software.=0D
- *=0D
- *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,=0D
- *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF=0D
- *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.=
=0D
- *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY=0D
- *  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,=0D
- *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE=0D
- *  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.=0D
- *=0D
- */=0D
-=0D
-#ifndef UBCSP_INCLUDE_H=0D
-#define UBCSP_INCLUDE_H=0D
-=0D
-/*************************************************************************=
****/=0D
-/*************************************************************************=
****/=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp.h                                                               =
  **/=0D
-/**                                                                       =
  **/=0D
-/** MicroBCSP - a very low cost implementation of the BCSP protocol       =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-/* If we wish to use CRC's, then change 0 to 1 in the next line */=0D
-#define UBCSP_CRC 1=0D
-=0D
-/* Define some basic types - change these for your architecture */=0D
-typedef unsigned char uint8;=0D
-typedef unsigned short uint16;=0D
-typedef unsigned int uint32;=0D
-typedef signed char int8;=0D
-typedef signed short int16;=0D
-typedef signed int int32;=0D
-=0D
-/* The defines below require a printf function to be available */=0D
-=0D
-/* Do we want to show packet errors in debug output */=0D
-#define SHOW_PACKET_ERRORS	0=0D
-=0D
-/* Do we want to show Link Establishment State transitions in debug output=
 */=0D
-#define SHOW_LE_STATES		0=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_packet                                                          =
  **/=0D
-/**                                                                       =
  **/=0D
-/** This is description of a bcsp packet for the upper layer              =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-struct ubcsp_packet=0D
-{=0D
-	uint8 channel;		/* Which Channel this packet is to/from */=0D
-	uint8 reliable;		/* Is this packet reliable */=0D
-	uint8 use_crc;		/* Does this packet use CRC data protection */=0D
-	uint16 length;		/* What is the length of the payload data */=0D
-	uint8 *payload;		/* The payload data itself - size of length */=0D
-};=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_configuration                                                   =
  **/=0D
-/**                                                                       =
  **/=0D
-/** This is the main configuration of the ubcsp engine                    =
  **/=0D
-/** All state variables are stored in this structure                      =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-enum ubcsp_link_establishment_state=0D
-{=0D
-	ubcsp_le_uninitialized,=0D
-	ubcsp_le_initialized,=0D
-	ubcsp_le_active=0D
-};=0D
-=0D
-enum ubcsp_link_establishment_packet=0D
-{=0D
-	ubcsp_le_sync,=0D
-	ubcsp_le_sync_resp,=0D
-	ubcsp_le_conf,=0D
-	ubcsp_le_conf_resp,=0D
-	ubcsp_le_none=0D
-};=0D
-=0D
-struct ubcsp_configuration=0D
-{=0D
-	uint8 link_establishment_state;=0D
-	uint8 link_establishment_resp;=0D
-	uint8 link_establishment_packet;=0D
-=0D
-	uint8 sequence_number:3;=0D
-	uint8 ack_number:3;=0D
-	uint8 send_ack;=0D
-	struct ubcsp_packet *send_packet;=0D
-	struct ubcsp_packet *receive_packet;=0D
-=0D
-	uint8 receive_header_checksum;=0D
-	uint8 receive_slip_escape;=0D
-	int32 receive_index;=0D
-=0D
-	uint8 send_header_checksum;=0D
-#ifdef UBCSP_CRC=0D
-	uint8 need_send_crc;=0D
-	uint16 send_crc;=0D
-#endif=0D
-	uint8 send_slip_escape;=0D
-=0D
-	uint8 *send_ptr;=0D
-	int32 send_size;=0D
-	uint8 *next_send_ptr;=0D
-	int32 next_send_size;=0D
-=0D
-	int8 delay;=0D
-};=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** ubcsp_poll sets activity from an OR of these flags                    =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-#define UBCSP_PACKET_SENT 0x01=0D
-#define UBCSP_PACKET_RECEIVED 0x02=0D
-#define UBCSP_PEER_RESET 0x04=0D
-#define UBCSP_PACKET_ACK 0x08=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** This is the functional interface for ucbsp                            =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-void ubcsp_initialize (void);=0D
-void ubcsp_send_packet (struct ubcsp_packet *send_packet);=0D
-void ubcsp_receive_packet (struct ubcsp_packet *receive_packet);=0D
-uint8 ubcsp_poll (uint8 *activity);=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** Slip Escape Values                                                    =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-#define SLIP_FRAME 0xC0=0D
-#define SLIP_ESCAPE 0xDB=0D
-#define SLIP_ESCAPE_FRAME 0xDC=0D
-#define SLIP_ESCAPE_ESCAPE 0xDD=0D
-=0D
-/*************************************************************************=
****/=0D
-/*************************************************************************=
****/=0D
-/*************************************************************************=
****/=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** These functions need to be linked into your system                    =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** put_uart outputs a single octet over the UART Tx line                 =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-extern void put_uart (uint8);=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** get_uart receives a single octet over the UART Rx line                =
  **/=0D
-/** if no octet is available, then this returns 0                         =
  **/=0D
-/** if an octet was read, then this is returned in the argument and       =
  **/=0D
-/**   the function returns 1                                              =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-extern uint8 get_uart (uint8 *);=0D
-=0D
-/*************************************************************************=
****/=0D
-/**                                                                       =
  **/=0D
-/** These defines should be changed to your systems concept of 100ms      =
  **/=0D
-/**                                                                       =
  **/=0D
-/*************************************************************************=
****/=0D
-=0D
-#define UBCSP_POLL_TIME_IMMEDIATE   0=0D
-#define UBCSP_POLL_TIME_DELAY       25=0D
-=0D
-/*************************************************************************=
****/=0D
-/*************************************************************************=
****/=0D
-/*************************************************************************=
****/=0D
-#endif
--=20
2.26.2

